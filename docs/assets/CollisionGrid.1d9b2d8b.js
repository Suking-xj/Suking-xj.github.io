import{c as t}from"./vendor.abf366c9.js";import{t as s}from"./FeatureSetReader.e8820b66.js";import{o as e}from"./definitions.6737c10c.js";const i=0,o=1,h=2;class r{constructor(t,e){this.width=t,this.height=e;const i=Math.ceil(t/1),o=Math.ceil(e/1);this._cols=i,this._rows=o,this._cells=s.create(i*o)}insertMetrics(t){const s=this._hasCollision(t);return 0===s&&this._markMetrics(t),s}getCellId(t,s){return t+s*this._cols}has(t){return this._cells.has(t)}hasRange(t,s){return this._cells.hasRange(t,s)}set(t){this._cells.set(t)}setRange(t,s){this._cells.setRange(t,s)}_hasCollision(t){const s=t.id;let e=0,i=0;t.save();do{const s=t.boundsCount;e+=s;for(let e=0;e<s;e++){const s=t.boundsComputedAnchorX(e),o=t.boundsComputedAnchorY(e),h=t.boundsWidth(e)+2,r=t.boundsHeight(e)+2;switch(this._collide(s,o,h,r)){case 2:return 2;case 1:i++}}}while(t.peekId()===s&&t.next());return t.restore(),e===i?1:0}_collide(s,e,i,o){const h=s-i/2,r=s+i/2,n=e-o/2,c=e+o/2;if(r<0||c<0||h>this.width||n>this.height)return 1;const l=t(Math.floor(h/1),0,this._cols),_=t(Math.floor(n/1),0,this._rows),a=t(Math.ceil(r/1),0,this._cols),d=t(Math.ceil(c/1),0,this._rows);for(let t=_;t<=d;t++)for(let s=l;s<=a;s++){const e=this.getCellId(s,t);if(this.has(e))return 2}return 0}_mark(s,e,i,o){const h=s-i/2,r=s+i/2,n=e-o/2,c=e+o/2,l=t(Math.floor(h/1),0,this._cols),_=t(Math.floor(n/1),0,this._rows),a=t(Math.ceil(r/1),0,this._cols),d=t(Math.ceil(c/1),0,this._rows);for(let t=_;t<=d;t++)for(let s=l;s<=a;s++){const e=this.getCellId(s,t);this.set(e)}return!1}_markMetrics(t){const s=t.id;do{const s=t.boundsCount;for(let e=0;e<s;e++){const s=t.boundsComputedAnchorX(e),i=t.boundsComputedAnchorY(e),o=t.boundsWidth(e)+2,h=t.boundsHeight(e)+2;this._mark(s,i,o,h)}}while(t.peekId()===s&&t.next())}}class n{constructor(t,s=2){this._bucketSize=t,this._rowsLength=e/t,this._colsLength=e/t,this._elementsPerBucket=s,this._grid=this._initGrid()}checkOverlap(t,s){const e=Math.floor(t/this._bucketSize),i=Math.floor(s/this._bucketSize);return e<0||e>=this._rowsLength||i<0||i>=this._colsLength||this._grid[i*this._colsLength+e]>=this._elementsPerBucket}markUsed(t,s){const e=Math.floor(t/this._bucketSize),i=Math.floor(s/this._bucketSize);this._grid[i*this._colsLength+e]+=1}reset(){this._grid=this._initGrid()}_initGrid(){return new Uint8Array(this._rowsLength*this._colsLength)}}export{r as c,i as h,n as l,h as n,o as r};
