import{f_ as t,f$ as e,g0 as n,g1 as i,g2 as s,bs as r}from"./vendor.74d5941c.js";class o{constructor(){this.code=null,this.description=null}}class a{constructor(t){this.error=new o,this.globalId=null,this.objectId=null,this.success=!1,this.uniqueId=null,this.error.description=t}}function l(t){return new a(t)}class u{constructor(t){this.globalId=null,this.success=!0,this.objectId=this.uniqueId=t}}function c(t){return new u(t)}const f=new Set;function d(t,e,n,r,o=!1,a){f.clear();for(const u in r){const e=t.get(u);if(!e)continue;const c=r[u],d=g(e,c);if(d!==c&&a&&a.push({name:"invalid-value-type",message:"attribute value was converted to match the field type",details:{field:e,originalValue:c,sanitizedValue:d}}),f.add(e.name),e&&(o||e.editable)){const t=i(e,d);if(t)return l(s(t,e,d));n[e.name]=d}}for(const i of e)if(!f.has(i.name))return l(`missing required field "${i.name}"`);return null}function g(i,s){let r=s;return"string"==typeof s&&t(i)?r=parseFloat(s):null!=s&&e(i)&&"string"!=typeof s&&(r=String(s)),n(r)}let h;function m(t,e){if(!t||!r(e))return t;if("rings"in t||"paths"in t){if(!h)throw new TypeError("geometry engine not loaded");return h.simplify(e,t)}return t}async function p(t,e){!r(t)||"esriGeometryPolygon"!==e&&"esriGeometryPolyline"!==e||await async function(){return h||(h=await import("./geometryEngineJSON.100cb9da.js"),h)}()}export{c,d,m as h,l as u,p as y};
