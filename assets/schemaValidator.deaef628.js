import { aa as s } from "./vendor.74d5941c.js";
import { n as n$1, o, r } from "./_commonjsHelpers.f2a458db.js";
function t(t2, e2 = 10) {
  const n2 = {};
  let l = t2.map(a$1).map((t3, a2) => ({ e: t3, i: a2 })).sort(({ e: t3, i: a2 }, { e: e3, i: n3 }) => {
    const l2 = t3.dataPath ? t3.dataPath.split(".").length : 0, r2 = e3.dataPath ? e3.dataPath.split(".").length : 0;
    return l2 === r2 ? a2 - n3 : r2 - l2;
  }).map(({ e: t3 }) => `${t3.dataPath ? t3.dataPath + ": " : ""}${t3.message}`).filter((t3) => {
    const a2 = !n2[t3];
    return n2[t3] = true, a2;
  });
  if (l.length > e2) {
    const t3 = "(" + (l.length - e2) + " more...)";
    l = l.slice(0, e2), l.push(t3);
  }
  return l;
}
function a$1(t2, a2 = 5) {
  if (e$1(t2.params)) {
    let e2 = t2.params.allowedValues;
    if (e2) {
      if (e2 = e2.map((t3) => JSON.stringify(t3)), e2.length > a2) {
        const t3 = "(" + (e2.length - a2) + " more...)";
        e2 = e2.slice(0, a2), e2.push(t3);
      }
      t2.message = "should be equal to one of: " + e2.join(", ");
    }
  } else
    n(t2.params) && (t2.message = "should NOT have additional property: " + t2.params.additionalProperty);
  return t2;
}
function e$1(t2) {
  return (t2 && t2.allowedValues) != null;
}
function n(t2) {
  return (t2 && t2.additionalProperty) != null;
}
var a = n$1(o(function(e2, r$1) {
  var a2;
  a2 = function() {
    return function e3(r$12, a3, s2) {
      function o2(n3, l) {
        if (!a3[n3]) {
          if (!r$12[n3]) {
            var c2 = typeof r == "function" && r;
            if (!l && c2)
              return c2(n3, true);
            if (i2)
              return i2(n3, true);
            var u = new Error("Cannot find module '" + n3 + "'");
            throw u.code = "MODULE_NOT_FOUND", u;
          }
          var h = a3[n3] = { exports: {} };
          r$12[n3][0].call(h.exports, function(e4) {
            return o2(r$12[n3][1][e4] || e4);
          }, h, h.exports, e3, r$12, a3, s2);
        }
        return a3[n3].exports;
      }
      for (var i2 = typeof r == "function" && r, n2 = 0; n2 < s2.length; n2++)
        o2(s2[n2]);
      return o2;
    }({ 1: [function(e3, r2, t2) {
      var a3 = r2.exports = function() {
        this._cache = {};
      };
      a3.prototype.put = function(e4, r3) {
        this._cache[e4] = r3;
      }, a3.prototype.get = function(e4) {
        return this._cache[e4];
      }, a3.prototype.del = function(e4) {
        delete this._cache[e4];
      }, a3.prototype.clear = function() {
        this._cache = {};
      };
    }, {}], 2: [function(e3, r2, t2) {
      var a3 = e3("./error_classes").MissingRef;
      function s2(e4, r3, t3) {
        var o2 = this;
        if (typeof this._opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        typeof r3 == "function" && (t3 = r3, r3 = void 0);
        var i2 = n2(e4).then(function() {
          var t4 = o2._addSchema(e4, void 0, r3);
          return t4.validate || function e5(s3) {
            try {
              return o2._compile(s3);
            } catch (t5) {
              if (t5 instanceof a3)
                return i3(t5);
              throw t5;
            }
            function i3(t5) {
              var a4 = t5.missingSchema;
              if (c2(a4))
                throw new Error("Schema " + a4 + " is loaded but " + t5.missingRef + " cannot be resolved");
              var i4 = o2._loadingSchemas[a4];
              return i4 || (i4 = o2._loadingSchemas[a4] = o2._opts.loadSchema(a4)).then(l, l), i4.then(function(e6) {
                if (!c2(a4))
                  return n2(e6).then(function() {
                    c2(a4) || o2.addSchema(e6, a4, void 0, r3);
                  });
              }).then(function() {
                return e5(s3);
              });
              function l() {
                delete o2._loadingSchemas[a4];
              }
              function c2(e6) {
                return o2._refs[e6] || o2._schemas[e6];
              }
            }
          }(t4);
        });
        return t3 && i2.then(function(e5) {
          t3(null, e5);
        }, t3), i2;
        function n2(e5) {
          var r4 = e5.$schema;
          return r4 && !o2.getSchema(r4) ? s2.call(o2, { $ref: r4 }, true) : Promise.resolve();
        }
      }
      r2.exports = s2;
    }, { "./error_classes": 3 }], 3: [function(e3, r2, t2) {
      var a3 = e3("./resolve");
      function s2(e4, r3, t3) {
        this.message = t3 || s2.message(e4, r3), this.missingRef = a3.url(e4, r3), this.missingSchema = a3.normalizeId(a3.fullPath(this.missingRef));
      }
      function o2(e4) {
        return e4.prototype = Object.create(Error.prototype), e4.prototype.constructor = e4;
      }
      r2.exports = { Validation: o2(function(e4) {
        this.message = "validation failed", this.errors = e4, this.ajv = this.validation = true;
      }), MissingRef: o2(s2) }, s2.message = function(e4, r3) {
        return "can't resolve reference " + r3 + " from id " + e4;
      };
    }, { "./resolve": 6 }], 4: [function(e3, r2, t2) {
      var a3 = e3("./util"), s2 = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, o2 = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], i2 = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i, n2 = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, l = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, c2 = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, u = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i, h = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, d = /^(?:\/(?:[^~/]|~0|~1)*)*$/, p = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, f = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
      function m2(e4) {
        return e4 = e4 == "full" ? "full" : "fast", a3.copy(m2[e4]);
      }
      function v(e4) {
        var r3 = e4.match(s2);
        if (!r3)
          return false;
        var t3, a4 = +r3[1], i3 = +r3[2], n3 = +r3[3];
        return 1 <= i3 && i3 <= 12 && 1 <= n3 && n3 <= (i3 != 2 || (t3 = a4) % 4 != 0 || t3 % 100 == 0 && t3 % 400 != 0 ? o2[i3] : 29);
      }
      function y(e4, r3) {
        var t3 = e4.match(i2);
        if (!t3)
          return false;
        var a4 = t3[1], s3 = t3[2], o3 = t3[3], n3 = t3[5];
        return (a4 <= 23 && s3 <= 59 && o3 <= 59 || a4 == 23 && s3 == 59 && o3 == 60) && (!r3 || n3);
      }
      (r2.exports = m2).fast = { date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/, time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, uri: /^(?:[a-z][a-z0-9+-.]*:)(?:\/?\/)?[^\s]*$/i, "uri-reference": /^(?:(?:[a-z][a-z0-9+-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i, "uri-template": c2, url: u, email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i, hostname: n2, ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/, ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i, regex: w, uuid: h, "json-pointer": d, "json-pointer-uri-fragment": p, "relative-json-pointer": f }, m2.full = { date: v, time: y, "date-time": function(e4) {
        var r3 = e4.split(g);
        return r3.length == 2 && v(r3[0]) && y(r3[1], true);
      }, uri: function(e4) {
        return P.test(e4) && l.test(e4);
      }, "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, "uri-template": c2, url: u, email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i, hostname: n2, ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/, ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i, regex: w, uuid: h, "json-pointer": d, "json-pointer-uri-fragment": p, "relative-json-pointer": f };
      var g = /t|\s/i, P = /\/|:/, E = /[^\\]\\Z/;
      function w(e4) {
        if (E.test(e4))
          return false;
        try {
          return new RegExp(e4), true;
        } catch (e5) {
          return false;
        }
      }
    }, { "./util": 10 }], 5: [function(e3, r2, t2) {
      var a3 = e3("./resolve"), s2 = e3("./util"), o2 = e3("./error_classes"), i2 = e3("fast-json-stable-stringify"), n2 = e3("../dotjs/validate"), l = s2.ucs2length, c2 = e3("fast-deep-equal"), u = o2.Validation;
      function h(e4, r3, t3, g) {
        var P = this, E = this._opts, w = [void 0], b = {}, S = [], _ = {}, F = [], x = {}, R = [], $ = function(e5, r4, t4) {
          var a4 = d.call(this, e5, r4, t4);
          return 0 <= a4 ? { index: a4, compiling: true } : (a4 = this._compilations.length, this._compilations[a4] = { schema: e5, root: r4, baseId: t4 }, { index: a4, compiling: false });
        }.call(this, e4, r3 = r3 || { schema: e4, refVal: w, refs: b }, g), j = this._compilations[$.index];
        if ($.compiling)
          return j.callValidate = k;
        var D = this._formats, O = this.RULES;
        try {
          var I = C(e4, r3, t3, g);
          j.validate = I;
          var A = j.callValidate;
          return A && (A.schema = I.schema, A.errors = null, A.refs = I.refs, A.refVal = I.refVal, A.root = I.root, A.$async = I.$async, E.sourceCode && (A.source = I.source)), I;
        } finally {
          (function(e5, r4, t4) {
            var a4 = d.call(this, e5, r4, t4);
            0 <= a4 && this._compilations.splice(a4, 1);
          }).call(this, e4, r3, g);
        }
        function k() {
          var e5 = j.validate, r4 = e5.apply(this, arguments);
          return k.errors = e5.errors, r4;
        }
        function C(e5, t4, i3, d2) {
          var g2 = !t4 || t4 && t4.schema == e5;
          if (t4.schema != r3.schema)
            return h.call(P, e5, t4, i3, d2);
          var _2 = e5.$async === true, x2 = n2({ isTop: true, schema: e5, isRoot: g2, baseId: d2, root: t4, schemaPath: "", errSchemaPath: "#", errorPath: '""', MissingRefError: o2.MissingRef, RULES: O, validate: n2, util: s2, resolve: a3, resolveRef: L, usePattern: T, useDefault: q, useCustomRule: Q, opts: E, formats: D, logger: P.logger, self: P });
          x2 = y(w, m2) + y(S, p) + y(F, f) + y(R, v) + x2, E.processCode && (x2 = E.processCode(x2, e5));
          try {
            var $2 = new Function("self", "RULES", "formats", "root", "refVal", "defaults", "customRules", "equal", "ucs2length", "ValidationError", x2)(P, O, D, r3, w, F, R, c2, l, u);
            w[0] = $2;
          } catch (e6) {
            throw P.logger.error("Error compiling schema, function code:", x2), e6;
          }
          return $2.schema = e5, $2.errors = null, $2.refs = b, $2.refVal = w, $2.root = g2 ? $2 : t4, _2 && ($2.$async = true), E.sourceCode === true && ($2.source = { code: x2, patterns: S, defaults: F }), $2;
        }
        function L(e5, s3, o3) {
          s3 = a3.url(e5, s3);
          var i3, n3, l2 = b[s3];
          if (l2 !== void 0)
            return z(i3 = w[l2], n3 = "refVal[" + l2 + "]");
          if (!o3 && r3.refs) {
            var c3 = r3.refs[s3];
            if (c3 !== void 0)
              return z(i3 = r3.refVal[c3], n3 = N(s3, i3));
          }
          n3 = N(s3);
          var u2, d2, p2, f2 = a3.call(P, C, r3, s3);
          if (f2 !== void 0 || (u2 = t3 && t3[s3]) && (f2 = a3.inlineRef(u2, E.inlineRefs) ? u2 : h.call(P, u2, r3, t3, e5)), f2 !== void 0)
            return d2 = f2, p2 = b[s3], w[p2] = d2, z(f2, n3);
          delete b[s3];
        }
        function N(e5, r4) {
          var t4 = w.length;
          return w[t4] = r4, "refVal" + (b[e5] = t4);
        }
        function z(e5, r4) {
          return typeof e5 == "object" || typeof e5 == "boolean" ? { code: r4, schema: e5, inline: true } : { code: r4, $async: e5 && !!e5.$async };
        }
        function T(e5) {
          var r4 = _[e5];
          return r4 === void 0 && (r4 = _[e5] = S.length, S[r4] = e5), "pattern" + r4;
        }
        function q(e5) {
          switch (typeof e5) {
            case "boolean":
            case "number":
              return "" + e5;
            case "string":
              return s2.toQuotedString(e5);
            case "object":
              if (e5 === null)
                return "null";
              var r4 = i2(e5), t4 = x[r4];
              return t4 === void 0 && (t4 = x[r4] = F.length, F[t4] = e5), "default" + t4;
          }
        }
        function Q(e5, r4, t4, a4) {
          if (P._opts.validateSchema !== false) {
            var s3 = e5.definition.dependencies;
            if (s3 && !s3.every(function(e6) {
              return Object.prototype.hasOwnProperty.call(t4, e6);
            }))
              throw new Error("parent schema must have all required keywords: " + s3.join(","));
            var o3 = e5.definition.validateSchema;
            if (o3 && !o3(r4)) {
              var i3 = "keyword schema is invalid: " + P.errorsText(o3.errors);
              if (P._opts.validateSchema != "log")
                throw new Error(i3);
              P.logger.error(i3);
            }
          }
          var n3, l2 = e5.definition.compile, c3 = e5.definition.inline, u2 = e5.definition.macro;
          if (l2)
            n3 = l2.call(P, r4, t4, a4);
          else if (u2)
            n3 = u2.call(P, r4, t4, a4), E.validateSchema !== false && P.validateSchema(n3, true);
          else if (c3)
            n3 = c3.call(P, a4, e5.keyword, r4, t4);
          else if (!(n3 = e5.definition.validate))
            return;
          if (n3 === void 0)
            throw new Error('custom keyword "' + e5.keyword + '"failed to compile');
          var h2 = R.length;
          return { code: "customRule" + h2, validate: R[h2] = n3 };
        }
      }
      function d(e4, r3, t3) {
        for (var a4 = 0; a4 < this._compilations.length; a4++) {
          var s3 = this._compilations[a4];
          if (s3.schema == e4 && s3.root == r3 && s3.baseId == t3)
            return a4;
        }
        return -1;
      }
      function p(e4, r3) {
        return "var pattern" + e4 + " = new RegExp(" + s2.toQuotedString(r3[e4]) + ");";
      }
      function f(e4) {
        return "var default" + e4 + " = defaults[" + e4 + "];";
      }
      function m2(e4, r3) {
        return r3[e4] === void 0 ? "" : "var refVal" + e4 + " = refVal[" + e4 + "];";
      }
      function v(e4) {
        return "var customRule" + e4 + " = customRules[" + e4 + "];";
      }
      function y(e4, r3) {
        if (!e4.length)
          return "";
        for (var t3 = "", a4 = 0; a4 < e4.length; a4++)
          t3 += r3(a4, e4);
        return t3;
      }
      r2.exports = h;
    }, { "../dotjs/validate": 38, "./error_classes": 3, "./resolve": 6, "./util": 10, "fast-deep-equal": 42, "fast-json-stable-stringify": 43 }], 6: [function(e3, r2, t2) {
      var a3 = e3("uri-js"), s2 = e3("fast-deep-equal"), o2 = e3("./util"), i2 = e3("./schema_obj"), n2 = e3("json-schema-traverse");
      function l(e4, r3, t3) {
        var a4 = this._refs[t3];
        if (typeof a4 == "string") {
          if (!this._refs[a4])
            return l.call(this, e4, r3, a4);
          a4 = this._refs[a4];
        }
        if ((a4 = a4 || this._schemas[t3]) instanceof i2)
          return p(a4.schema, this._opts.inlineRefs) ? a4.schema : a4.validate || this._compile(a4);
        var s3, o3, n3, u2 = c2.call(this, r3, t3);
        return u2 && (s3 = u2.schema, r3 = u2.root, n3 = u2.baseId), s3 instanceof i2 ? o3 = s3.validate || e4.call(this, s3.schema, r3, void 0, n3) : s3 !== void 0 && (o3 = p(s3, this._opts.inlineRefs) ? s3 : e4.call(this, s3, r3, void 0, n3)), o3;
      }
      function c2(e4, r3) {
        var t3 = a3.parse(r3), s3 = m2(t3), o3 = f(this._getId(e4.schema));
        if (Object.keys(e4.schema).length === 0 || s3 !== o3) {
          var n3 = y(s3), l2 = this._refs[n3];
          if (typeof l2 == "string")
            return function(e5, r4, t4) {
              var a4 = c2.call(this, e5, r4);
              if (a4) {
                var s4 = a4.schema, o4 = a4.baseId;
                e5 = a4.root;
                var i3 = this._getId(s4);
                return i3 && (o4 = g(o4, i3)), h.call(this, t4, o4, s4, e5);
              }
            }.call(this, e4, l2, t3);
          if (l2 instanceof i2)
            l2.validate || this._compile(l2), e4 = l2;
          else {
            if (!((l2 = this._schemas[n3]) instanceof i2))
              return;
            if (l2.validate || this._compile(l2), n3 == y(r3))
              return { schema: l2, root: e4, baseId: o3 };
            e4 = l2;
          }
          if (!e4.schema)
            return;
          o3 = f(this._getId(e4.schema));
        }
        return h.call(this, t3, o3, e4.schema, e4);
      }
      (r2.exports = l).normalizeId = y, l.fullPath = f, l.url = g, l.ids = function(e4) {
        var r3 = y(this._getId(e4)), t3 = { "": r3 }, i3 = { "": f(r3, false) }, l2 = {}, c3 = this;
        return n2(e4, { allKeys: true }, function(e5, r4, n3, u2, h2, d2, p2) {
          if (r4 !== "") {
            var f2 = c3._getId(e5), m3 = t3[u2], v2 = i3[u2] + "/" + h2;
            if (p2 !== void 0 && (v2 += "/" + (typeof p2 == "number" ? p2 : o2.escapeFragment(p2))), typeof f2 == "string") {
              f2 = m3 = y(m3 ? a3.resolve(m3, f2) : f2);
              var g2 = c3._refs[f2];
              if (typeof g2 == "string" && (g2 = c3._refs[g2]), g2 && g2.schema) {
                if (!s2(e5, g2.schema))
                  throw new Error('id "' + f2 + '" resolves to more than one schema');
              } else if (f2 != y(v2))
                if (f2[0] == "#") {
                  if (l2[f2] && !s2(e5, l2[f2]))
                    throw new Error('id "' + f2 + '" resolves to more than one schema');
                  l2[f2] = e5;
                } else
                  c3._refs[f2] = v2;
            }
            t3[r4] = m3, i3[r4] = v2;
          }
        }), l2;
      }, l.inlineRef = p, l.schema = c2;
      var u = o2.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
      function h(e4, r3, t3, a4) {
        if (e4.fragment = e4.fragment || "", e4.fragment.slice(0, 1) == "/") {
          for (var s3 = e4.fragment.split("/"), i3 = 1; i3 < s3.length; i3++) {
            var n3, l2, h2, d2 = s3[i3];
            if (d2) {
              if ((t3 = t3[d2 = o2.unescapeFragment(d2)]) === void 0)
                break;
              u[d2] || ((h2 = this._getId(t3)) && (r3 = g(r3, h2)), t3.$ref && (n3 = g(r3, t3.$ref), (l2 = c2.call(this, a4, n3)) && (t3 = l2.schema, a4 = l2.root, r3 = l2.baseId)));
            }
          }
          return t3 !== void 0 && t3 !== a4.schema ? { schema: t3, root: a4, baseId: r3 } : void 0;
        }
      }
      var d = o2.toHash(["type", "format", "pattern", "maxLength", "minLength", "maxProperties", "minProperties", "maxItems", "minItems", "maximum", "minimum", "uniqueItems", "multipleOf", "required", "enum"]);
      function p(e4, r3) {
        return r3 !== false && (r3 === void 0 || r3 === true ? function e5(r4) {
          var t3;
          if (Array.isArray(r4)) {
            for (var a4 = 0; a4 < r4.length; a4++)
              if (typeof (t3 = r4[a4]) == "object" && !e5(t3))
                return false;
          } else
            for (var s3 in r4) {
              if (s3 == "$ref")
                return false;
              if (typeof (t3 = r4[s3]) == "object" && !e5(t3))
                return false;
            }
          return true;
        }(e4) : r3 ? function e5(r4) {
          var t3, a4 = 0;
          if (Array.isArray(r4)) {
            for (var s3 = 0; s3 < r4.length; s3++)
              if (typeof (t3 = r4[s3]) == "object" && (a4 += e5(t3)), a4 == 1 / 0)
                return 1 / 0;
          } else
            for (var o3 in r4) {
              if (o3 == "$ref")
                return 1 / 0;
              if (d[o3])
                a4++;
              else if (typeof (t3 = r4[o3]) == "object" && (a4 += e5(t3) + 1), a4 == 1 / 0)
                return 1 / 0;
            }
          return a4;
        }(e4) <= r3 : void 0);
      }
      function f(e4, r3) {
        return r3 !== false && (e4 = y(e4)), m2(a3.parse(e4));
      }
      function m2(e4) {
        return a3.serialize(e4).split("#")[0] + "#";
      }
      var v = /#\/?$/;
      function y(e4) {
        return e4 ? e4.replace(v, "") : "";
      }
      function g(e4, r3) {
        return r3 = y(r3), a3.resolve(e4, r3);
      }
    }, { "./schema_obj": 8, "./util": 10, "fast-deep-equal": 42, "json-schema-traverse": 44, "uri-js": 45 }], 7: [function(e3, r2, t2) {
      var a3 = e3("../dotjs"), s2 = e3("./util").toHash;
      r2.exports = function() {
        var e4 = [{ type: "number", rules: [{ maximum: ["exclusiveMaximum"] }, { minimum: ["exclusiveMinimum"] }, "multipleOf", "format"] }, { type: "string", rules: ["maxLength", "minLength", "pattern", "format"] }, { type: "array", rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"] }, { type: "object", rules: ["maxProperties", "minProperties", "required", "dependencies", "propertyNames", { properties: ["additionalProperties", "patternProperties"] }] }, { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }], r3 = ["type", "$comment"];
        return e4.all = s2(r3), e4.types = s2(["number", "integer", "string", "array", "object", "boolean", "null"]), e4.forEach(function(t3) {
          t3.rules = t3.rules.map(function(t4) {
            var s3, o2;
            return typeof t4 == "object" && (o2 = t4[s3 = Object.keys(t4)[0]], t4 = s3, o2.forEach(function(t5) {
              r3.push(t5), e4.all[t5] = true;
            })), r3.push(t4), e4.all[t4] = { keyword: t4, code: a3[t4], implements: o2 };
          }), e4.all.$comment = { keyword: "$comment", code: a3.$comment }, t3.type && (e4.types[t3.type] = t3);
        }), e4.keywords = s2(r3.concat(["$schema", "$id", "id", "$data", "$async", "title", "description", "default", "definitions", "examples", "readOnly", "writeOnly", "contentMediaType", "contentEncoding", "additionalItems", "then", "else"])), e4.custom = {}, e4;
      };
    }, { "../dotjs": 27, "./util": 10 }], 8: [function(e3, r2, t2) {
      var a3 = e3("./util");
      r2.exports = function(e4) {
        a3.copy(e4, this);
      };
    }, { "./util": 10 }], 9: [function(e3, r2, t2) {
      r2.exports = function(e4) {
        for (var r3, t3 = 0, a3 = e4.length, s2 = 0; s2 < a3; )
          t3++, 55296 <= (r3 = e4.charCodeAt(s2++)) && r3 <= 56319 && s2 < a3 && (64512 & (r3 = e4.charCodeAt(s2))) == 56320 && s2++;
        return t3;
      };
    }, {}], 10: [function(e3, r2, t2) {
      function a3(e4, r3, t3, a4) {
        var s3 = a4 ? " !== " : " === ", o3 = a4 ? " || " : " && ", i3 = a4 ? "!" : "", n3 = a4 ? "" : "!";
        switch (e4) {
          case "null":
            return r3 + s3 + "null";
          case "array":
            return i3 + "Array.isArray(" + r3 + ")";
          case "object":
            return "(" + i3 + r3 + o3 + "typeof " + r3 + s3 + '"object"' + o3 + n3 + "Array.isArray(" + r3 + "))";
          case "integer":
            return "(typeof " + r3 + s3 + '"number"' + o3 + n3 + "(" + r3 + " % 1)" + o3 + r3 + s3 + r3 + (t3 ? o3 + i3 + "isFinite(" + r3 + ")" : "") + ")";
          case "number":
            return "(typeof " + r3 + s3 + '"' + e4 + '"' + (t3 ? o3 + i3 + "isFinite(" + r3 + ")" : "") + ")";
          default:
            return "typeof " + r3 + s3 + '"' + e4 + '"';
        }
      }
      r2.exports = { copy: function(e4, r3) {
        for (var t3 in r3 = r3 || {}, e4)
          r3[t3] = e4[t3];
        return r3;
      }, checkDataType: a3, checkDataTypes: function(e4, r3, t3) {
        switch (e4.length) {
          case 1:
            return a3(e4[0], r3, t3, true);
          default:
            var s3 = "", i3 = o2(e4);
            for (var n3 in i3.array && i3.object && (s3 = i3.null ? "(" : "(!" + r3 + " || ", s3 += "typeof " + r3 + ' !== "object")', delete i3.null, delete i3.array, delete i3.object), i3.number && delete i3.integer, i3)
              s3 += (s3 ? " && " : "") + a3(n3, r3, t3, true);
            return s3;
        }
      }, coerceToTypes: function(e4, r3) {
        if (Array.isArray(r3)) {
          for (var t3 = [], a4 = 0; a4 < r3.length; a4++) {
            var o3 = r3[a4];
            (s2[o3] || e4 === "array" && o3 === "array") && (t3[t3.length] = o3);
          }
          if (t3.length)
            return t3;
        } else {
          if (s2[r3])
            return [r3];
          if (e4 === "array" && r3 === "array")
            return ["array"];
        }
      }, toHash: o2, getProperty: l, escapeQuotes: c2, equal: e3("fast-deep-equal"), ucs2length: e3("./ucs2length"), varOccurences: function(e4, r3) {
        r3 += "[^0-9]";
        var t3 = e4.match(new RegExp(r3, "g"));
        return t3 ? t3.length : 0;
      }, varReplace: function(e4, r3, t3) {
        return r3 += "([^0-9])", t3 = t3.replace(/\$/g, "$$$$"), e4.replace(new RegExp(r3, "g"), t3 + "$1");
      }, schemaHasRules: function(e4, r3) {
        if (typeof e4 == "boolean")
          return !e4;
        for (var t3 in e4)
          if (r3[t3])
            return true;
      }, schemaHasRulesExcept: function(e4, r3, t3) {
        if (typeof e4 == "boolean")
          return !e4 && t3 != "not";
        for (var a4 in e4)
          if (a4 != t3 && r3[a4])
            return true;
      }, schemaUnknownRules: function(e4, r3) {
        if (typeof e4 != "boolean") {
          for (var t3 in e4)
            if (!r3[t3])
              return t3;
        }
      }, toQuotedString: u, getPathExpr: function(e4, r3, t3, a4) {
        return p(e4, t3 ? "'/' + " + r3 + (a4 ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : a4 ? "'[' + " + r3 + " + ']'" : "'[\\'' + " + r3 + " + '\\']'");
      }, getPath: function(e4, r3, t3) {
        return p(e4, u(t3 ? "/" + f(r3) : l(r3)));
      }, getData: function(e4, r3, t3) {
        var a4, s3, o3, i3;
        if (e4 === "")
          return "rootData";
        if (e4[0] == "/") {
          if (!h.test(e4))
            throw new Error("Invalid JSON-pointer: " + e4);
          s3 = e4, o3 = "rootData";
        } else {
          if (!(i3 = e4.match(d)))
            throw new Error("Invalid JSON-pointer: " + e4);
          if (a4 = +i3[1], (s3 = i3[2]) == "#") {
            if (r3 <= a4)
              throw new Error("Cannot access property/index " + a4 + " levels up, current level is " + r3);
            return t3[r3 - a4];
          }
          if (r3 < a4)
            throw new Error("Cannot access data " + a4 + " levels up, current level is " + r3);
          if (o3 = "data" + (r3 - a4 || ""), !s3)
            return o3;
        }
        for (var n3 = o3, c3 = s3.split("/"), u2 = 0; u2 < c3.length; u2++) {
          var p2 = c3[u2];
          p2 && (n3 += " && " + (o3 += l(m2(p2))));
        }
        return n3;
      }, unescapeFragment: function(e4) {
        return m2(decodeURIComponent(e4));
      }, unescapeJsonPointer: m2, escapeFragment: function(e4) {
        return encodeURIComponent(f(e4));
      }, escapeJsonPointer: f };
      var s2 = o2(["string", "number", "integer", "boolean", "null"]);
      function o2(e4) {
        for (var r3 = {}, t3 = 0; t3 < e4.length; t3++)
          r3[e4[t3]] = true;
        return r3;
      }
      var i2 = /^[a-z$_][a-z$_0-9]*$/i, n2 = /'|\\/g;
      function l(e4) {
        return typeof e4 == "number" ? "[" + e4 + "]" : i2.test(e4) ? "." + e4 : "['" + c2(e4) + "']";
      }
      function c2(e4) {
        return e4.replace(n2, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
      }
      function u(e4) {
        return "'" + c2(e4) + "'";
      }
      var h = /^\/(?:[^~]|~0|~1)*$/, d = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
      function p(e4, r3) {
        return e4 == '""' ? r3 : (e4 + " + " + r3).replace(/([^\\])' \+ '/g, "$1");
      }
      function f(e4) {
        return e4.replace(/~/g, "~0").replace(/\//g, "~1");
      }
      function m2(e4) {
        return e4.replace(/~1/g, "/").replace(/~0/g, "~");
      }
    }, { "./ucs2length": 9, "fast-deep-equal": 42 }], 11: [function(e3, r2, t2) {
      var a3 = ["multipleOf", "maximum", "exclusiveMaximum", "minimum", "exclusiveMinimum", "maxLength", "minLength", "pattern", "additionalItems", "maxItems", "minItems", "uniqueItems", "maxProperties", "minProperties", "required", "additionalProperties", "enum", "format", "const"];
      r2.exports = function(e4, r3) {
        for (var t3 = 0; t3 < r3.length; t3++) {
          e4 = JSON.parse(JSON.stringify(e4));
          for (var s2 = r3[t3].split("/"), o2 = e4, i2 = 1; i2 < s2.length; i2++)
            o2 = o2[s2[i2]];
          for (i2 = 0; i2 < a3.length; i2++) {
            var n2 = a3[i2], l = o2[n2];
            l && (o2[n2] = { anyOf: [l, { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }] });
          }
        }
        return e4;
      };
    }, {}], 12: [function(e3, r2, t2) {
      var a3 = e3("./refs/json-schema-draft-07.json");
      r2.exports = { $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js", definitions: { simpleTypes: a3.definitions.simpleTypes }, type: "object", dependencies: { schema: ["validate"], $data: ["validate"], statements: ["inline"], valid: { not: { required: ["macro"] } } }, properties: { type: a3.properties.type, schema: { type: "boolean" }, statements: { type: "boolean" }, dependencies: { type: "array", items: { type: "string" } }, metaSchema: { type: "object" }, modifying: { type: "boolean" }, valid: { type: "boolean" }, $data: { type: "boolean" }, async: { type: "boolean" }, errors: { anyOf: [{ type: "boolean" }, { const: "full" }] } } };
    }, { "./refs/json-schema-draft-07.json": 41 }], 13: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3, a3, s2, o2, i2, n2, l, c2 = " ", u = e4.level, h = e4.dataLevel, d = e4.schema[r3], p = e4.schemaPath + e4.util.getProperty(r3), f = e4.errSchemaPath + "/" + r3, m2 = !e4.opts.allErrors, v = "data" + (h || ""), y = e4.opts.$data && d && d.$data, g = y ? (c2 += " var schema" + u + " = " + e4.util.getData(d.$data, h, e4.dataPathArr) + "; ", "schema" + u) : d, P = r3 == "maximum", E = P ? "exclusiveMaximum" : "exclusiveMinimum", w = e4.schema[E], b = e4.opts.$data && w && w.$data, S = P ? "<" : ">", _ = P ? ">" : "<", F = void 0;
        if (!y && typeof d != "number" && d !== void 0)
          throw new Error(r3 + " must be number");
        if (!b && w !== void 0 && typeof w != "number" && typeof w != "boolean")
          throw new Error(E + " must be number or boolean");
        b ? (o2 = "exclIsNumber" + u, i2 = "' + " + (n2 = "op" + u) + " + '", c2 += " var schemaExcl" + u + " = " + (t3 = e4.util.getData(w.$data, h, e4.dataPathArr)) + "; ", F = E, (l = l || []).push(c2 += " var " + (a3 = "exclusive" + u) + "; var " + (s2 = "exclType" + u) + " = typeof " + (t3 = "schemaExcl" + u) + "; if (" + s2 + " != 'boolean' && " + s2 + " != 'undefined' && " + s2 + " != 'number') { "), c2 = "", e4.createErrors !== false ? (c2 += " { keyword: '" + (F || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(f) + " , params: {} ", e4.opts.messages !== false && (c2 += " , message: '" + E + " should be boolean' "), e4.opts.verbose && (c2 += " , schema: validate.schema" + p + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + v + " "), c2 += " } ") : c2 += " {} ", x = c2, c2 = l.pop(), !e4.compositeRule && m2 ? e4.async ? c2 += " throw new ValidationError([" + x + "]); " : c2 += " validate.errors = [" + x + "]; return false; " : c2 += " var err = " + x + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", c2 += " } else if ( ", y && (c2 += " (" + g + " !== undefined && typeof " + g + " != 'number') || "), c2 += " " + s2 + " == 'number' ? ( (" + a3 + " = " + g + " === undefined || " + t3 + " " + S + "= " + g + ") ? " + v + " " + _ + "= " + t3 + " : " + v + " " + _ + " " + g + " ) : ( (" + a3 + " = " + t3 + " === true) ? " + v + " " + _ + "= " + g + " : " + v + " " + _ + " " + g + " ) || " + v + " !== " + v + ") { var op" + u + " = " + a3 + " ? '" + S + "' : '" + S + "='; ", d === void 0 && (F = E, f = e4.errSchemaPath + "/" + E, g = t3, y = b)) : (i2 = S, (o2 = typeof w == "number") && y ? (n2 = "'" + i2 + "'", c2 += " if ( ", y && (c2 += " (" + g + " !== undefined && typeof " + g + " != 'number') || "), c2 += " ( " + g + " === undefined || " + w + " " + S + "= " + g + " ? " + v + " " + _ + "= " + w + " : " + v + " " + _ + " " + g + " ) || " + v + " !== " + v + ") { ") : (o2 && d === void 0 ? (a3 = true, F = E, f = e4.errSchemaPath + "/" + E, g = w, _ += "=") : (o2 && (g = Math[P ? "min" : "max"](w, d)), w === (!o2 || g) ? (a3 = true, F = E, f = e4.errSchemaPath + "/" + E, _ += "=") : (a3 = false, i2 += "=")), n2 = "'" + i2 + "'", c2 += " if ( ", y && (c2 += " (" + g + " !== undefined && typeof " + g + " != 'number') || "), c2 += " " + v + " " + _ + " " + g + " || " + v + " !== " + v + ") { ")), F = F || r3, (l = l || []).push(c2), c2 = "", e4.createErrors !== false ? (c2 += " { keyword: '" + (F || "_limit") + "' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(f) + " , params: { comparison: " + n2 + ", limit: " + g + ", exclusive: " + a3 + " } ", e4.opts.messages !== false && (c2 += " , message: 'should be " + i2 + " ", c2 += y ? "' + " + g : g + "'"), e4.opts.verbose && (c2 += " , schema:  ", c2 += y ? "validate.schema" + p : "" + d, c2 += "         , parentSchema: validate.schema" + e4.schemaPath + " , data: " + v + " "), c2 += " } ") : c2 += " {} ";
        var x = c2;
        return c2 = l.pop(), !e4.compositeRule && m2 ? e4.async ? c2 += " throw new ValidationError([" + x + "]); " : c2 += " validate.errors = [" + x + "]; return false; " : c2 += " var err = " + x + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", c2 += " } ", m2 && (c2 += " else { "), c2;
      };
    }, {}], 14: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3 = " ", a3 = e4.level, s2 = e4.dataLevel, o2 = e4.schema[r3], i2 = e4.schemaPath + e4.util.getProperty(r3), n2 = e4.errSchemaPath + "/" + r3, l = !e4.opts.allErrors, c2 = "data" + (s2 || ""), u = e4.opts.$data && o2 && o2.$data, h = u ? (t3 += " var schema" + a3 + " = " + e4.util.getData(o2.$data, s2, e4.dataPathArr) + "; ", "schema" + a3) : o2;
        if (!u && typeof o2 != "number")
          throw new Error(r3 + " must be number");
        t3 += "if ( ", u && (t3 += " (" + h + " !== undefined && typeof " + h + " != 'number') || "), t3 += " " + c2 + ".length " + (r3 == "maxItems" ? ">" : "<") + " " + h + ") { ";
        var d = r3, p = p || [];
        p.push(t3), t3 = "", e4.createErrors !== false ? (t3 += " { keyword: '" + (d || "_limitItems") + "' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: { limit: " + h + " } ", e4.opts.messages !== false && (t3 += " , message: 'should NOT have ", t3 += r3 == "maxItems" ? "more" : "fewer", t3 += " than ", t3 += u ? "' + " + h + " + '" : "" + o2, t3 += " items' "), e4.opts.verbose && (t3 += " , schema:  ", t3 += u ? "validate.schema" + i2 : "" + o2, t3 += "         , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ";
        var f = t3;
        return t3 = p.pop(), !e4.compositeRule && l ? e4.async ? t3 += " throw new ValidationError([" + f + "]); " : t3 += " validate.errors = [" + f + "]; return false; " : t3 += " var err = " + f + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t3 += "} ", l && (t3 += " else { "), t3;
      };
    }, {}], 15: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3 = " ", a3 = e4.level, s2 = e4.dataLevel, o2 = e4.schema[r3], i2 = e4.schemaPath + e4.util.getProperty(r3), n2 = e4.errSchemaPath + "/" + r3, l = !e4.opts.allErrors, c2 = "data" + (s2 || ""), u = e4.opts.$data && o2 && o2.$data, h = u ? (t3 += " var schema" + a3 + " = " + e4.util.getData(o2.$data, s2, e4.dataPathArr) + "; ", "schema" + a3) : o2;
        if (!u && typeof o2 != "number")
          throw new Error(r3 + " must be number");
        var d = r3 == "maxLength" ? ">" : "<";
        t3 += "if ( ", u && (t3 += " (" + h + " !== undefined && typeof " + h + " != 'number') || "), e4.opts.unicode === false ? t3 += " " + c2 + ".length " : t3 += " ucs2length(" + c2 + ") ", t3 += " " + d + " " + h + ") { ";
        var p = r3, f = f || [];
        f.push(t3), t3 = "", e4.createErrors !== false ? (t3 += " { keyword: '" + (p || "_limitLength") + "' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: { limit: " + h + " } ", e4.opts.messages !== false && (t3 += " , message: 'should NOT be ", t3 += r3 == "maxLength" ? "longer" : "shorter", t3 += " than ", t3 += u ? "' + " + h + " + '" : "" + o2, t3 += " characters' "), e4.opts.verbose && (t3 += " , schema:  ", t3 += u ? "validate.schema" + i2 : "" + o2, t3 += "         , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ";
        var m2 = t3;
        return t3 = f.pop(), !e4.compositeRule && l ? e4.async ? t3 += " throw new ValidationError([" + m2 + "]); " : t3 += " validate.errors = [" + m2 + "]; return false; " : t3 += " var err = " + m2 + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t3 += "} ", l && (t3 += " else { "), t3;
      };
    }, {}], 16: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3 = " ", a3 = e4.level, s2 = e4.dataLevel, o2 = e4.schema[r3], i2 = e4.schemaPath + e4.util.getProperty(r3), n2 = e4.errSchemaPath + "/" + r3, l = !e4.opts.allErrors, c2 = "data" + (s2 || ""), u = e4.opts.$data && o2 && o2.$data, h = u ? (t3 += " var schema" + a3 + " = " + e4.util.getData(o2.$data, s2, e4.dataPathArr) + "; ", "schema" + a3) : o2;
        if (!u && typeof o2 != "number")
          throw new Error(r3 + " must be number");
        t3 += "if ( ", u && (t3 += " (" + h + " !== undefined && typeof " + h + " != 'number') || "), t3 += " Object.keys(" + c2 + ").length " + (r3 == "maxProperties" ? ">" : "<") + " " + h + ") { ";
        var d = r3, p = p || [];
        p.push(t3), t3 = "", e4.createErrors !== false ? (t3 += " { keyword: '" + (d || "_limitProperties") + "' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: { limit: " + h + " } ", e4.opts.messages !== false && (t3 += " , message: 'should NOT have ", t3 += r3 == "maxProperties" ? "more" : "fewer", t3 += " than ", t3 += u ? "' + " + h + " + '" : "" + o2, t3 += " properties' "), e4.opts.verbose && (t3 += " , schema:  ", t3 += u ? "validate.schema" + i2 : "" + o2, t3 += "         , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ";
        var f = t3;
        return t3 = p.pop(), !e4.compositeRule && l ? e4.async ? t3 += " throw new ValidationError([" + f + "]); " : t3 += " validate.errors = [" + f + "]; return false; " : t3 += " var err = " + f + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t3 += "} ", l && (t3 += " else { "), t3;
      };
    }, {}], 17: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3 = " ", a3 = e4.schema[r3], s2 = e4.schemaPath + e4.util.getProperty(r3), o2 = e4.errSchemaPath + "/" + r3, i2 = !e4.opts.allErrors, n2 = e4.util.copy(e4), l = "";
        n2.level++;
        var c2 = "valid" + n2.level, u = n2.baseId, h = true, d = a3;
        if (d)
          for (var p, f = -1, m2 = d.length - 1; f < m2; )
            p = d[f += 1], (e4.opts.strictKeywords ? typeof p == "object" && 0 < Object.keys(p).length : e4.util.schemaHasRules(p, e4.RULES.all)) && (h = false, n2.schema = p, n2.schemaPath = s2 + "[" + f + "]", n2.errSchemaPath = o2 + "/" + f, t3 += "  " + e4.validate(n2) + " ", n2.baseId = u, i2 && (t3 += " if (" + c2 + ") { ", l += "}"));
        return i2 && (t3 += h ? " if (true) { " : " " + l.slice(0, -1) + " "), t3;
      };
    }, {}], 18: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3 = " ", a3 = e4.level, s2 = e4.dataLevel, o2 = e4.schema[r3], i2 = e4.schemaPath + e4.util.getProperty(r3), n2 = e4.errSchemaPath + "/" + r3, l = !e4.opts.allErrors, c2 = "data" + (s2 || ""), u = "valid" + a3, h = "errs__" + a3, d = e4.util.copy(e4), p = "";
        d.level++;
        var f = "valid" + d.level;
        if (o2.every(function(r4) {
          return e4.opts.strictKeywords ? typeof r4 == "object" && 0 < Object.keys(r4).length : e4.util.schemaHasRules(r4, e4.RULES.all);
        })) {
          var m2 = d.baseId;
          t3 += " var " + h + " = errors; var " + u + " = false;  ";
          var v = e4.compositeRule;
          e4.compositeRule = d.compositeRule = true;
          var y = o2;
          if (y)
            for (var g, P = -1, E = y.length - 1; P < E; )
              g = y[P += 1], d.schema = g, d.schemaPath = i2 + "[" + P + "]", d.errSchemaPath = n2 + "/" + P, t3 += "  " + e4.validate(d) + " ", d.baseId = m2, t3 += " " + u + " = " + u + " || " + f + "; if (!" + u + ") { ", p += "}";
          e4.compositeRule = d.compositeRule = v, t3 += " " + p + " if (!" + u + ") {   var err =   ", e4.createErrors !== false ? (t3 += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: {} ", e4.opts.messages !== false && (t3 += " , message: 'should match some schema in anyOf' "), e4.opts.verbose && (t3 += " , schema: validate.schema" + i2 + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ", t3 += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e4.compositeRule && l && (e4.async ? t3 += " throw new ValidationError(vErrors); " : t3 += " validate.errors = vErrors; return false; "), t3 += " } else {  errors = " + h + "; if (vErrors !== null) { if (" + h + ") vErrors.length = " + h + "; else vErrors = null; } ", e4.opts.allErrors && (t3 += " } ");
        } else
          l && (t3 += " if (true) { ");
        return t3;
      };
    }, {}], 19: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3 = " ", a3 = e4.schema[r3], s2 = e4.errSchemaPath + "/" + r3, o2 = (e4.opts.allErrors, e4.util.toQuotedString(a3));
        return e4.opts.$comment === true ? t3 += " console.log(" + o2 + ");" : typeof e4.opts.$comment == "function" && (t3 += " self._opts.$comment(" + o2 + ", " + e4.util.toQuotedString(s2) + ", validate.root.schema);"), t3;
      };
    }, {}], 20: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3 = " ", a3 = e4.level, s2 = e4.dataLevel, o2 = e4.schema[r3], i2 = e4.schemaPath + e4.util.getProperty(r3), n2 = e4.errSchemaPath + "/" + r3, l = !e4.opts.allErrors, c2 = "data" + (s2 || ""), u = "valid" + a3, h = e4.opts.$data && o2 && o2.$data;
        h && (t3 += " var schema" + a3 + " = " + e4.util.getData(o2.$data, s2, e4.dataPathArr) + "; "), h || (t3 += " var schema" + a3 + " = validate.schema" + i2 + ";"), t3 += "var " + u + " = equal(" + c2 + ", schema" + a3 + "); if (!" + u + ") {   ";
        var d = d || [];
        d.push(t3), t3 = "", e4.createErrors !== false ? (t3 += " { keyword: 'const' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: { allowedValue: schema" + a3 + " } ", e4.opts.messages !== false && (t3 += " , message: 'should be equal to constant' "), e4.opts.verbose && (t3 += " , schema: validate.schema" + i2 + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ";
        var p = t3;
        return t3 = d.pop(), !e4.compositeRule && l ? e4.async ? t3 += " throw new ValidationError([" + p + "]); " : t3 += " validate.errors = [" + p + "]; return false; " : t3 += " var err = " + p + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t3 += " }", l && (t3 += " else { "), t3;
      };
    }, {}], 21: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3 = " ", a3 = e4.level, s2 = e4.dataLevel, o2 = e4.schema[r3], i2 = e4.schemaPath + e4.util.getProperty(r3), n2 = e4.errSchemaPath + "/" + r3, l = !e4.opts.allErrors, c2 = "data" + (s2 || ""), u = "valid" + a3, h = "errs__" + a3, d = e4.util.copy(e4);
        d.level++;
        var p, f, m2, v = "valid" + d.level, y = "i" + a3, g = d.dataLevel = e4.dataLevel + 1, P = "data" + g, E = e4.baseId, w = e4.opts.strictKeywords ? typeof o2 == "object" && 0 < Object.keys(o2).length : e4.util.schemaHasRules(o2, e4.RULES.all);
        t3 += "var " + h + " = errors;var " + u + ";", w ? (p = e4.compositeRule, e4.compositeRule = d.compositeRule = true, d.schema = o2, d.schemaPath = i2, d.errSchemaPath = n2, t3 += " var " + v + " = false; for (var " + y + " = 0; " + y + " < " + c2 + ".length; " + y + "++) { ", d.errorPath = e4.util.getPathExpr(e4.errorPath, y, e4.opts.jsonPointers, true), f = c2 + "[" + y + "]", d.dataPathArr[g] = y, m2 = e4.validate(d), d.baseId = E, e4.util.varOccurences(m2, P) < 2 ? t3 += " " + e4.util.varReplace(m2, P, f) + " " : t3 += " var " + P + " = " + f + "; " + m2 + " ", t3 += " if (" + v + ") break; }  ", e4.compositeRule = d.compositeRule = p, t3 += "  if (!" + v + ") {") : t3 += " if (" + c2 + ".length == 0) {";
        var b = b || [];
        b.push(t3), t3 = "", e4.createErrors !== false ? (t3 += " { keyword: 'contains' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: {} ", e4.opts.messages !== false && (t3 += " , message: 'should contain a valid item' "), e4.opts.verbose && (t3 += " , schema: validate.schema" + i2 + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ";
        var S = t3;
        return t3 = b.pop(), !e4.compositeRule && l ? e4.async ? t3 += " throw new ValidationError([" + S + "]); " : t3 += " validate.errors = [" + S + "]; return false; " : t3 += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t3 += " } else { ", w && (t3 += "  errors = " + h + "; if (vErrors !== null) { if (" + h + ") vErrors.length = " + h + "; else vErrors = null; } "), e4.opts.allErrors && (t3 += " } "), t3;
      };
    }, {}], 22: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3, a3, s2, o2, i2, n2, l = " ", c2 = e4.level, u = e4.dataLevel, h = e4.schema[r3], d = e4.schemaPath + e4.util.getProperty(r3), p = e4.errSchemaPath + "/" + r3, f = !e4.opts.allErrors, m2 = "data" + (u || ""), v = "valid" + c2, y = "errs__" + c2, g = e4.opts.$data && h && h.$data, P = g ? (l += " var schema" + c2 + " = " + e4.util.getData(h.$data, u, e4.dataPathArr) + "; ", "schema" + c2) : h, E = this, w = "definition" + c2, b = E.definition, S = "";
        if (g && b.$data) {
          n2 = "keywordValidate" + c2;
          var _ = b.validateSchema;
          l += " var " + w + " = RULES.custom['" + r3 + "'].definition; var " + n2 + " = " + w + ".validate;";
        } else {
          if (!(i2 = e4.useCustomRule(E, h, e4.schema, e4)))
            return;
          P = "validate.schema" + d, n2 = i2.code, a3 = b.compile, s2 = b.inline, o2 = b.macro;
        }
        var F, x, R, $, j, D, O, I, A, k, C = n2 + ".errors", L = "i" + c2, N = "ruleErr" + c2, z = b.async;
        if (z && !e4.async)
          throw new Error("async keyword in sync schema");
        return s2 || o2 || (l += C + " = null;"), l += "var " + y + " = errors;var " + v + ";", g && b.$data && (S += "}", l += " if (" + P + " === undefined) { " + v + " = true; } else { ", _ && (S += "}", l += " " + v + " = " + w + ".validateSchema(" + P + "); if (" + v + ") { ")), s2 ? b.statements ? l += " " + i2.validate + " " : l += " " + v + " = " + i2.validate + "; " : o2 ? (S = "", (F = e4.util.copy(e4)).level++, x = "valid" + F.level, F.schema = i2.validate, F.schemaPath = "", R = e4.compositeRule, e4.compositeRule = F.compositeRule = true, $ = e4.validate(F).replace(/validate\.schema/g, n2), e4.compositeRule = F.compositeRule = R, l += " " + $) : ((I = I || []).push(l), l = "", l += "  " + n2 + ".call( ", e4.opts.passContext ? l += "this" : l += "self", a3 || b.schema === false ? l += " , " + m2 + " " : l += " , " + P + " , " + m2 + " , validate.schema" + e4.schemaPath + " ", l += " , (dataPath || '')", e4.errorPath != '""' && (l += " + " + e4.errorPath), O = l += " , " + (j = u ? "data" + (u - 1 || "") : "parentData") + " , " + (D = u ? e4.dataPathArr[u] : "parentDataProperty") + " , rootData )  ", l = I.pop(), b.errors === false ? (l += " " + v + " = ", z && (l += "await "), l += O + "; ") : l += z ? " var " + (C = "customErrors" + c2) + " = null; try { " + v + " = await " + O + "; } catch (e) { " + v + " = false; if (e instanceof ValidationError) " + C + " = e.errors; else throw e; } " : " " + C + " = null; " + v + " = " + O + "; "), b.modifying && (l += " if (" + j + ") " + m2 + " = " + j + "[" + D + "];"), l += "" + S, b.valid ? f && (l += " if (true) { ") : (l += " if ( ", b.valid === void 0 ? (l += " !", l += o2 ? "" + x : v) : l += " " + !b.valid + " ", l += ") { ", t3 = E.keyword, (I = I || []).push(l), (I = I || []).push(l = ""), l = "", e4.createErrors !== false ? (l += " { keyword: '" + (t3 || "custom") + "' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(p) + " , params: { keyword: '" + E.keyword + "' } ", e4.opts.messages !== false && (l += ` , message: 'should pass "` + E.keyword + `" keyword validation' `), e4.opts.verbose && (l += " , schema: validate.schema" + d + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + m2 + " "), l += " } ") : l += " {} ", A = l, l = I.pop(), !e4.compositeRule && f ? e4.async ? l += " throw new ValidationError([" + A + "]); " : l += " validate.errors = [" + A + "]; return false; " : l += " var err = " + A + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", k = l, l = I.pop(), s2 ? b.errors ? b.errors != "full" && (l += "  for (var " + L + "=" + y + "; " + L + "<errors; " + L + "++) { var " + N + " = vErrors[" + L + "]; if (" + N + ".dataPath === undefined) " + N + ".dataPath = (dataPath || '') + " + e4.errorPath + "; if (" + N + ".schemaPath === undefined) { " + N + '.schemaPath = "' + p + '"; } ', e4.opts.verbose && (l += " " + N + ".schema = " + P + "; " + N + ".data = " + m2 + "; "), l += " } ") : b.errors === false ? l += " " + k + " " : (l += " if (" + y + " == errors) { " + k + " } else {  for (var " + L + "=" + y + "; " + L + "<errors; " + L + "++) { var " + N + " = vErrors[" + L + "]; if (" + N + ".dataPath === undefined) " + N + ".dataPath = (dataPath || '') + " + e4.errorPath + "; if (" + N + ".schemaPath === undefined) { " + N + '.schemaPath = "' + p + '"; } ', e4.opts.verbose && (l += " " + N + ".schema = " + P + "; " + N + ".data = " + m2 + "; "), l += " } } ") : o2 ? (l += "   var err =   ", e4.createErrors !== false ? (l += " { keyword: '" + (t3 || "custom") + "' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(p) + " , params: { keyword: '" + E.keyword + "' } ", e4.opts.messages !== false && (l += ` , message: 'should pass "` + E.keyword + `" keyword validation' `), e4.opts.verbose && (l += " , schema: validate.schema" + d + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + m2 + " "), l += " } ") : l += " {} ", l += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e4.compositeRule && f && (e4.async ? l += " throw new ValidationError(vErrors); " : l += " validate.errors = vErrors; return false; ")) : b.errors === false ? l += " " + k + " " : (l += " if (Array.isArray(" + C + ")) { if (vErrors === null) vErrors = " + C + "; else vErrors = vErrors.concat(" + C + "); errors = vErrors.length;  for (var " + L + "=" + y + "; " + L + "<errors; " + L + "++) { var " + N + " = vErrors[" + L + "]; if (" + N + ".dataPath === undefined) " + N + ".dataPath = (dataPath || '') + " + e4.errorPath + ";  " + N + '.schemaPath = "' + p + '";  ', e4.opts.verbose && (l += " " + N + ".schema = " + P + "; " + N + ".data = " + m2 + "; "), l += " } } else { " + k + " } "), l += " } ", f && (l += " else { ")), l;
      };
    }, {}], 23: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3 = " ", a3 = e4.level, s2 = e4.dataLevel, o2 = e4.schema[r3], i2 = e4.schemaPath + e4.util.getProperty(r3), n2 = e4.errSchemaPath + "/" + r3, l = !e4.opts.allErrors, c2 = "data" + (s2 || ""), u = "errs__" + a3, h = e4.util.copy(e4), d = "";
        h.level++;
        var p, f = "valid" + h.level, m2 = {}, v = {}, y = e4.opts.ownProperties;
        for (P in o2)
          P != "__proto__" && (k = o2[P], (p = Array.isArray(k) ? v : m2)[P] = k);
        t3 += "var " + u + " = errors;";
        var g = e4.errorPath;
        for (var P in t3 += "var missing" + a3 + ";", v)
          if ((p = v[P]).length) {
            if (t3 += " if ( " + c2 + e4.util.getProperty(P) + " !== undefined ", y && (t3 += " && Object.prototype.hasOwnProperty.call(" + c2 + ", '" + e4.util.escapeQuotes(P) + "') "), l) {
              t3 += " && ( ";
              var E = p;
              if (E)
                for (var w = -1, b = E.length - 1; w < b; )
                  $ = E[w += 1], w && (t3 += " || "), t3 += " ( ( " + (I = c2 + (O = e4.util.getProperty($))) + " === undefined ", y && (t3 += " || ! Object.prototype.hasOwnProperty.call(" + c2 + ", '" + e4.util.escapeQuotes($) + "') "), t3 += ") && (missing" + a3 + " = " + e4.util.toQuotedString(e4.opts.jsonPointers ? $ : O) + ") ) ";
              t3 += ")) {  ";
              var S = "missing" + a3, _ = "' + " + S + " + '";
              e4.opts._errorDataPathProperty && (e4.errorPath = e4.opts.jsonPointers ? e4.util.getPathExpr(g, S, true) : g + " + " + S);
              var F = F || [];
              F.push(t3), t3 = "", e4.createErrors !== false ? (t3 += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: { property: '" + e4.util.escapeQuotes(P) + "', missingProperty: '" + _ + "', depsCount: " + p.length + ", deps: '" + e4.util.escapeQuotes(p.length == 1 ? p[0] : p.join(", ")) + "' } ", e4.opts.messages !== false && (t3 += " , message: 'should have ", p.length == 1 ? t3 += "property " + e4.util.escapeQuotes(p[0]) : t3 += "properties " + e4.util.escapeQuotes(p.join(", ")), t3 += " when property " + e4.util.escapeQuotes(P) + " is present' "), e4.opts.verbose && (t3 += " , schema: validate.schema" + i2 + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ";
              var x = t3;
              t3 = F.pop(), !e4.compositeRule && l ? e4.async ? t3 += " throw new ValidationError([" + x + "]); " : t3 += " validate.errors = [" + x + "]; return false; " : t3 += " var err = " + x + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            } else {
              t3 += " ) { ";
              var R = p;
              if (R)
                for (var $, j = -1, D = R.length - 1; j < D; ) {
                  $ = R[j += 1];
                  var O = e4.util.getProperty($), I = (_ = e4.util.escapeQuotes($), c2 + O);
                  e4.opts._errorDataPathProperty && (e4.errorPath = e4.util.getPath(g, $, e4.opts.jsonPointers)), t3 += " if ( " + I + " === undefined ", y && (t3 += " || ! Object.prototype.hasOwnProperty.call(" + c2 + ", '" + e4.util.escapeQuotes($) + "') "), t3 += ") {  var err =   ", e4.createErrors !== false ? (t3 += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: { property: '" + e4.util.escapeQuotes(P) + "', missingProperty: '" + _ + "', depsCount: " + p.length + ", deps: '" + e4.util.escapeQuotes(p.length == 1 ? p[0] : p.join(", ")) + "' } ", e4.opts.messages !== false && (t3 += " , message: 'should have ", p.length == 1 ? t3 += "property " + e4.util.escapeQuotes(p[0]) : t3 += "properties " + e4.util.escapeQuotes(p.join(", ")), t3 += " when property " + e4.util.escapeQuotes(P) + " is present' "), e4.opts.verbose && (t3 += " , schema: validate.schema" + i2 + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ", t3 += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
                }
            }
            t3 += " }   ", l && (d += "}", t3 += " else { ");
          }
        e4.errorPath = g;
        var A = h.baseId;
        for (var P in m2) {
          var k = m2[P];
          (e4.opts.strictKeywords ? typeof k == "object" && 0 < Object.keys(k).length : e4.util.schemaHasRules(k, e4.RULES.all)) && (t3 += " " + f + " = true; if ( " + c2 + e4.util.getProperty(P) + " !== undefined ", y && (t3 += " && Object.prototype.hasOwnProperty.call(" + c2 + ", '" + e4.util.escapeQuotes(P) + "') "), t3 += ") { ", h.schema = k, h.schemaPath = i2 + e4.util.getProperty(P), h.errSchemaPath = n2 + "/" + e4.util.escapeFragment(P), t3 += "  " + e4.validate(h) + " ", h.baseId = A, t3 += " }  ", l && (t3 += " if (" + f + ") { ", d += "}"));
        }
        return l && (t3 += "   " + d + " if (" + u + " == errors) {"), t3;
      };
    }, {}], 24: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3 = " ", a3 = e4.level, s2 = e4.dataLevel, o2 = e4.schema[r3], i2 = e4.schemaPath + e4.util.getProperty(r3), n2 = e4.errSchemaPath + "/" + r3, l = !e4.opts.allErrors, c2 = "data" + (s2 || ""), u = "valid" + a3, h = e4.opts.$data && o2 && o2.$data, d = (h && (t3 += " var schema" + a3 + " = " + e4.util.getData(o2.$data, s2, e4.dataPathArr) + "; "), "i" + a3), p = "schema" + a3;
        h || (t3 += " var " + p + " = validate.schema" + i2 + ";"), t3 += "var " + u + ";", h && (t3 += " if (schema" + a3 + " === undefined) " + u + " = true; else if (!Array.isArray(schema" + a3 + ")) " + u + " = false; else {"), t3 += u + " = false;for (var " + d + "=0; " + d + "<" + p + ".length; " + d + "++) if (equal(" + c2 + ", " + p + "[" + d + "])) { " + u + " = true; break; }", h && (t3 += "  }  "), t3 += " if (!" + u + ") {   ";
        var f = f || [];
        f.push(t3), t3 = "", e4.createErrors !== false ? (t3 += " { keyword: 'enum' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: { allowedValues: schema" + a3 + " } ", e4.opts.messages !== false && (t3 += " , message: 'should be equal to one of the allowed values' "), e4.opts.verbose && (t3 += " , schema: validate.schema" + i2 + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ";
        var m2 = t3;
        return t3 = f.pop(), !e4.compositeRule && l ? e4.async ? t3 += " throw new ValidationError([" + m2 + "]); " : t3 += " validate.errors = [" + m2 + "]; return false; " : t3 += " var err = " + m2 + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t3 += " }", l && (t3 += " else { "), t3;
      };
    }, {}], 25: [function(e3, r2, t2) {
      r2.exports = function(e4, r3, t3) {
        var a3 = " ", s2 = e4.level, o2 = e4.dataLevel, i2 = e4.schema[r3], n2 = e4.schemaPath + e4.util.getProperty(r3), l = e4.errSchemaPath + "/" + r3, c2 = !e4.opts.allErrors, u = "data" + (o2 || "");
        if (e4.opts.format === false)
          return c2 && (a3 += " if (true) { "), a3;
        var h, d = e4.opts.$data && i2 && i2.$data, p = d ? (a3 += " var schema" + s2 + " = " + e4.util.getData(i2.$data, o2, e4.dataPathArr) + "; ", "schema" + s2) : i2, f = e4.opts.unknownFormats, m2 = Array.isArray(f);
        if (d)
          a3 += " var " + (h = "format" + s2) + " = formats[" + p + "]; var " + (v = "isObject" + s2) + " = typeof " + h + " == 'object' && !(" + h + " instanceof RegExp) && " + h + ".validate; var " + (g = "formatType" + s2) + " = " + v + " && " + h + ".type || 'string'; if (" + v + ") { ", e4.async && (a3 += " var async" + s2 + " = " + h + ".async; "), a3 += " " + h + " = " + h + ".validate; } if (  ", d && (a3 += " (" + p + " !== undefined && typeof " + p + " != 'string') || "), a3 += " (", f != "ignore" && (a3 += " (" + p + " && !" + h + " ", m2 && (a3 += " && self._opts.unknownFormats.indexOf(" + p + ") == -1 "), a3 += ") || "), a3 += " (" + h + " && " + g + " == '" + t3 + "' && !(typeof " + h + " == 'function' ? ", e4.async ? a3 += " (async" + s2 + " ? await " + h + "(" + u + ") : " + h + "(" + u + ")) " : a3 += " " + h + "(" + u + ") ", a3 += " : " + h + ".test(" + u + "))))) {";
        else {
          if (!(h = e4.formats[i2])) {
            if (f == "ignore")
              return e4.logger.warn('unknown format "' + i2 + '" ignored in schema at path "' + e4.errSchemaPath + '"'), c2 && (a3 += " if (true) { "), a3;
            if (m2 && 0 <= f.indexOf(i2))
              return c2 && (a3 += " if (true) { "), a3;
            throw new Error('unknown format "' + i2 + '" is used in schema at path "' + e4.errSchemaPath + '"');
          }
          var v, y, g = (v = typeof h == "object" && !(h instanceof RegExp) && h.validate) && h.type || "string";
          if (v && (y = h.async === true, h = h.validate), g != t3)
            return c2 && (a3 += " if (true) { "), a3;
          if (y) {
            if (!e4.async)
              throw new Error("async format in sync schema");
            a3 += " if (!(await " + (P = "formats" + e4.util.getProperty(i2) + ".validate") + "(" + u + "))) { ";
          } else {
            a3 += " if (! ";
            var P = "formats" + e4.util.getProperty(i2);
            v && (P += ".validate"), a3 += typeof h == "function" ? " " + P + "(" + u + ") " : " " + P + ".test(" + u + ") ", a3 += ") { ";
          }
        }
        var E = E || [];
        E.push(a3), a3 = "", e4.createErrors !== false ? (a3 += " { keyword: 'format' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(l) + " , params: { format:  ", a3 += d ? "" + p : "" + e4.util.toQuotedString(i2), a3 += "  } ", e4.opts.messages !== false && (a3 += ` , message: 'should match format "`, a3 += d ? "' + " + p + " + '" : "" + e4.util.escapeQuotes(i2), a3 += `"' `), e4.opts.verbose && (a3 += " , schema:  ", a3 += d ? "validate.schema" + n2 : "" + e4.util.toQuotedString(i2), a3 += "         , parentSchema: validate.schema" + e4.schemaPath + " , data: " + u + " "), a3 += " } ") : a3 += " {} ";
        var w = a3;
        return a3 = E.pop(), !e4.compositeRule && c2 ? e4.async ? a3 += " throw new ValidationError([" + w + "]); " : a3 += " validate.errors = [" + w + "]; return false; " : a3 += " var err = " + w + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", a3 += " } ", c2 && (a3 += " else { "), a3;
      };
    }, {}], 26: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3 = " ", a3 = e4.level, s2 = e4.dataLevel, o2 = e4.schema[r3], i2 = e4.schemaPath + e4.util.getProperty(r3), n2 = e4.errSchemaPath + "/" + r3, l = !e4.opts.allErrors, c2 = "data" + (s2 || ""), u = "valid" + a3, h = "errs__" + a3, d = e4.util.copy(e4);
        d.level++;
        var p, f, m2 = "valid" + d.level, v = e4.schema.then, y = e4.schema.else, g = v !== void 0 && (e4.opts.strictKeywords ? typeof v == "object" && 0 < Object.keys(v).length : e4.util.schemaHasRules(v, e4.RULES.all)), P = y !== void 0 && (e4.opts.strictKeywords ? typeof y == "object" && 0 < Object.keys(y).length : e4.util.schemaHasRules(y, e4.RULES.all)), E = d.baseId;
        return g || P ? (d.createErrors = false, d.schema = o2, d.schemaPath = i2, d.errSchemaPath = n2, t3 += " var " + h + " = errors; var " + u + " = true;  ", f = e4.compositeRule, e4.compositeRule = d.compositeRule = true, t3 += "  " + e4.validate(d) + " ", d.baseId = E, d.createErrors = true, t3 += "  errors = " + h + "; if (vErrors !== null) { if (" + h + ") vErrors.length = " + h + "; else vErrors = null; }  ", e4.compositeRule = d.compositeRule = f, g ? (t3 += " if (" + m2 + ") {  ", d.schema = e4.schema.then, d.schemaPath = e4.schemaPath + ".then", d.errSchemaPath = e4.errSchemaPath + "/then", t3 += "  " + e4.validate(d) + " ", d.baseId = E, t3 += " " + u + " = " + m2 + "; ", g && P ? t3 += " var " + (p = "ifClause" + a3) + " = 'then'; " : p = "'then'", t3 += " } ", P && (t3 += " else { ")) : t3 += " if (!" + m2 + ") { ", P && (d.schema = e4.schema.else, d.schemaPath = e4.schemaPath + ".else", d.errSchemaPath = e4.errSchemaPath + "/else", t3 += "  " + e4.validate(d) + " ", d.baseId = E, t3 += " " + u + " = " + m2 + "; ", g && P ? t3 += " var " + (p = "ifClause" + a3) + " = 'else'; " : p = "'else'", t3 += " } "), t3 += " if (!" + u + ") {   var err =   ", e4.createErrors !== false ? (t3 += " { keyword: 'if' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: { failingKeyword: " + p + " } ", e4.opts.messages !== false && (t3 += ` , message: 'should match "' + ` + p + ` + '" schema' `), e4.opts.verbose && (t3 += " , schema: validate.schema" + i2 + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ", t3 += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e4.compositeRule && l && (e4.async ? t3 += " throw new ValidationError(vErrors); " : t3 += " validate.errors = vErrors; return false; "), t3 += " }   ", l && (t3 += " else { ")) : l && (t3 += " if (true) { "), t3;
      };
    }, {}], 27: [function(e3, r2, t2) {
      r2.exports = { $ref: e3("./ref"), allOf: e3("./allOf"), anyOf: e3("./anyOf"), $comment: e3("./comment"), const: e3("./const"), contains: e3("./contains"), dependencies: e3("./dependencies"), enum: e3("./enum"), format: e3("./format"), if: e3("./if"), items: e3("./items"), maximum: e3("./_limit"), minimum: e3("./_limit"), maxItems: e3("./_limitItems"), minItems: e3("./_limitItems"), maxLength: e3("./_limitLength"), minLength: e3("./_limitLength"), maxProperties: e3("./_limitProperties"), minProperties: e3("./_limitProperties"), multipleOf: e3("./multipleOf"), not: e3("./not"), oneOf: e3("./oneOf"), pattern: e3("./pattern"), properties: e3("./properties"), propertyNames: e3("./propertyNames"), required: e3("./required"), uniqueItems: e3("./uniqueItems"), validate: e3("./validate") };
    }, { "./_limit": 13, "./_limitItems": 14, "./_limitLength": 15, "./_limitProperties": 16, "./allOf": 17, "./anyOf": 18, "./comment": 19, "./const": 20, "./contains": 21, "./dependencies": 23, "./enum": 24, "./format": 25, "./if": 26, "./items": 28, "./multipleOf": 29, "./not": 30, "./oneOf": 31, "./pattern": 32, "./properties": 33, "./propertyNames": 34, "./ref": 35, "./required": 36, "./uniqueItems": 37, "./validate": 38 }], 28: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3 = " ", a3 = e4.level, s2 = e4.dataLevel, o2 = e4.schema[r3], i2 = e4.schemaPath + e4.util.getProperty(r3), n2 = e4.errSchemaPath + "/" + r3, l = !e4.opts.allErrors, c2 = "data" + (s2 || ""), u = "valid" + a3, h = "errs__" + a3, d = e4.util.copy(e4), p = "";
        d.level++;
        var f = "valid" + d.level, m2 = "i" + a3, v = d.dataLevel = e4.dataLevel + 1, y = "data" + v, g = e4.baseId;
        if (t3 += "var " + h + " = errors;var " + u + ";", Array.isArray(o2)) {
          var P, E, w, b = e4.schema.additionalItems;
          b === false && (t3 += " " + u + " = " + c2 + ".length <= " + o2.length + "; ", P = n2, n2 = e4.errSchemaPath + "/additionalItems", (E = E || []).push(t3 += "  if (!" + u + ") {   "), t3 = "", e4.createErrors !== false ? (t3 += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: { limit: " + o2.length + " } ", e4.opts.messages !== false && (t3 += " , message: 'should NOT have more than " + o2.length + " items' "), e4.opts.verbose && (t3 += " , schema: false , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ", w = t3, t3 = E.pop(), !e4.compositeRule && l ? e4.async ? t3 += " throw new ValidationError([" + w + "]); " : t3 += " validate.errors = [" + w + "]; return false; " : t3 += " var err = " + w + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t3 += " } ", n2 = P, l && (p += "}", t3 += " else { "));
          var S = o2;
          if (S)
            for (var _ = -1, F = S.length - 1; _ < F; ) {
              var x, R, $ = S[_ += 1];
              (e4.opts.strictKeywords ? typeof $ == "object" && 0 < Object.keys($).length : e4.util.schemaHasRules($, e4.RULES.all)) && (t3 += " " + f + " = true; if (" + c2 + ".length > " + _ + ") { ", x = c2 + "[" + _ + "]", d.schema = $, d.schemaPath = i2 + "[" + _ + "]", d.errSchemaPath = n2 + "/" + _, d.errorPath = e4.util.getPathExpr(e4.errorPath, _, e4.opts.jsonPointers, true), d.dataPathArr[v] = _, R = e4.validate(d), d.baseId = g, e4.util.varOccurences(R, y) < 2 ? t3 += " " + e4.util.varReplace(R, y, x) + " " : t3 += " var " + y + " = " + x + "; " + R + " ", t3 += " }  ", l && (t3 += " if (" + f + ") { ", p += "}"));
            }
          typeof b == "object" && (e4.opts.strictKeywords ? typeof b == "object" && 0 < Object.keys(b).length : e4.util.schemaHasRules(b, e4.RULES.all)) && (d.schema = b, d.schemaPath = e4.schemaPath + ".additionalItems", d.errSchemaPath = e4.errSchemaPath + "/additionalItems", t3 += " " + f + " = true; if (" + c2 + ".length > " + o2.length + ") {  for (var " + m2 + " = " + o2.length + "; " + m2 + " < " + c2 + ".length; " + m2 + "++) { ", d.errorPath = e4.util.getPathExpr(e4.errorPath, m2, e4.opts.jsonPointers, true), x = c2 + "[" + m2 + "]", d.dataPathArr[v] = m2, R = e4.validate(d), d.baseId = g, e4.util.varOccurences(R, y) < 2 ? t3 += " " + e4.util.varReplace(R, y, x) + " " : t3 += " var " + y + " = " + x + "; " + R + " ", l && (t3 += " if (!" + f + ") break; "), t3 += " } }  ", l && (t3 += " if (" + f + ") { ", p += "}"));
        } else
          (e4.opts.strictKeywords ? typeof o2 == "object" && 0 < Object.keys(o2).length : e4.util.schemaHasRules(o2, e4.RULES.all)) && (d.schema = o2, d.schemaPath = i2, d.errSchemaPath = n2, t3 += "  for (var " + m2 + " = 0; " + m2 + " < " + c2 + ".length; " + m2 + "++) { ", d.errorPath = e4.util.getPathExpr(e4.errorPath, m2, e4.opts.jsonPointers, true), x = c2 + "[" + m2 + "]", d.dataPathArr[v] = m2, R = e4.validate(d), d.baseId = g, e4.util.varOccurences(R, y) < 2 ? t3 += " " + e4.util.varReplace(R, y, x) + " " : t3 += " var " + y + " = " + x + "; " + R + " ", l && (t3 += " if (!" + f + ") break; "), t3 += " }");
        return l && (t3 += " " + p + " if (" + h + " == errors) {"), t3;
      };
    }, {}], 29: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3 = " ", a3 = e4.level, s2 = e4.dataLevel, o2 = e4.schema[r3], i2 = e4.schemaPath + e4.util.getProperty(r3), n2 = e4.errSchemaPath + "/" + r3, l = !e4.opts.allErrors, c2 = "data" + (s2 || ""), u = e4.opts.$data && o2 && o2.$data, h = u ? (t3 += " var schema" + a3 + " = " + e4.util.getData(o2.$data, s2, e4.dataPathArr) + "; ", "schema" + a3) : o2;
        if (!u && typeof o2 != "number")
          throw new Error(r3 + " must be number");
        t3 += "var division" + a3 + ";if (", u && (t3 += " " + h + " !== undefined && ( typeof " + h + " != 'number' || "), t3 += " (division" + a3 + " = " + c2 + " / " + h + ", ", e4.opts.multipleOfPrecision ? t3 += " Math.abs(Math.round(division" + a3 + ") - division" + a3 + ") > 1e-" + e4.opts.multipleOfPrecision + " " : t3 += " division" + a3 + " !== parseInt(division" + a3 + ") ", t3 += " ) ", u && (t3 += "  )  "), t3 += " ) {   ";
        var d = d || [];
        d.push(t3), t3 = "", e4.createErrors !== false ? (t3 += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: { multipleOf: " + h + " } ", e4.opts.messages !== false && (t3 += " , message: 'should be multiple of ", t3 += u ? "' + " + h : h + "'"), e4.opts.verbose && (t3 += " , schema:  ", t3 += u ? "validate.schema" + i2 : "" + o2, t3 += "         , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ";
        var p = t3;
        return t3 = d.pop(), !e4.compositeRule && l ? e4.async ? t3 += " throw new ValidationError([" + p + "]); " : t3 += " validate.errors = [" + p + "]; return false; " : t3 += " var err = " + p + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t3 += "} ", l && (t3 += " else { "), t3;
      };
    }, {}], 30: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3 = " ", a3 = e4.level, s2 = e4.dataLevel, o2 = e4.schema[r3], i2 = e4.schemaPath + e4.util.getProperty(r3), n2 = e4.errSchemaPath + "/" + r3, l = !e4.opts.allErrors, c2 = "data" + (s2 || ""), u = "errs__" + a3, h = e4.util.copy(e4);
        h.level++;
        var d, p, f, m2, v = "valid" + h.level;
        return (e4.opts.strictKeywords ? typeof o2 == "object" && 0 < Object.keys(o2).length : e4.util.schemaHasRules(o2, e4.RULES.all)) ? (h.schema = o2, h.schemaPath = i2, h.errSchemaPath = n2, t3 += " var " + u + " = errors;  ", d = e4.compositeRule, e4.compositeRule = h.compositeRule = true, h.createErrors = false, h.opts.allErrors && (p = h.opts.allErrors, h.opts.allErrors = false), t3 += " " + e4.validate(h) + " ", h.createErrors = true, p && (h.opts.allErrors = p), e4.compositeRule = h.compositeRule = d, (f = f || []).push(t3 += " if (" + v + ") {   "), t3 = "", e4.createErrors !== false ? (t3 += " { keyword: 'not' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: {} ", e4.opts.messages !== false && (t3 += " , message: 'should NOT be valid' "), e4.opts.verbose && (t3 += " , schema: validate.schema" + i2 + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ", m2 = t3, t3 = f.pop(), !e4.compositeRule && l ? e4.async ? t3 += " throw new ValidationError([" + m2 + "]); " : t3 += " validate.errors = [" + m2 + "]; return false; " : t3 += " var err = " + m2 + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t3 += " } else {  errors = " + u + "; if (vErrors !== null) { if (" + u + ") vErrors.length = " + u + "; else vErrors = null; } ", e4.opts.allErrors && (t3 += " } ")) : (t3 += "  var err =   ", e4.createErrors !== false ? (t3 += " { keyword: 'not' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: {} ", e4.opts.messages !== false && (t3 += " , message: 'should NOT be valid' "), e4.opts.verbose && (t3 += " , schema: validate.schema" + i2 + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ", t3 += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", l && (t3 += " if (false) { ")), t3;
      };
    }, {}], 31: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3 = " ", a3 = e4.level, s2 = e4.dataLevel, o2 = e4.schema[r3], i2 = e4.schemaPath + e4.util.getProperty(r3), n2 = e4.errSchemaPath + "/" + r3, l = !e4.opts.allErrors, c2 = "data" + (s2 || ""), u = "valid" + a3, h = "errs__" + a3, d = e4.util.copy(e4), p = "";
        d.level++;
        var f = "valid" + d.level, m2 = d.baseId, v = "prevValid" + a3, y = "passingSchemas" + a3;
        t3 += "var " + h + " = errors , " + v + " = false , " + u + " = false , " + y + " = null; ";
        var g = e4.compositeRule;
        e4.compositeRule = d.compositeRule = true;
        var P = o2;
        if (P)
          for (var E, w = -1, b = P.length - 1; w < b; )
            E = P[w += 1], (e4.opts.strictKeywords ? typeof E == "object" && 0 < Object.keys(E).length : e4.util.schemaHasRules(E, e4.RULES.all)) ? (d.schema = E, d.schemaPath = i2 + "[" + w + "]", d.errSchemaPath = n2 + "/" + w, t3 += "  " + e4.validate(d) + " ", d.baseId = m2) : t3 += " var " + f + " = true; ", w && (t3 += " if (" + f + " && " + v + ") { " + u + " = false; " + y + " = [" + y + ", " + w + "]; } else { ", p += "}"), t3 += " if (" + f + ") { " + u + " = " + v + " = true; " + y + " = " + w + "; }";
        return e4.compositeRule = d.compositeRule = g, t3 += p + "if (!" + u + ") {   var err =   ", e4.createErrors !== false ? (t3 += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: { passingSchemas: " + y + " } ", e4.opts.messages !== false && (t3 += " , message: 'should match exactly one schema in oneOf' "), e4.opts.verbose && (t3 += " , schema: validate.schema" + i2 + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ", t3 += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e4.compositeRule && l && (e4.async ? t3 += " throw new ValidationError(vErrors); " : t3 += " validate.errors = vErrors; return false; "), t3 += "} else {  errors = " + h + "; if (vErrors !== null) { if (" + h + ") vErrors.length = " + h + "; else vErrors = null; }", e4.opts.allErrors && (t3 += " } "), t3;
      };
    }, {}], 32: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3 = " ", a3 = e4.level, s2 = e4.dataLevel, o2 = e4.schema[r3], i2 = e4.schemaPath + e4.util.getProperty(r3), n2 = e4.errSchemaPath + "/" + r3, l = !e4.opts.allErrors, c2 = "data" + (s2 || ""), u = e4.opts.$data && o2 && o2.$data, h = u ? (t3 += " var schema" + a3 + " = " + e4.util.getData(o2.$data, s2, e4.dataPathArr) + "; ", "schema" + a3) : o2;
        t3 += "if ( ", u && (t3 += " (" + h + " !== undefined && typeof " + h + " != 'string') || "), t3 += " !" + (u ? "(new RegExp(" + h + "))" : e4.usePattern(o2)) + ".test(" + c2 + ") ) {   ";
        var d = d || [];
        d.push(t3), t3 = "", e4.createErrors !== false ? (t3 += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: { pattern:  ", t3 += u ? "" + h : "" + e4.util.toQuotedString(o2), t3 += "  } ", e4.opts.messages !== false && (t3 += ` , message: 'should match pattern "`, t3 += u ? "' + " + h + " + '" : "" + e4.util.escapeQuotes(o2), t3 += `"' `), e4.opts.verbose && (t3 += " , schema:  ", t3 += u ? "validate.schema" + i2 : "" + e4.util.toQuotedString(o2), t3 += "         , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ";
        var p = t3;
        return t3 = d.pop(), !e4.compositeRule && l ? e4.async ? t3 += " throw new ValidationError([" + p + "]); " : t3 += " validate.errors = [" + p + "]; return false; " : t3 += " var err = " + p + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t3 += "} ", l && (t3 += " else { "), t3;
      };
    }, {}], 33: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3 = " ", a3 = e4.level, s2 = e4.dataLevel, o2 = e4.schema[r3], i2 = e4.schemaPath + e4.util.getProperty(r3), n2 = e4.errSchemaPath + "/" + r3, l = !e4.opts.allErrors, c2 = "data" + (s2 || ""), u = "errs__" + a3, h = e4.util.copy(e4), d = "";
        h.level++;
        var p, f, m2, v = "valid" + h.level, y = "key" + a3, g = "idx" + a3, P = h.dataLevel = e4.dataLevel + 1, E = "data" + P, w = "dataProperties" + a3, b = Object.keys(o2 || {}).filter(k), S = e4.schema.patternProperties || {}, _ = Object.keys(S).filter(k), F = e4.schema.additionalProperties, x = b.length || _.length, R = F === false, $ = typeof F == "object" && Object.keys(F).length, j = e4.opts.removeAdditional, D = R || $ || j, O = e4.opts.ownProperties, I = e4.baseId, A = e4.schema.required;
        function k(e5) {
          return e5 !== "__proto__";
        }
        if (A && (!e4.opts.$data || !A.$data) && A.length < e4.opts.loopRequired && (p = e4.util.toHash(A)), t3 += "var " + u + " = errors;var " + v + " = true;", O && (t3 += " var " + w + " = undefined;"), D) {
          if (t3 += O ? " " + w + " = " + w + " || Object.keys(" + c2 + "); for (var " + g + "=0; " + g + "<" + w + ".length; " + g + "++) { var " + y + " = " + w + "[" + g + "]; " : " for (var " + y + " in " + c2 + ") { ", x) {
            if (t3 += " var isAdditional" + a3 + " = !(false ", b.length)
              if (8 < b.length)
                t3 += " || validate.schema" + i2 + ".hasOwnProperty(" + y + ") ";
              else {
                var C = b;
                if (C)
                  for (var L = -1, N = C.length - 1; L < N; )
                    U = C[L += 1], t3 += " || " + y + " == " + e4.util.toQuotedString(U) + " ";
              }
            if (_.length) {
              var z = _;
              if (z)
                for (var T = -1, q = z.length - 1; T < q; )
                  te = z[T += 1], t3 += " || " + e4.usePattern(te) + ".test(" + y + ") ";
            }
            t3 += " ); if (isAdditional" + a3 + ") { ";
          }
          j == "all" ? t3 += " delete " + c2 + "[" + y + "]; " : (Z = e4.errorPath, f = "' + " + y + " + '", e4.opts._errorDataPathProperty && (e4.errorPath = e4.util.getPathExpr(e4.errorPath, y, e4.opts.jsonPointers)), R ? j ? t3 += " delete " + c2 + "[" + y + "]; " : (t3 += " " + v + " = false; ", G = n2, n2 = e4.errSchemaPath + "/additionalProperties", (W = W || []).push(t3), t3 = "", e4.createErrors !== false ? (t3 += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: { additionalProperty: '" + f + "' } ", e4.opts.messages !== false && (t3 += " , message: '", e4.opts._errorDataPathProperty ? t3 += "is an invalid additional property" : t3 += "should NOT have additional properties", t3 += "' "), e4.opts.verbose && (t3 += " , schema: false , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ", X = t3, t3 = W.pop(), !e4.compositeRule && l ? e4.async ? t3 += " throw new ValidationError([" + X + "]); " : t3 += " validate.errors = [" + X + "]; return false; " : t3 += " var err = " + X + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n2 = G, l && (t3 += " break; ")) : $ && (j == "failing" ? (t3 += " var " + u + " = errors;  ", m2 = e4.compositeRule, e4.compositeRule = h.compositeRule = true, h.schema = F, h.schemaPath = e4.schemaPath + ".additionalProperties", h.errSchemaPath = e4.errSchemaPath + "/additionalProperties", h.errorPath = e4.opts._errorDataPathProperty ? e4.errorPath : e4.util.getPathExpr(e4.errorPath, y, e4.opts.jsonPointers), oe = c2 + "[" + y + "]", h.dataPathArr[P] = y, ie = e4.validate(h), h.baseId = I, e4.util.varOccurences(ie, E) < 2 ? t3 += " " + e4.util.varReplace(ie, E, oe) + " " : t3 += " var " + E + " = " + oe + "; " + ie + " ", t3 += " if (!" + v + ") { errors = " + u + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + c2 + "[" + y + "]; }  ", e4.compositeRule = h.compositeRule = m2) : (h.schema = F, h.schemaPath = e4.schemaPath + ".additionalProperties", h.errSchemaPath = e4.errSchemaPath + "/additionalProperties", h.errorPath = e4.opts._errorDataPathProperty ? e4.errorPath : e4.util.getPathExpr(e4.errorPath, y, e4.opts.jsonPointers), oe = c2 + "[" + y + "]", h.dataPathArr[P] = y, ie = e4.validate(h), h.baseId = I, e4.util.varOccurences(ie, E) < 2 ? t3 += " " + e4.util.varReplace(ie, E, oe) + " " : t3 += " var " + E + " = " + oe + "; " + ie + " ", l && (t3 += " if (!" + v + ") break; "))), e4.errorPath = Z), x && (t3 += " } "), t3 += " }  ", l && (t3 += " if (" + v + ") { ", d += "}");
        }
        var Q = e4.opts.useDefaults && !e4.compositeRule;
        if (b.length) {
          var V = b;
          if (V)
            for (var U, H = -1, K = V.length - 1; H < K; ) {
              var M, B, J, Z, G, Y, W, X, ee = o2[U = V[H += 1]];
              (e4.opts.strictKeywords ? typeof ee == "object" && 0 < Object.keys(ee).length : e4.util.schemaHasRules(ee, e4.RULES.all)) && (oe = c2 + (M = e4.util.getProperty(U)), B = Q && ee.default !== void 0, h.schema = ee, h.schemaPath = i2 + M, h.errSchemaPath = n2 + "/" + e4.util.escapeFragment(U), h.errorPath = e4.util.getPath(e4.errorPath, U, e4.opts.jsonPointers), h.dataPathArr[P] = e4.util.toQuotedString(U), ie = e4.validate(h), h.baseId = I, e4.util.varOccurences(ie, E) < 2 ? (ie = e4.util.varReplace(ie, E, oe), J = oe) : t3 += " var " + (J = E) + " = " + oe + "; ", B ? t3 += " " + ie + " " : (p && p[U] ? (t3 += " if ( " + J + " === undefined ", O && (t3 += " || ! Object.prototype.hasOwnProperty.call(" + c2 + ", '" + e4.util.escapeQuotes(U) + "') "), t3 += ") { " + v + " = false; ", Z = e4.errorPath, G = n2, Y = e4.util.escapeQuotes(U), e4.opts._errorDataPathProperty && (e4.errorPath = e4.util.getPath(Z, U, e4.opts.jsonPointers)), n2 = e4.errSchemaPath + "/required", (W = W || []).push(t3), t3 = "", e4.createErrors !== false ? (t3 += " { keyword: 'required' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: { missingProperty: '" + Y + "' } ", e4.opts.messages !== false && (t3 += " , message: '", e4.opts._errorDataPathProperty ? t3 += "is a required property" : t3 += "should have required property \\'" + Y + "\\'", t3 += "' "), e4.opts.verbose && (t3 += " , schema: validate.schema" + i2 + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ", X = t3, t3 = W.pop(), !e4.compositeRule && l ? e4.async ? t3 += " throw new ValidationError([" + X + "]); " : t3 += " validate.errors = [" + X + "]; return false; " : t3 += " var err = " + X + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n2 = G, e4.errorPath = Z, t3 += " } else { ") : l ? (t3 += " if ( " + J + " === undefined ", O && (t3 += " || ! Object.prototype.hasOwnProperty.call(" + c2 + ", '" + e4.util.escapeQuotes(U) + "') "), t3 += ") { " + v + " = true; } else { ") : (t3 += " if (" + J + " !== undefined ", O && (t3 += " &&   Object.prototype.hasOwnProperty.call(" + c2 + ", '" + e4.util.escapeQuotes(U) + "') "), t3 += " ) { "), t3 += " " + ie + " } ")), l && (t3 += " if (" + v + ") { ", d += "}");
            }
        }
        if (_.length) {
          var re = _;
          if (re)
            for (var te, ae = -1, se = re.length - 1; ae < se; ) {
              var oe, ie;
              ee = S[te = re[ae += 1]], (e4.opts.strictKeywords ? typeof ee == "object" && 0 < Object.keys(ee).length : e4.util.schemaHasRules(ee, e4.RULES.all)) && (h.schema = ee, h.schemaPath = e4.schemaPath + ".patternProperties" + e4.util.getProperty(te), h.errSchemaPath = e4.errSchemaPath + "/patternProperties/" + e4.util.escapeFragment(te), t3 += O ? " " + w + " = " + w + " || Object.keys(" + c2 + "); for (var " + g + "=0; " + g + "<" + w + ".length; " + g + "++) { var " + y + " = " + w + "[" + g + "]; " : " for (var " + y + " in " + c2 + ") { ", t3 += " if (" + e4.usePattern(te) + ".test(" + y + ")) { ", h.errorPath = e4.util.getPathExpr(e4.errorPath, y, e4.opts.jsonPointers), oe = c2 + "[" + y + "]", h.dataPathArr[P] = y, ie = e4.validate(h), h.baseId = I, e4.util.varOccurences(ie, E) < 2 ? t3 += " " + e4.util.varReplace(ie, E, oe) + " " : t3 += " var " + E + " = " + oe + "; " + ie + " ", l && (t3 += " if (!" + v + ") break; "), t3 += " } ", l && (t3 += " else " + v + " = true; "), t3 += " }  ", l && (t3 += " if (" + v + ") { ", d += "}"));
            }
        }
        return l && (t3 += " " + d + " if (" + u + " == errors) {"), t3;
      };
    }, {}], 34: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3 = " ", a3 = e4.level, s2 = e4.dataLevel, o2 = e4.schema[r3], i2 = e4.schemaPath + e4.util.getProperty(r3), n2 = e4.errSchemaPath + "/" + r3, l = !e4.opts.allErrors, c2 = "data" + (s2 || ""), u = "errs__" + a3, h = e4.util.copy(e4);
        h.level++;
        var d, p, f, m2, v, y, g, P, E, w, b, S = "valid" + h.level;
        return t3 += "var " + u + " = errors;", (e4.opts.strictKeywords ? typeof o2 == "object" && 0 < Object.keys(o2).length : e4.util.schemaHasRules(o2, e4.RULES.all)) && (h.schema = o2, h.schemaPath = i2, h.errSchemaPath = n2, p = "idx" + a3, f = "i" + a3, m2 = "' + " + (d = "key" + a3) + " + '", v = "data" + (h.dataLevel = e4.dataLevel + 1), y = "dataProperties" + a3, g = e4.opts.ownProperties, P = e4.baseId, g && (t3 += " var " + y + " = undefined; "), t3 += g ? " " + y + " = " + y + " || Object.keys(" + c2 + "); for (var " + p + "=0; " + p + "<" + y + ".length; " + p + "++) { var " + d + " = " + y + "[" + p + "]; " : " for (var " + d + " in " + c2 + ") { ", t3 += " var startErrs" + a3 + " = errors; ", E = d, w = e4.compositeRule, e4.compositeRule = h.compositeRule = true, b = e4.validate(h), h.baseId = P, e4.util.varOccurences(b, v) < 2 ? t3 += " " + e4.util.varReplace(b, v, E) + " " : t3 += " var " + v + " = " + E + "; " + b + " ", e4.compositeRule = h.compositeRule = w, t3 += " if (!" + S + ") { for (var " + f + "=startErrs" + a3 + "; " + f + "<errors; " + f + "++) { vErrors[" + f + "].propertyName = " + d + "; }   var err =   ", e4.createErrors !== false ? (t3 += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: { propertyName: '" + m2 + "' } ", e4.opts.messages !== false && (t3 += " , message: 'property name \\'" + m2 + "\\' is invalid' "), e4.opts.verbose && (t3 += " , schema: validate.schema" + i2 + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ", t3 += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e4.compositeRule && l && (e4.async ? t3 += " throw new ValidationError(vErrors); " : t3 += " validate.errors = vErrors; return false; "), l && (t3 += " break; "), t3 += " } }"), l && (t3 += "  if (" + u + " == errors) {"), t3;
      };
    }, {}], 35: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3, a3, s2 = " ", o2 = e4.level, i2 = e4.dataLevel, n2 = e4.schema[r3], l = e4.errSchemaPath + "/" + r3, c2 = !e4.opts.allErrors, u = "data" + (i2 || ""), h = "valid" + o2;
        if (n2 == "#" || n2 == "#/")
          a3 = e4.isRoot ? (t3 = e4.async, "validate") : (t3 = e4.root.schema.$async === true, "root.refVal[0]");
        else {
          var d, p, f = e4.resolveRef(e4.baseId, n2, e4.isRoot);
          if (f === void 0) {
            var m2, v = e4.MissingRefError.message(e4.baseId, n2);
            if (e4.opts.missingRefs == "fail") {
              e4.logger.error(v), (m2 = m2 || []).push(s2), s2 = "", e4.createErrors !== false ? (s2 += " { keyword: '$ref' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(l) + " , params: { ref: '" + e4.util.escapeQuotes(n2) + "' } ", e4.opts.messages !== false && (s2 += " , message: 'can\\'t resolve reference " + e4.util.escapeQuotes(n2) + "' "), e4.opts.verbose && (s2 += " , schema: " + e4.util.toQuotedString(n2) + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + u + " "), s2 += " } ") : s2 += " {} ";
              var y = s2;
              s2 = m2.pop(), !e4.compositeRule && c2 ? e4.async ? s2 += " throw new ValidationError([" + y + "]); " : s2 += " validate.errors = [" + y + "]; return false; " : s2 += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", c2 && (s2 += " if (false) { ");
            } else {
              if (e4.opts.missingRefs != "ignore")
                throw new e4.MissingRefError(e4.baseId, n2, v);
              e4.logger.warn(v), c2 && (s2 += " if (true) { ");
            }
          } else
            f.inline ? ((d = e4.util.copy(e4)).level++, p = "valid" + d.level, d.schema = f.schema, d.schemaPath = "", d.errSchemaPath = n2, s2 += " " + e4.validate(d).replace(/validate\.schema/g, f.code) + " ", c2 && (s2 += " if (" + p + ") { ")) : (t3 = f.$async === true || e4.async && f.$async !== false, a3 = f.code);
        }
        if (a3) {
          (m2 = m2 || []).push(s2), s2 = "", e4.opts.passContext ? s2 += " " + a3 + ".call(this, " : s2 += " " + a3 + "( ", s2 += " " + u + ", (dataPath || '')", e4.errorPath != '""' && (s2 += " + " + e4.errorPath);
          var g = s2 += " , " + (i2 ? "data" + (i2 - 1 || "") : "parentData") + " , " + (i2 ? e4.dataPathArr[i2] : "parentDataProperty") + ", rootData)  ";
          if (s2 = m2.pop(), t3) {
            if (!e4.async)
              throw new Error("async schema referenced by sync schema");
            c2 && (s2 += " var " + h + "; "), s2 += " try { await " + g + "; ", c2 && (s2 += " " + h + " = true; "), s2 += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ", c2 && (s2 += " " + h + " = false; "), s2 += " } ", c2 && (s2 += " if (" + h + ") { ");
          } else
            s2 += " if (!" + g + ") { if (vErrors === null) vErrors = " + a3 + ".errors; else vErrors = vErrors.concat(" + a3 + ".errors); errors = vErrors.length; } ", c2 && (s2 += " else { ");
        }
        return s2;
      };
    }, {}], 36: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3 = " ", a3 = e4.level, s2 = e4.dataLevel, o2 = e4.schema[r3], i2 = e4.schemaPath + e4.util.getProperty(r3), n2 = e4.errSchemaPath + "/" + r3, l = !e4.opts.allErrors, c2 = "data" + (s2 || ""), u = "valid" + a3, h = e4.opts.$data && o2 && o2.$data, d = (h && (t3 += " var schema" + a3 + " = " + e4.util.getData(o2.$data, s2, e4.dataPathArr) + "; "), "schema" + a3);
        if (!h)
          if (o2.length < e4.opts.loopRequired && e4.schema.properties && Object.keys(e4.schema.properties).length) {
            var p = [], f = o2;
            if (f)
              for (var m2, v = -1, y = f.length - 1; v < y; ) {
                m2 = f[v += 1];
                var g = e4.schema.properties[m2];
                g && (e4.opts.strictKeywords ? typeof g == "object" && 0 < Object.keys(g).length : e4.util.schemaHasRules(g, e4.RULES.all)) || (p[p.length] = m2);
              }
          } else
            p = o2;
        if (h || p.length) {
          var P = e4.errorPath, E = h || p.length >= e4.opts.loopRequired, w = e4.opts.ownProperties;
          if (l)
            if (t3 += " var missing" + a3 + "; ", E) {
              h || (t3 += " var " + d + " = validate.schema" + i2 + "; ");
              var b = "' + " + ($ = "schema" + a3 + "[" + (x = "i" + a3) + "]") + " + '";
              e4.opts._errorDataPathProperty && (e4.errorPath = e4.util.getPathExpr(P, $, e4.opts.jsonPointers)), t3 += " var " + u + " = true; ", h && (t3 += " if (schema" + a3 + " === undefined) " + u + " = true; else if (!Array.isArray(schema" + a3 + ")) " + u + " = false; else {"), t3 += " for (var " + x + " = 0; " + x + " < " + d + ".length; " + x + "++) { " + u + " = " + c2 + "[" + d + "[" + x + "]] !== undefined ", w && (t3 += " &&   Object.prototype.hasOwnProperty.call(" + c2 + ", " + d + "[" + x + "]) "), t3 += "; if (!" + u + ") break; } ", h && (t3 += "  }  "), (_ = _ || []).push(t3 += "  if (!" + u + ") {   "), t3 = "", e4.createErrors !== false ? (t3 += " { keyword: 'required' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: { missingProperty: '" + b + "' } ", e4.opts.messages !== false && (t3 += " , message: '", e4.opts._errorDataPathProperty ? t3 += "is a required property" : t3 += "should have required property \\'" + b + "\\'", t3 += "' "), e4.opts.verbose && (t3 += " , schema: validate.schema" + i2 + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ";
              var S = t3;
              t3 = _.pop(), !e4.compositeRule && l ? e4.async ? t3 += " throw new ValidationError([" + S + "]); " : t3 += " validate.errors = [" + S + "]; return false; " : t3 += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t3 += " } else { ";
            } else {
              t3 += " if ( ";
              var _, F = p;
              if (F)
                for (var x = -1, R = F.length - 1; x < R; )
                  D = F[x += 1], x && (t3 += " || "), t3 += " ( ( " + (k = c2 + (A = e4.util.getProperty(D))) + " === undefined ", w && (t3 += " || ! Object.prototype.hasOwnProperty.call(" + c2 + ", '" + e4.util.escapeQuotes(D) + "') "), t3 += ") && (missing" + a3 + " = " + e4.util.toQuotedString(e4.opts.jsonPointers ? D : A) + ") ) ";
              t3 += ") {  ", b = "' + " + ($ = "missing" + a3) + " + '", e4.opts._errorDataPathProperty && (e4.errorPath = e4.opts.jsonPointers ? e4.util.getPathExpr(P, $, true) : P + " + " + $), (_ = _ || []).push(t3), t3 = "", e4.createErrors !== false ? (t3 += " { keyword: 'required' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: { missingProperty: '" + b + "' } ", e4.opts.messages !== false && (t3 += " , message: '", e4.opts._errorDataPathProperty ? t3 += "is a required property" : t3 += "should have required property \\'" + b + "\\'", t3 += "' "), e4.opts.verbose && (t3 += " , schema: validate.schema" + i2 + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ", S = t3, t3 = _.pop(), !e4.compositeRule && l ? e4.async ? t3 += " throw new ValidationError([" + S + "]); " : t3 += " validate.errors = [" + S + "]; return false; " : t3 += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t3 += " } else { ";
            }
          else if (E) {
            var $;
            h || (t3 += " var " + d + " = validate.schema" + i2 + "; "), b = "' + " + ($ = "schema" + a3 + "[" + (x = "i" + a3) + "]") + " + '", e4.opts._errorDataPathProperty && (e4.errorPath = e4.util.getPathExpr(P, $, e4.opts.jsonPointers)), h && (t3 += " if (" + d + " && !Array.isArray(" + d + ")) {  var err =   ", e4.createErrors !== false ? (t3 += " { keyword: 'required' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: { missingProperty: '" + b + "' } ", e4.opts.messages !== false && (t3 += " , message: '", e4.opts._errorDataPathProperty ? t3 += "is a required property" : t3 += "should have required property \\'" + b + "\\'", t3 += "' "), e4.opts.verbose && (t3 += " , schema: validate.schema" + i2 + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ", t3 += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + d + " !== undefined) { "), t3 += " for (var " + x + " = 0; " + x + " < " + d + ".length; " + x + "++) { if (" + c2 + "[" + d + "[" + x + "]] === undefined ", w && (t3 += " || ! Object.prototype.hasOwnProperty.call(" + c2 + ", " + d + "[" + x + "]) "), t3 += ") {  var err =   ", e4.createErrors !== false ? (t3 += " { keyword: 'required' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: { missingProperty: '" + b + "' } ", e4.opts.messages !== false && (t3 += " , message: '", e4.opts._errorDataPathProperty ? t3 += "is a required property" : t3 += "should have required property \\'" + b + "\\'", t3 += "' "), e4.opts.verbose && (t3 += " , schema: validate.schema" + i2 + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ", t3 += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ", h && (t3 += "  }  ");
          } else {
            var j = p;
            if (j)
              for (var D, O = -1, I = j.length - 1; O < I; ) {
                D = j[O += 1];
                var A = e4.util.getProperty(D), k = (b = e4.util.escapeQuotes(D), c2 + A);
                e4.opts._errorDataPathProperty && (e4.errorPath = e4.util.getPath(P, D, e4.opts.jsonPointers)), t3 += " if ( " + k + " === undefined ", w && (t3 += " || ! Object.prototype.hasOwnProperty.call(" + c2 + ", '" + e4.util.escapeQuotes(D) + "') "), t3 += ") {  var err =   ", e4.createErrors !== false ? (t3 += " { keyword: 'required' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(n2) + " , params: { missingProperty: '" + b + "' } ", e4.opts.messages !== false && (t3 += " , message: '", e4.opts._errorDataPathProperty ? t3 += "is a required property" : t3 += "should have required property \\'" + b + "\\'", t3 += "' "), e4.opts.verbose && (t3 += " , schema: validate.schema" + i2 + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + c2 + " "), t3 += " } ") : t3 += " {} ", t3 += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
              }
          }
          e4.errorPath = P;
        } else
          l && (t3 += " if (true) {");
        return t3;
      };
    }, {}], 37: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3, a3, s2, o2, i2, n2 = " ", l = e4.level, c2 = e4.dataLevel, u = e4.schema[r3], h = e4.schemaPath + e4.util.getProperty(r3), d = e4.errSchemaPath + "/" + r3, p = !e4.opts.allErrors, f = "data" + (c2 || ""), m2 = "valid" + l, v = e4.opts.$data && u && u.$data, y = v ? (n2 += " var schema" + l + " = " + e4.util.getData(u.$data, c2, e4.dataPathArr) + "; ", "schema" + l) : u;
        return (u || v) && e4.opts.uniqueItems !== false ? (v && (n2 += " var " + m2 + "; if (" + y + " === false || " + y + " === undefined) " + m2 + " = true; else if (typeof " + y + " != 'boolean') " + m2 + " = false; else { "), n2 += " var i = " + f + ".length , " + m2 + " = true , j; if (i > 1) { ", t3 = e4.schema.items && e4.schema.items.type, a3 = Array.isArray(t3), !t3 || t3 == "object" || t3 == "array" || a3 && (0 <= t3.indexOf("object") || 0 <= t3.indexOf("array")) ? n2 += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + f + "[i], " + f + "[j])) { " + m2 + " = false; break outer; } } } " : (n2 += " var itemIndices = {}, item; for (;i--;) { var item = " + f + "[i]; ", s2 = "checkDataType" + (a3 ? "s" : ""), n2 += " if (" + e4.util[s2](t3, "item", e4.opts.strictNumbers, true) + ") continue; ", a3 && (n2 += ` if (typeof item == 'string') item = '"' + item; `), n2 += " if (typeof itemIndices[item] == 'number') { " + m2 + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } "), n2 += " } ", v && (n2 += "  }  "), (o2 = o2 || []).push(n2 += " if (!" + m2 + ") {   "), n2 = "", e4.createErrors !== false ? (n2 += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(d) + " , params: { i: i, j: j } ", e4.opts.messages !== false && (n2 += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' "), e4.opts.verbose && (n2 += " , schema:  ", n2 += v ? "validate.schema" + h : "" + u, n2 += "         , parentSchema: validate.schema" + e4.schemaPath + " , data: " + f + " "), n2 += " } ") : n2 += " {} ", i2 = n2, n2 = o2.pop(), !e4.compositeRule && p ? e4.async ? n2 += " throw new ValidationError([" + i2 + "]); " : n2 += " validate.errors = [" + i2 + "]; return false; " : n2 += " var err = " + i2 + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n2 += " } ", p && (n2 += " else { ")) : p && (n2 += " if (true) { "), n2;
      };
    }, {}], 38: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        var t3 = "", a3 = e4.schema.$async === true, s2 = e4.util.schemaHasRulesExcept(e4.schema, e4.RULES.all, "$ref"), o2 = e4.self._getId(e4.schema);
        if (e4.opts.strictKeywords) {
          var i2 = e4.util.schemaUnknownRules(e4.schema, e4.RULES.keywords);
          if (i2) {
            var n2 = "unknown keyword: " + i2;
            if (e4.opts.strictKeywords !== "log")
              throw new Error(n2);
            e4.logger.warn(n2);
          }
        }
        if (e4.isTop && (t3 += " var validate = ", a3 && (e4.async = true, t3 += "async "), t3 += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ", o2 && (e4.opts.sourceCode || e4.opts.processCode) && (t3 += " /*# sourceURL=" + o2 + " */ ")), typeof e4.schema == "boolean" || !s2 && !e4.schema.$ref) {
          r3 = "false schema";
          var l = e4.level, c2 = e4.dataLevel, u = e4.schema[r3], h = e4.schemaPath + e4.util.getProperty(r3), d = e4.errSchemaPath + "/" + r3, p = !e4.opts.allErrors, f = "data" + (c2 || ""), m2 = "valid" + l;
          return e4.schema === false ? (e4.isTop ? p = true : t3 += " var " + m2 + " = false; ", (H = H || []).push(t3), t3 = "", e4.createErrors !== false ? (t3 += " { keyword: 'false schema' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(d) + " , params: {} ", e4.opts.messages !== false && (t3 += " , message: 'boolean schema is false' "), e4.opts.verbose && (t3 += " , schema: false , parentSchema: validate.schema" + e4.schemaPath + " , data: " + f + " "), t3 += " } ") : t3 += " {} ", O = t3, t3 = H.pop(), !e4.compositeRule && p ? e4.async ? t3 += " throw new ValidationError([" + O + "]); " : t3 += " validate.errors = [" + O + "]; return false; " : t3 += " var err = " + O + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ") : e4.isTop ? t3 += a3 ? " return data; " : " validate.errors = null; return true; " : t3 += " var " + m2 + " = true; ", e4.isTop && (t3 += " }; return validate; "), t3;
        }
        if (e4.isTop) {
          var v = e4.isTop;
          if (l = e4.level = 0, c2 = e4.dataLevel = 0, f = "data", e4.rootId = e4.resolve.fullPath(e4.self._getId(e4.root.schema)), e4.baseId = e4.baseId || e4.rootId, delete e4.isTop, e4.dataPathArr = [void 0], e4.schema.default !== void 0 && e4.opts.useDefaults && e4.opts.strictDefaults) {
            var y = "default is ignored in the schema root";
            if (e4.opts.strictDefaults !== "log")
              throw new Error(y);
            e4.logger.warn(y);
          }
          t3 += " var vErrors = null; ", t3 += " var errors = 0;     ", t3 += " if (rootData === undefined) rootData = data; ";
        } else {
          if (l = e4.level, f = "data" + ((c2 = e4.dataLevel) || ""), o2 && (e4.baseId = e4.resolve.url(e4.baseId, o2)), a3 && !e4.async)
            throw new Error("async schema in sync schema");
          t3 += " var errs_" + l + " = errors;";
        }
        m2 = "valid" + l, p = !e4.opts.allErrors;
        var g, P = "", E = "", w = e4.schema.type, b = Array.isArray(w);
        if (w && e4.opts.nullable && e4.schema.nullable === true && (b ? w.indexOf("null") == -1 && (w = w.concat("null")) : w != "null" && (w = [w, "null"], b = true)), b && w.length == 1 && (w = w[0], b = false), e4.schema.$ref && s2) {
          if (e4.opts.extendRefs == "fail")
            throw new Error('$ref: validation keywords used in schema at path "' + e4.errSchemaPath + '" (see option extendRefs)');
          e4.opts.extendRefs !== true && (s2 = false, e4.logger.warn('$ref: keywords ignored in schema at path "' + e4.errSchemaPath + '"'));
        }
        if (e4.schema.$comment && e4.opts.$comment && (t3 += " " + e4.RULES.all.$comment.code(e4, "$comment")), w) {
          e4.opts.coerceTypes && (g = e4.util.coerceToTypes(e4.opts.coerceTypes, w));
          var S = e4.RULES.types[w];
          if (g || b || S === true || S && !G(S)) {
            h = e4.schemaPath + ".type", d = e4.errSchemaPath + "/type", h = e4.schemaPath + ".type", d = e4.errSchemaPath + "/type";
            var _ = b ? "checkDataTypes" : "checkDataType";
            if (t3 += " if (" + e4.util[_](w, f, e4.opts.strictNumbers, true) + ") { ", g) {
              var F = "dataType" + l, x = "coerced" + l;
              t3 += " var " + F + " = typeof " + f + "; var " + x + " = undefined; ", e4.opts.coerceTypes == "array" && (t3 += " if (" + F + " == 'object' && Array.isArray(" + f + ") && " + f + ".length == 1) { " + f + " = " + f + "[0]; " + F + " = typeof " + f + "; if (" + e4.util.checkDataType(e4.schema.type, f, e4.opts.strictNumbers) + ") " + x + " = " + f + "; } "), t3 += " if (" + x + " !== undefined) ; ";
              var R = g;
              if (R)
                for (var $, j = -1, D = R.length - 1; j < D; )
                  ($ = R[j += 1]) == "string" ? t3 += " else if (" + F + " == 'number' || " + F + " == 'boolean') " + x + " = '' + " + f + "; else if (" + f + " === null) " + x + " = ''; " : $ == "number" || $ == "integer" ? (t3 += " else if (" + F + " == 'boolean' || " + f + " === null || (" + F + " == 'string' && " + f + " && " + f + " == +" + f + " ", $ == "integer" && (t3 += " && !(" + f + " % 1)"), t3 += ")) " + x + " = +" + f + "; ") : $ == "boolean" ? t3 += " else if (" + f + " === 'false' || " + f + " === 0 || " + f + " === null) " + x + " = false; else if (" + f + " === 'true' || " + f + " === 1) " + x + " = true; " : $ == "null" ? t3 += " else if (" + f + " === '' || " + f + " === 0 || " + f + " === false) " + x + " = null; " : e4.opts.coerceTypes == "array" && $ == "array" && (t3 += " else if (" + F + " == 'string' || " + F + " == 'number' || " + F + " == 'boolean' || " + f + " == null) " + x + " = [" + f + "]; ");
              (H = H || []).push(t3 += " else {   "), t3 = "", e4.createErrors !== false ? (t3 += " { keyword: 'type' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(d) + " , params: { type: '", t3 += b ? "" + w.join(",") : "" + w, t3 += "' } ", e4.opts.messages !== false && (t3 += " , message: 'should be ", t3 += b ? "" + w.join(",") : "" + w, t3 += "' "), e4.opts.verbose && (t3 += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + f + " "), t3 += " } ") : t3 += " {} ";
              var O = t3;
              t3 = H.pop(), !e4.compositeRule && p ? e4.async ? t3 += " throw new ValidationError([" + O + "]); " : t3 += " validate.errors = [" + O + "]; return false; " : t3 += " var err = " + O + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t3 += " } if (" + x + " !== undefined) {  ";
              var I = c2 ? "data" + (c2 - 1 || "") : "parentData";
              t3 += " " + f + " = " + x + "; ", c2 || (t3 += "if (" + I + " !== undefined)"), t3 += " " + I + "[" + (c2 ? e4.dataPathArr[c2] : "parentDataProperty") + "] = " + x + "; } ";
            } else
              (H = H || []).push(t3), t3 = "", e4.createErrors !== false ? (t3 += " { keyword: 'type' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(d) + " , params: { type: '", t3 += b ? "" + w.join(",") : "" + w, t3 += "' } ", e4.opts.messages !== false && (t3 += " , message: 'should be ", t3 += b ? "" + w.join(",") : "" + w, t3 += "' "), e4.opts.verbose && (t3 += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + f + " "), t3 += " } ") : t3 += " {} ", O = t3, t3 = H.pop(), !e4.compositeRule && p ? e4.async ? t3 += " throw new ValidationError([" + O + "]); " : t3 += " validate.errors = [" + O + "]; return false; " : t3 += " var err = " + O + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            t3 += " } ";
          }
        }
        if (e4.schema.$ref && !s2)
          t3 += " " + e4.RULES.all.$ref.code(e4, "$ref") + " ", p && (t3 += " } if (errors === ", t3 += v ? "0" : "errs_" + l, t3 += ") { ", E += "}");
        else {
          var A = e4.RULES;
          if (A) {
            for (var k = -1, C = A.length - 1; k < C; )
              if (G(S = A[k += 1])) {
                if (S.type && (t3 += " if (" + e4.util.checkDataType(S.type, f, e4.opts.strictNumbers) + ") { "), e4.opts.useDefaults) {
                  if (S.type == "object" && e4.schema.properties) {
                    u = e4.schema.properties;
                    var L = Object.keys(u);
                    if (L) {
                      for (var N, z = -1, T = L.length - 1; z < T; )
                        if ((V = u[N = L[z += 1]]).default !== void 0) {
                          var q = f + e4.util.getProperty(N);
                          if (e4.compositeRule) {
                            if (e4.opts.strictDefaults) {
                              if (y = "default is ignored for: " + q, e4.opts.strictDefaults !== "log")
                                throw new Error(y);
                              e4.logger.warn(y);
                            }
                          } else
                            t3 += " if (" + q + " === undefined ", e4.opts.useDefaults == "empty" && (t3 += " || " + q + " === null || " + q + " === '' "), t3 += " ) " + q + " = ", e4.opts.useDefaults == "shared" ? t3 += " " + e4.useDefault(V.default) + " " : t3 += " " + JSON.stringify(V.default) + " ", t3 += "; ";
                        }
                    }
                  } else if (S.type == "array" && Array.isArray(e4.schema.items)) {
                    var Q = e4.schema.items;
                    if (Q) {
                      j = -1;
                      for (var V, U = Q.length - 1; j < U; )
                        if ((V = Q[j += 1]).default !== void 0)
                          if (q = f + "[" + j + "]", e4.compositeRule) {
                            if (e4.opts.strictDefaults) {
                              if (y = "default is ignored for: " + q, e4.opts.strictDefaults !== "log")
                                throw new Error(y);
                              e4.logger.warn(y);
                            }
                          } else
                            t3 += " if (" + q + " === undefined ", e4.opts.useDefaults == "empty" && (t3 += " || " + q + " === null || " + q + " === '' "), t3 += " ) " + q + " = ", e4.opts.useDefaults == "shared" ? t3 += " " + e4.useDefault(V.default) + " " : t3 += " " + JSON.stringify(V.default) + " ", t3 += "; ";
                    }
                  }
                }
                var H, K = S.rules;
                if (K)
                  for (var M, B, J = -1, Z = K.length - 1; J < Z; )
                    !Y(B = K[J += 1]) || (M = B.code(e4, B.keyword, S.type)) && (t3 += " " + M + " ", p && (P += "}"));
                p && (t3 += " " + P + " ", P = ""), S.type && (t3 += " } ", w && w === S.type && !g && (t3 += " else { ", h = e4.schemaPath + ".type", d = e4.errSchemaPath + "/type", (H = H || []).push(t3), t3 = "", e4.createErrors !== false ? (t3 += " { keyword: 'type' , dataPath: (dataPath || '') + " + e4.errorPath + " , schemaPath: " + e4.util.toQuotedString(d) + " , params: { type: '", t3 += b ? "" + w.join(",") : "" + w, t3 += "' } ", e4.opts.messages !== false && (t3 += " , message: 'should be ", t3 += b ? "" + w.join(",") : "" + w, t3 += "' "), e4.opts.verbose && (t3 += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + e4.schemaPath + " , data: " + f + " "), t3 += " } ") : t3 += " {} ", O = t3, t3 = H.pop(), !e4.compositeRule && p ? e4.async ? t3 += " throw new ValidationError([" + O + "]); " : t3 += " validate.errors = [" + O + "]; return false; " : t3 += " var err = " + O + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t3 += " } ")), p && (t3 += " if (errors === ", t3 += v ? "0" : "errs_" + l, t3 += ") { ", E += "}");
              }
          }
        }
        function G(e5) {
          for (var r4 = e5.rules, t4 = 0; t4 < r4.length; t4++)
            if (Y(r4[t4]))
              return 1;
        }
        function Y(r4) {
          return e4.schema[r4.keyword] !== void 0 || r4.implements && function(r5) {
            for (var t4 = r5.implements, a4 = 0; a4 < t4.length; a4++)
              if (e4.schema[t4[a4]] !== void 0)
                return true;
          }(r4);
        }
        return p && (t3 += " " + E + " "), v ? (a3 ? (t3 += " if (errors === 0) return data;           ", t3 += " else throw new ValidationError(vErrors); ") : (t3 += " validate.errors = vErrors; ", t3 += " return errors === 0;       "), t3 += " }; return validate;") : t3 += " var " + m2 + " = errors === errs_" + l + ";", t3;
      };
    }, {}], 39: [function(e3, r2, t2) {
      var a3 = /^[a-z_$][a-z0-9_$-]*$/i, s2 = e3("./dotjs/custom"), o2 = e3("./definition_schema");
      function i2(e4, r3) {
        i2.errors = null;
        var t3 = this._validateKeyword = this._validateKeyword || this.compile(o2, true);
        if (t3(e4))
          return true;
        if (i2.errors = t3.errors, r3)
          throw new Error("custom keyword definition is invalid: " + this.errorsText(t3.errors));
        return false;
      }
      r2.exports = { add: function(e4, r3) {
        var t3 = this.RULES;
        if (t3.keywords[e4])
          throw new Error("Keyword " + e4 + " is already defined");
        if (!a3.test(e4))
          throw new Error("Keyword " + e4 + " is not a valid identifier");
        if (r3) {
          this.validateKeyword(r3, true);
          var o3 = r3.type;
          if (Array.isArray(o3))
            for (var i3 = 0; i3 < o3.length; i3++)
              l(e4, o3[i3], r3);
          else
            l(e4, o3, r3);
          var n2 = r3.metaSchema;
          n2 && (r3.$data && this._opts.$data && (n2 = { anyOf: [n2, { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }] }), r3.validateSchema = this.compile(n2, true));
        }
        function l(e5, r4, a4) {
          for (var o4, i4 = 0; i4 < t3.length; i4++) {
            var n3 = t3[i4];
            if (n3.type == r4) {
              o4 = n3;
              break;
            }
          }
          o4 || (o4 = { type: r4, rules: [] }, t3.push(o4));
          var l2 = { keyword: e5, definition: a4, custom: true, code: s2, implements: a4.implements };
          o4.rules.push(l2), t3.custom[e5] = l2;
        }
        return t3.keywords[e4] = t3.all[e4] = true, this;
      }, get: function(e4) {
        var r3 = this.RULES.custom[e4];
        return r3 ? r3.definition : this.RULES.keywords[e4] || false;
      }, remove: function(e4) {
        var r3 = this.RULES;
        delete r3.keywords[e4], delete r3.all[e4], delete r3.custom[e4];
        for (var t3 = 0; t3 < r3.length; t3++)
          for (var a4 = r3[t3].rules, s3 = 0; s3 < a4.length; s3++)
            if (a4[s3].keyword == e4) {
              a4.splice(s3, 1);
              break;
            }
        return this;
      }, validate: i2 };
    }, { "./definition_schema": 12, "./dotjs/custom": 22 }], 40: [function(e3, r2, t2) {
      r2.exports = { $schema: "http://json-schema.org/draft-07/schema#", $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", description: "Meta-schema for $data reference (JSON Schema extension proposal)", type: "object", required: ["$data"], properties: { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, additionalProperties: false };
    }, {}], 41: [function(e3, r2, t2) {
      r2.exports = { $schema: "http://json-schema.org/draft-07/schema#", $id: "http://json-schema.org/draft-07/schema#", title: "Core schema meta-schema", definitions: { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: true, default: [] } }, type: ["object", "boolean"], properties: { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: true, readOnly: { type: "boolean", default: false }, examples: { type: "array", items: true }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: true }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: false }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: true, enum: { type: "array", items: true, minItems: 1, uniqueItems: true }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: true }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, default: true };
    }, {}], 42: [function(e3, r2, t2) {
      r2.exports = function e4(r3, t3) {
        if (r3 === t3)
          return true;
        if (r3 && t3 && typeof r3 == "object" && typeof t3 == "object") {
          if (r3.constructor !== t3.constructor)
            return false;
          var a3, s2, o2;
          if (Array.isArray(r3)) {
            if ((a3 = r3.length) != t3.length)
              return false;
            for (s2 = a3; s2-- != 0; )
              if (!e4(r3[s2], t3[s2]))
                return false;
            return true;
          }
          if (r3.constructor === RegExp)
            return r3.source === t3.source && r3.flags === t3.flags;
          if (r3.valueOf !== Object.prototype.valueOf)
            return r3.valueOf() === t3.valueOf();
          if (r3.toString !== Object.prototype.toString)
            return r3.toString() === t3.toString();
          if ((a3 = (o2 = Object.keys(r3)).length) !== Object.keys(t3).length)
            return false;
          for (s2 = a3; s2-- != 0; )
            if (!Object.prototype.hasOwnProperty.call(t3, o2[s2]))
              return false;
          for (s2 = a3; s2-- != 0; ) {
            var i2 = o2[s2];
            if (!e4(r3[i2], t3[i2]))
              return false;
          }
          return true;
        }
        return r3 != r3 && t3 != t3;
      };
    }, {}], 43: [function(e3, r2, t2) {
      r2.exports = function(e4, r3) {
        typeof (r3 = r3 || {}) == "function" && (r3 = { cmp: r3 });
        var t3, a3 = typeof r3.cycles == "boolean" && r3.cycles, s2 = r3.cmp && (t3 = r3.cmp, function(e5) {
          return function(r4, a4) {
            var s3 = { key: r4, value: e5[r4] }, o3 = { key: a4, value: e5[a4] };
            return t3(s3, o3);
          };
        }), o2 = [];
        return function e5(r4) {
          if (r4 && r4.toJSON && typeof r4.toJSON == "function" && (r4 = r4.toJSON()), r4 !== void 0) {
            if (typeof r4 == "number")
              return isFinite(r4) ? "" + r4 : "null";
            if (typeof r4 != "object")
              return JSON.stringify(r4);
            if (Array.isArray(r4)) {
              for (n2 = "[", l = 0; l < r4.length; l++)
                l && (n2 += ","), n2 += e5(r4[l]) || "null";
              return n2 + "]";
            }
            if (r4 === null)
              return "null";
            if (o2.indexOf(r4) !== -1) {
              if (a3)
                return JSON.stringify("__cycle__");
              throw new TypeError("Converting circular structure to JSON");
            }
            for (var t4 = o2.push(r4) - 1, i2 = Object.keys(r4).sort(s2 && s2(r4)), n2 = "", l = 0; l < i2.length; l++) {
              var c2 = i2[l], u = e5(r4[c2]);
              u && (n2 && (n2 += ","), n2 += JSON.stringify(c2) + ":" + u);
            }
            return o2.splice(t4, 1), "{" + n2 + "}";
          }
        }(e4);
      };
    }, {}], 44: [function(e3, r2, t2) {
      var a3 = r2.exports = function(e4, r3, t3) {
        typeof r3 == "function" && (t3 = r3, r3 = {}), function e5(r4, t4, s2, o2, i2, n2, l, c2, u, h) {
          if (o2 && typeof o2 == "object" && !Array.isArray(o2)) {
            for (var d in t4(o2, i2, n2, l, c2, u, h), o2) {
              var p = o2[d];
              if (Array.isArray(p)) {
                if (d in a3.arrayKeywords)
                  for (var f = 0; f < p.length; f++)
                    e5(r4, t4, s2, p[f], i2 + "/" + d + "/" + f, n2, i2, d, o2, f);
              } else if (d in a3.propsKeywords) {
                if (p && typeof p == "object")
                  for (var m2 in p)
                    e5(r4, t4, s2, p[m2], i2 + "/" + d + "/" + m2.replace(/~/g, "~0").replace(/\//g, "~1"), n2, i2, d, o2, m2);
              } else
                (d in a3.keywords || r4.allKeys && !(d in a3.skipKeywords)) && e5(r4, t4, s2, p, i2 + "/" + d, n2, i2, d, o2);
            }
            s2(o2, i2, n2, l, c2, u, h);
          }
        }(r3, typeof (t3 = r3.cb || t3) == "function" ? t3 : t3.pre || function() {
        }, t3.post || function() {
        }, e4, "", e4);
      };
      a3.keywords = { additionalItems: true, items: true, contains: true, additionalProperties: true, propertyNames: true, not: true }, a3.arrayKeywords = { items: true, allOf: true, anyOf: true, oneOf: true }, a3.propsKeywords = { definitions: true, properties: true, patternProperties: true, dependencies: true }, a3.skipKeywords = { default: true, enum: true, const: true, required: true, maximum: true, minimum: true, exclusiveMaximum: true, exclusiveMinimum: true, multipleOf: true, maxLength: true, minLength: true, pattern: true, format: true, maxItems: true, minItems: true, uniqueItems: true, maxProperties: true, minProperties: true };
    }, {}], 45: [function(e3, r2, t2) {
      var a3;
      a3 = this, function(e4) {
        function r3() {
          for (var e5 = arguments.length, r4 = Array(e5), t4 = 0; t4 < e5; t4++)
            r4[t4] = arguments[t4];
          if (1 < r4.length) {
            r4[0] = r4[0].slice(0, -1);
            for (var a5 = r4.length - 1, s3 = 1; s3 < a5; ++s3)
              r4[s3] = r4[s3].slice(1, -1);
            return r4[a5] = r4[a5].slice(1), r4.join("");
          }
          return r4[0];
        }
        function t3(e5) {
          return "(?:" + e5 + ")";
        }
        function a4(e5) {
          return e5 === void 0 ? "undefined" : e5 === null ? "null" : Object.prototype.toString.call(e5).split(" ").pop().split("]").shift().toLowerCase();
        }
        function s2(e5) {
          return e5.toUpperCase();
        }
        function o2(e5) {
          var a5 = "[A-Za-z]", s3 = "[0-9]", o3 = r3(s3, "[A-Fa-f]"), i3 = t3(t3("%[EFef]" + o3 + "%" + o3 + o3 + "%" + o3 + o3) + "|" + t3("%[89A-Fa-f]" + o3 + "%" + o3 + o3) + "|" + t3("%" + o3 + o3)), n3 = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", l2 = r3("[\\:\\/\\?\\#\\[\\]\\@]", n3), c3 = e5 ? "[\\uE000-\\uF8FF]" : "[]", u2 = r3(a5, s3, "[\\-\\.\\_\\~]", e5 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]"), h2 = (t3(a5 + r3(a5, s3, "[\\+\\-\\.]") + "*"), t3(t3(i3 + "|" + r3(u2, n3, "[\\:]")) + "*"), t3("(?:25[0-5])|(?:2[0-4][0-9])|(?:1[0-9][0-9])|(?:0?[1-9][0-9])|0?0?" + s3)), d2 = t3(h2 + "\\." + h2 + "\\." + h2 + "\\." + h2), p2 = t3(o3 + "{1,4}"), f2 = t3(t3(p2 + "\\:" + p2) + "|" + d2), m3 = t3(t3(p2 + "\\:") + "{6}" + f2), v2 = t3("\\:\\:" + t3(p2 + "\\:") + "{5}" + f2), y2 = t3(t3(p2) + "?\\:\\:" + t3(p2 + "\\:") + "{4}" + f2), g2 = t3(t3(t3(p2 + "\\:") + "{0,1}" + p2) + "?\\:\\:" + t3(p2 + "\\:") + "{3}" + f2), P2 = t3(t3(t3(p2 + "\\:") + "{0,2}" + p2) + "?\\:\\:" + t3(p2 + "\\:") + "{2}" + f2), E2 = t3(t3(t3(p2 + "\\:") + "{0,3}" + p2) + "?\\:\\:" + p2 + "\\:" + f2), w2 = t3(t3(t3(p2 + "\\:") + "{0,4}" + p2) + "?\\:\\:" + f2), b2 = t3(t3(t3(p2 + "\\:") + "{0,5}" + p2) + "?\\:\\:" + p2), S2 = t3(t3(t3(p2 + "\\:") + "{0,6}" + p2) + "?\\:\\:"), _2 = t3([m3, v2, y2, g2, P2, E2, w2, b2, S2].join("|")), F2 = t3(t3(u2 + "|" + i3) + "+"), x2 = (t3("[vV]" + o3 + "+\\." + r3(u2, n3, "[\\:]") + "+"), t3(t3(i3 + "|" + r3(u2, n3)) + "*"), t3(i3 + "|" + r3(u2, n3, "[\\:\\@]")));
          return t3(t3(i3 + "|" + r3(u2, n3, "[\\@]")) + "+"), t3(t3(x2 + "|" + r3("[\\/\\?]", c3)) + "*"), { NOT_SCHEME: new RegExp(r3("[^]", a5, s3, "[\\+\\-\\.]"), "g"), NOT_USERINFO: new RegExp(r3("[^\\%\\:]", u2, n3), "g"), NOT_HOST: new RegExp(r3("[^\\%\\[\\]\\:]", u2, n3), "g"), NOT_PATH: new RegExp(r3("[^\\%\\/\\:\\@]", u2, n3), "g"), NOT_PATH_NOSCHEME: new RegExp(r3("[^\\%\\/\\@]", u2, n3), "g"), NOT_QUERY: new RegExp(r3("[^\\%]", u2, n3, "[\\:\\@\\/\\?]", c3), "g"), NOT_FRAGMENT: new RegExp(r3("[^\\%]", u2, n3, "[\\:\\@\\/\\?]"), "g"), ESCAPE: new RegExp(r3("[^]", u2, n3), "g"), UNRESERVED: new RegExp(u2, "g"), OTHER_CHARS: new RegExp(r3("[^\\%]", u2, l2), "g"), PCT_ENCODED: new RegExp(i3, "g"), IPV4ADDRESS: new RegExp("^(" + d2 + ")$"), IPV6ADDRESS: new RegExp("^\\[?(" + _2 + ")" + t3(t3("\\%25|\\%(?!" + o3 + "{2})") + "(" + F2 + ")") + "?\\]?$") };
        }
        var i2 = o2(false), n2 = o2(true), l = function(e5, r4) {
          if (Array.isArray(e5))
            return e5;
          if (Symbol.iterator in Object(e5))
            return function(e6, r5) {
              var t4 = [], a5 = true, s3 = false, o3 = void 0;
              try {
                for (var i3, n3 = e6[Symbol.iterator](); !(a5 = (i3 = n3.next()).done) && (t4.push(i3.value), !r5 || t4.length !== r5); a5 = true)
                  ;
              } catch (e7) {
                s3 = true, o3 = e7;
              } finally {
                try {
                  !a5 && n3.return && n3.return();
                } finally {
                  if (s3)
                    throw o3;
                }
              }
              return t4;
            }(e5, r4);
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }, c2 = 2147483647, u = /^xn--/, h = /[^\0-\x7E]/, d = /[\x2E\u3002\uFF0E\uFF61]/g, p = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, f = Math.floor, m2 = String.fromCharCode;
        function v(e5) {
          throw new RangeError(p[e5]);
        }
        function y(e5, r4) {
          var t4 = e5.split("@"), a5 = "";
          return 1 < t4.length && (a5 = t4[0] + "@", e5 = t4[1]), a5 + function(e6, r5) {
            for (var t5 = [], a6 = e6.length; a6--; )
              t5[a6] = r5(e6[a6]);
            return t5;
          }((e5 = e5.replace(d, ".")).split("."), r4).join(".");
        }
        function g(e5) {
          for (var r4 = [], t4 = 0, a5 = e5.length; t4 < a5; ) {
            var s3, o3 = e5.charCodeAt(t4++);
            55296 <= o3 && o3 <= 56319 && t4 < a5 ? (64512 & (s3 = e5.charCodeAt(t4++))) == 56320 ? r4.push(((1023 & o3) << 10) + (1023 & s3) + 65536) : (r4.push(o3), t4--) : r4.push(o3);
          }
          return r4;
        }
        function P(e5, r4) {
          return e5 + 22 + 75 * (e5 < 26) - ((r4 != 0) << 5);
        }
        function E(e5, r4, t4) {
          var a5 = 0;
          for (e5 = t4 ? f(e5 / 700) : e5 >> 1, e5 += f(e5 / r4); 455 < e5; a5 += 36)
            e5 = f(e5 / 35);
          return f(a5 + 36 * e5 / (e5 + 38));
        }
        function w(e5) {
          var r4 = [], t4 = e5.length, a5 = 0, s3 = 128, o3 = 72, i3 = e5.lastIndexOf("-");
          i3 < 0 && (i3 = 0);
          for (var n3 = 0; n3 < i3; ++n3)
            128 <= e5.charCodeAt(n3) && v("not-basic"), r4.push(e5.charCodeAt(n3));
          for (var l2, u2 = 0 < i3 ? i3 + 1 : 0; u2 < t4; ) {
            for (var h2 = a5, d2 = 1, p2 = 36; ; p2 += 36) {
              t4 <= u2 && v("invalid-input");
              var m3 = (l2 = e5.charCodeAt(u2++)) - 48 < 10 ? l2 - 22 : l2 - 65 < 26 ? l2 - 65 : l2 - 97 < 26 ? l2 - 97 : 36;
              (36 <= m3 || m3 > f((c2 - a5) / d2)) && v("overflow"), a5 += m3 * d2;
              var y2 = p2 <= o3 ? 1 : o3 + 26 <= p2 ? 26 : p2 - o3;
              if (m3 < y2)
                break;
              var g2 = 36 - y2;
              d2 > f(c2 / g2) && v("overflow"), d2 *= g2;
            }
            var P2 = r4.length + 1;
            o3 = E(a5 - h2, P2, h2 == 0), f(a5 / P2) > c2 - s3 && v("overflow"), s3 += f(a5 / P2), a5 %= P2, r4.splice(a5++, 0, s3);
          }
          return String.fromCodePoint.apply(String, r4);
        }
        function b(e5) {
          var r4 = [], t4 = (e5 = g(e5)).length, a5 = 128, s3 = 0, o3 = 72, i3 = true, n3 = false, l2 = void 0;
          try {
            for (var u2, h2 = e5[Symbol.iterator](); !(i3 = (u2 = h2.next()).done); i3 = true) {
              var d2 = u2.value;
              d2 < 128 && r4.push(m2(d2));
            }
          } catch (e6) {
            n3 = true, l2 = e6;
          } finally {
            try {
              !i3 && h2.return && h2.return();
            } finally {
              if (n3)
                throw l2;
            }
          }
          var p2 = r4.length, y2 = p2;
          for (p2 && r4.push("-"); y2 < t4; ) {
            var w2 = c2, b2 = true, S2 = false, _2 = void 0;
            try {
              for (var F2, x2 = e5[Symbol.iterator](); !(b2 = (F2 = x2.next()).done); b2 = true) {
                var R2 = F2.value;
                a5 <= R2 && R2 < w2 && (w2 = R2);
              }
            } catch (e6) {
              S2 = true, _2 = e6;
            } finally {
              try {
                !b2 && x2.return && x2.return();
              } finally {
                if (S2)
                  throw _2;
              }
            }
            var $2 = y2 + 1;
            w2 - a5 > f((c2 - s3) / $2) && v("overflow"), s3 += (w2 - a5) * $2, a5 = w2;
            var j2 = true, D2 = false, O2 = void 0;
            try {
              for (var I2, A2 = e5[Symbol.iterator](); !(j2 = (I2 = A2.next()).done); j2 = true) {
                var k2 = I2.value;
                if (k2 < a5 && ++s3 > c2 && v("overflow"), k2 == a5) {
                  for (var C2 = s3, L2 = 36; ; L2 += 36) {
                    var N2 = L2 <= o3 ? 1 : o3 + 26 <= L2 ? 26 : L2 - o3;
                    if (C2 < N2)
                      break;
                    var z2 = C2 - N2, T2 = 36 - N2;
                    r4.push(m2(P(N2 + z2 % T2, 0))), C2 = f(z2 / T2);
                  }
                  r4.push(m2(P(C2, 0))), o3 = E(s3, $2, y2 == p2), s3 = 0, ++y2;
                }
              }
            } catch (e6) {
              D2 = true, O2 = e6;
            } finally {
              try {
                !j2 && A2.return && A2.return();
              } finally {
                if (D2)
                  throw O2;
              }
            }
            ++s3, ++a5;
          }
          return r4.join("");
        }
        var S = { version: "2.1.0", ucs2: { decode: g, encode: function(e5) {
          return String.fromCodePoint.apply(String, function(e6) {
            if (Array.isArray(e6)) {
              for (var r4 = 0, t4 = Array(e6.length); r4 < e6.length; r4++)
                t4[r4] = e6[r4];
              return t4;
            }
            return Array.from(e6);
          }(e5));
        } }, decode: w, encode: b, toASCII: function(e5) {
          return y(e5, function(e6) {
            return h.test(e6) ? "xn--" + b(e6) : e6;
          });
        }, toUnicode: function(e5) {
          return y(e5, function(e6) {
            return u.test(e6) ? w(e6.slice(4).toLowerCase()) : e6;
          });
        } }, _ = {};
        function F(e5) {
          var r4 = e5.charCodeAt(0);
          return r4 < 16 ? "%0" + r4.toString(16).toUpperCase() : r4 < 128 ? "%" + r4.toString(16).toUpperCase() : r4 < 2048 ? "%" + (r4 >> 6 | 192).toString(16).toUpperCase() + "%" + (63 & r4 | 128).toString(16).toUpperCase() : "%" + (r4 >> 12 | 224).toString(16).toUpperCase() + "%" + (r4 >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (63 & r4 | 128).toString(16).toUpperCase();
        }
        function x(e5) {
          for (var r4 = "", t4 = 0, a5 = e5.length; t4 < a5; ) {
            var s3, o3, i3, n3 = parseInt(e5.substr(t4 + 1, 2), 16);
            n3 < 128 ? (r4 += String.fromCharCode(n3), t4 += 3) : 194 <= n3 && n3 < 224 ? (6 <= a5 - t4 ? (s3 = parseInt(e5.substr(t4 + 4, 2), 16), r4 += String.fromCharCode((31 & n3) << 6 | 63 & s3)) : r4 += e5.substr(t4, 6), t4 += 6) : 224 <= n3 ? (9 <= a5 - t4 ? (o3 = parseInt(e5.substr(t4 + 4, 2), 16), i3 = parseInt(e5.substr(t4 + 7, 2), 16), r4 += String.fromCharCode((15 & n3) << 12 | (63 & o3) << 6 | 63 & i3)) : r4 += e5.substr(t4, 9), t4 += 9) : (r4 += e5.substr(t4, 3), t4 += 3);
          }
          return r4;
        }
        function R(e5, r4) {
          function t4(e6) {
            var t5 = x(e6);
            return t5.match(r4.UNRESERVED) ? t5 : e6;
          }
          return e5.scheme && (e5.scheme = String(e5.scheme).replace(r4.PCT_ENCODED, t4).toLowerCase().replace(r4.NOT_SCHEME, "")), e5.userinfo !== void 0 && (e5.userinfo = String(e5.userinfo).replace(r4.PCT_ENCODED, t4).replace(r4.NOT_USERINFO, F).replace(r4.PCT_ENCODED, s2)), e5.host !== void 0 && (e5.host = String(e5.host).replace(r4.PCT_ENCODED, t4).toLowerCase().replace(r4.NOT_HOST, F).replace(r4.PCT_ENCODED, s2)), e5.path !== void 0 && (e5.path = String(e5.path).replace(r4.PCT_ENCODED, t4).replace(e5.scheme ? r4.NOT_PATH : r4.NOT_PATH_NOSCHEME, F).replace(r4.PCT_ENCODED, s2)), e5.query !== void 0 && (e5.query = String(e5.query).replace(r4.PCT_ENCODED, t4).replace(r4.NOT_QUERY, F).replace(r4.PCT_ENCODED, s2)), e5.fragment !== void 0 && (e5.fragment = String(e5.fragment).replace(r4.PCT_ENCODED, t4).replace(r4.NOT_FRAGMENT, F).replace(r4.PCT_ENCODED, s2)), e5;
        }
        function $(e5) {
          return e5.replace(/^0*(.*)/, "$1") || "0";
        }
        function j(e5, r4) {
          var t4 = e5.match(r4.IPV4ADDRESS) || [], a5 = l(t4, 2)[1];
          return a5 ? a5.split(".").map($).join(".") : e5;
        }
        function D(e5, r4) {
          var t4 = e5.match(r4.IPV6ADDRESS) || [], a5 = l(t4, 3), s3 = a5[1], o3 = a5[2];
          if (s3) {
            for (var i3 = s3.toLowerCase().split("::").reverse(), n3 = l(i3, 2), c3 = n3[0], u2 = n3[1], h2 = u2 ? u2.split(":").map($) : [], d2 = c3.split(":").map($), p2 = r4.IPV4ADDRESS.test(d2[d2.length - 1]), f2 = p2 ? 7 : 8, m3 = d2.length - f2, v2 = Array(f2), y2 = 0; y2 < f2; ++y2)
              v2[y2] = h2[y2] || d2[m3 + y2] || "";
            p2 && (v2[f2 - 1] = j(v2[f2 - 1], r4));
            var g2, P2, E2 = v2.reduce(function(e6, r5, t5) {
              var a6;
              return r5 && r5 !== "0" || ((a6 = e6[e6.length - 1]) && a6.index + a6.length === t5 ? a6.length++ : e6.push({ index: t5, length: 1 })), e6;
            }, []).sort(function(e6, r5) {
              return r5.length - e6.length;
            })[0], w2 = void 0;
            return w2 = E2 && 1 < E2.length ? (g2 = v2.slice(0, E2.index), P2 = v2.slice(E2.index + E2.length), g2.join(":") + "::" + P2.join(":")) : v2.join(":"), o3 && (w2 += "%" + o3), w2;
          }
          return e5;
        }
        var O = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i, I = "".match(/(){0}/)[1] === void 0;
        function A(e5) {
          var r4 = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {}, t4 = {}, a5 = r4.iri !== false ? n2 : i2;
          r4.reference === "suffix" && (e5 = (r4.scheme ? r4.scheme + ":" : "") + "//" + e5);
          var s3 = e5.match(O);
          if (s3) {
            I ? (t4.scheme = s3[1], t4.userinfo = s3[3], t4.host = s3[4], t4.port = parseInt(s3[5], 10), t4.path = s3[6] || "", t4.query = s3[7], t4.fragment = s3[8], isNaN(t4.port) && (t4.port = s3[5])) : (t4.scheme = s3[1] || void 0, t4.userinfo = e5.indexOf("@") !== -1 ? s3[3] : void 0, t4.host = e5.indexOf("//") !== -1 ? s3[4] : void 0, t4.port = parseInt(s3[5], 10), t4.path = s3[6] || "", t4.query = e5.indexOf("?") !== -1 ? s3[7] : void 0, t4.fragment = e5.indexOf("#") !== -1 ? s3[8] : void 0, isNaN(t4.port) && (t4.port = e5.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? s3[4] : void 0)), t4.host && (t4.host = D(j(t4.host, a5), a5)), t4.scheme !== void 0 || t4.userinfo !== void 0 || t4.host !== void 0 || t4.port !== void 0 || t4.path || t4.query !== void 0 ? t4.scheme === void 0 ? t4.reference = "relative" : t4.fragment === void 0 ? t4.reference = "absolute" : t4.reference = "uri" : t4.reference = "same-document", r4.reference && r4.reference !== "suffix" && r4.reference !== t4.reference && (t4.error = t4.error || "URI is not a " + r4.reference + " reference.");
            var o3 = _[(r4.scheme || t4.scheme || "").toLowerCase()];
            if (r4.unicodeSupport || o3 && o3.unicodeSupport)
              R(t4, a5);
            else {
              if (t4.host && (r4.domainHost || o3 && o3.domainHost))
                try {
                  t4.host = S.toASCII(t4.host.replace(a5.PCT_ENCODED, x).toLowerCase());
                } catch (e6) {
                  t4.error = t4.error || "Host's domain name can not be converted to ASCII via punycode: " + e6;
                }
              R(t4, i2);
            }
            o3 && o3.parse && o3.parse(t4, r4);
          } else
            t4.error = t4.error || "URI can not be parsed.";
          return t4;
        }
        var k = /^\.\.?\//, C = /^\/\.(\/|$)/, L = /^\/\.\.(\/|$)/, N = /^\/?(?:.|\n)*?(?=\/|$)/;
        function z(e5) {
          for (var r4 = []; e5.length; )
            if (e5.match(k))
              e5 = e5.replace(k, "");
            else if (e5.match(C))
              e5 = e5.replace(C, "/");
            else if (e5.match(L))
              e5 = e5.replace(L, "/"), r4.pop();
            else if (e5 === "." || e5 === "..")
              e5 = "";
            else {
              var t4 = e5.match(N);
              if (!t4)
                throw new Error("Unexpected dot segment condition");
              var a5 = t4[0];
              e5 = e5.slice(a5.length), r4.push(a5);
            }
          return r4.join("");
        }
        function T(e5) {
          var r4 = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {}, t4 = r4.iri ? n2 : i2, a5 = [], s3 = _[(r4.scheme || e5.scheme || "").toLowerCase()];
          if (s3 && s3.serialize && s3.serialize(e5, r4), e5.host && !t4.IPV6ADDRESS.test(e5.host) && (r4.domainHost || s3 && s3.domainHost))
            try {
              e5.host = r4.iri ? S.toUnicode(e5.host) : S.toASCII(e5.host.replace(t4.PCT_ENCODED, x).toLowerCase());
            } catch (t5) {
              e5.error = e5.error || "Host's domain name can not be converted to " + (r4.iri ? "Unicode" : "ASCII") + " via punycode: " + t5;
            }
          R(e5, t4), r4.reference !== "suffix" && e5.scheme && (a5.push(e5.scheme), a5.push(":"));
          var o3, l2, c3, u2, h2 = (o3 = e5, l2 = r4.iri !== false ? n2 : i2, c3 = [], o3.userinfo !== void 0 && (c3.push(o3.userinfo), c3.push("@")), o3.host !== void 0 && c3.push(D(j(String(o3.host), l2), l2).replace(l2.IPV6ADDRESS, function(e6, r5, t5) {
            return "[" + r5 + (t5 ? "%25" + t5 : "") + "]";
          })), typeof o3.port == "number" && (c3.push(":"), c3.push(o3.port.toString(10))), c3.length ? c3.join("") : void 0);
          return h2 !== void 0 && (r4.reference !== "suffix" && a5.push("//"), a5.push(h2), e5.path && e5.path.charAt(0) !== "/" && a5.push("/")), e5.path !== void 0 && (u2 = e5.path, r4.absolutePath || s3 && s3.absolutePath || (u2 = z(u2)), h2 === void 0 && (u2 = u2.replace(/^\/\//, "/%2F")), a5.push(u2)), e5.query !== void 0 && (a5.push("?"), a5.push(e5.query)), e5.fragment !== void 0 && (a5.push("#"), a5.push(e5.fragment)), a5.join("");
        }
        function q(e5, r4) {
          var t4 = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : {}, a5 = {};
          return arguments[3] || (e5 = A(T(e5, t4), t4), r4 = A(T(r4, t4), t4)), !(t4 = t4 || {}).tolerant && r4.scheme ? (a5.scheme = r4.scheme, a5.userinfo = r4.userinfo, a5.host = r4.host, a5.port = r4.port, a5.path = z(r4.path || ""), a5.query = r4.query) : (r4.userinfo !== void 0 || r4.host !== void 0 || r4.port !== void 0 ? (a5.userinfo = r4.userinfo, a5.host = r4.host, a5.port = r4.port, a5.path = z(r4.path || ""), a5.query = r4.query) : (r4.path ? (r4.path.charAt(0) === "/" ? a5.path = z(r4.path) : (e5.userinfo === void 0 && e5.host === void 0 && e5.port === void 0 || e5.path ? e5.path ? a5.path = e5.path.slice(0, e5.path.lastIndexOf("/") + 1) + r4.path : a5.path = r4.path : a5.path = "/" + r4.path, a5.path = z(a5.path)), a5.query = r4.query) : (a5.path = e5.path, r4.query !== void 0 ? a5.query = r4.query : a5.query = e5.query), a5.userinfo = e5.userinfo, a5.host = e5.host, a5.port = e5.port), a5.scheme = e5.scheme), a5.fragment = r4.fragment, a5;
        }
        function Q(e5, r4) {
          return e5 && e5.toString().replace(r4 && r4.iri ? n2.PCT_ENCODED : i2.PCT_ENCODED, x);
        }
        var V = { scheme: "http", domainHost: true, parse: function(e5) {
          return e5.host || (e5.error = e5.error || "HTTP URIs must have a host."), e5;
        }, serialize: function(e5) {
          return e5.port !== (String(e5.scheme).toLowerCase() !== "https" ? 80 : 443) && e5.port !== "" || (e5.port = void 0), e5.path || (e5.path = "/"), e5;
        } }, U = { scheme: "https", domainHost: V.domainHost, parse: V.parse, serialize: V.serialize }, H = {}, K = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]", M = r3("[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", '[\\"\\\\]'), B = new RegExp(K, "g"), J = new RegExp("(?:(?:%[EFef][0-9A-Fa-f]%[0-9A-Fa-f][0-9A-Fa-f]%[0-9A-Fa-f][0-9A-Fa-f])|(?:%[89A-Fa-f][0-9A-Fa-f]%[0-9A-Fa-f][0-9A-Fa-f])|(?:%[0-9A-Fa-f][0-9A-Fa-f]))", "g"), Z = new RegExp(r3("[^]", "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", "[\\.]", '[\\"]', M), "g"), G = new RegExp(r3("[^]", K, "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]"), "g"), Y = G;
        function W(e5) {
          var r4 = x(e5);
          return r4.match(B) ? r4 : e5;
        }
        var X = { scheme: "mailto", parse: function(e5, r4) {
          var t4 = e5, a5 = t4.to = t4.path ? t4.path.split(",") : [];
          if (t4.path = void 0, t4.query) {
            for (var s3 = false, o3 = {}, i3 = t4.query.split("&"), n3 = 0, l2 = i3.length; n3 < l2; ++n3) {
              var c3 = i3[n3].split("=");
              switch (c3[0]) {
                case "to":
                  for (var u2 = c3[1].split(","), h2 = 0, d2 = u2.length; h2 < d2; ++h2)
                    a5.push(u2[h2]);
                  break;
                case "subject":
                  t4.subject = Q(c3[1], r4);
                  break;
                case "body":
                  t4.body = Q(c3[1], r4);
                  break;
                default:
                  s3 = true, o3[Q(c3[0], r4)] = Q(c3[1], r4);
              }
            }
            s3 && (t4.headers = o3);
          }
          t4.query = void 0;
          for (var p2 = 0, f2 = a5.length; p2 < f2; ++p2) {
            var m3 = a5[p2].split("@");
            if (m3[0] = Q(m3[0]), r4.unicodeSupport)
              m3[1] = Q(m3[1], r4).toLowerCase();
            else
              try {
                m3[1] = S.toASCII(Q(m3[1], r4).toLowerCase());
              } catch (e6) {
                t4.error = t4.error || "Email address's domain name can not be converted to ASCII via punycode: " + e6;
              }
            a5[p2] = m3.join("@");
          }
          return t4;
        }, serialize: function(e5, r4) {
          var t4, a5 = e5, o3 = (t4 = e5.to) != null ? t4 instanceof Array ? t4 : typeof t4.length != "number" || t4.split || t4.setInterval || t4.call ? [t4] : Array.prototype.slice.call(t4) : [];
          if (o3) {
            for (var i3 = 0, n3 = o3.length; i3 < n3; ++i3) {
              var l2 = String(o3[i3]), c3 = l2.lastIndexOf("@"), u2 = l2.slice(0, c3).replace(J, W).replace(J, s2).replace(Z, F), h2 = l2.slice(c3 + 1);
              try {
                h2 = r4.iri ? S.toUnicode(h2) : S.toASCII(Q(h2, r4).toLowerCase());
              } catch (e6) {
                a5.error = a5.error || "Email address's domain name can not be converted to " + (r4.iri ? "Unicode" : "ASCII") + " via punycode: " + e6;
              }
              o3[i3] = u2 + "@" + h2;
            }
            a5.path = o3.join(",");
          }
          var d2 = e5.headers = e5.headers || {};
          e5.subject && (d2.subject = e5.subject), e5.body && (d2.body = e5.body);
          var p2 = [];
          for (var f2 in d2)
            d2[f2] !== H[f2] && p2.push(f2.replace(J, W).replace(J, s2).replace(G, F) + "=" + d2[f2].replace(J, W).replace(J, s2).replace(Y, F));
          return p2.length && (a5.query = p2.join("&")), a5;
        } }, ee = /^([^\:]+)\:(.*)/, re = { scheme: "urn", parse: function(e5, r4) {
          var t4, a5, s3, o3, i3, n3 = e5.path && e5.path.match(ee), l2 = e5;
          return n3 ? (t4 = r4.scheme || l2.scheme || "urn", a5 = n3[1].toLowerCase(), s3 = n3[2], o3 = t4 + ":" + (r4.nid || a5), i3 = _[o3], l2.nid = a5, l2.nss = s3, l2.path = void 0, i3 && (l2 = i3.parse(l2, r4))) : l2.error = l2.error || "URN can not be parsed.", l2;
        }, serialize: function(e5, r4) {
          var t4 = r4.scheme || e5.scheme || "urn", a5 = e5.nid, s3 = t4 + ":" + (r4.nid || a5), o3 = _[s3];
          o3 && (e5 = o3.serialize(e5, r4));
          var i3 = e5, n3 = e5.nss;
          return i3.path = (a5 || r4.nid) + ":" + n3, i3;
        } }, te = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, ae = { scheme: "urn:uuid", parse: function(e5, r4) {
          var t4 = e5;
          return t4.uuid = t4.nss, t4.nss = void 0, r4.tolerant || t4.uuid && t4.uuid.match(te) || (t4.error = t4.error || "UUID is not valid."), t4;
        }, serialize: function(e5) {
          var r4 = e5;
          return r4.nss = (e5.uuid || "").toLowerCase(), r4;
        } };
        _[V.scheme] = V, _[U.scheme] = U, _[X.scheme] = X, _[re.scheme] = re, _[ae.scheme] = ae, e4.SCHEMES = _, e4.pctEncChar = F, e4.pctDecChars = x, e4.parse = A, e4.removeDotSegments = z, e4.serialize = T, e4.resolveComponents = q, e4.resolve = function(e5, r4, t4) {
          var a5 = function(e6, r5) {
            var t5 = { scheme: "null" };
            if (r5)
              for (var a6 in r5)
                t5[a6] = r5[a6];
            return t5;
          }(0, t4);
          return T(q(A(e5, a5), A(r4, a5), a5, true), a5);
        }, e4.normalize = function(e5, r4) {
          return typeof e5 == "string" ? e5 = T(A(e5, r4), r4) : a4(e5) === "object" && (e5 = A(T(e5, r4), r4)), e5;
        }, e4.equal = function(e5, r4, t4) {
          return typeof e5 == "string" ? e5 = T(A(e5, t4), t4) : a4(e5) === "object" && (e5 = T(e5, t4)), typeof r4 == "string" ? r4 = T(A(r4, t4), t4) : a4(r4) === "object" && (r4 = T(r4, t4)), e5 === r4;
        }, e4.escapeComponent = function(e5, r4) {
          return e5 && e5.toString().replace(r4 && r4.iri ? n2.ESCAPE : i2.ESCAPE, F);
        }, e4.unescapeComponent = Q, Object.defineProperty(e4, "__esModule", { value: true });
      }(typeof t2 == "object" && r2 !== void 0 ? t2 : a3.URI = a3.URI || {});
    }, {}], ajv: [function(e3, r2, t2) {
      var a3 = e3("./compile"), s2 = e3("./compile/resolve"), o2 = e3("./cache"), i2 = e3("./compile/schema_obj"), n2 = e3("fast-json-stable-stringify"), l = e3("./compile/formats"), c2 = e3("./compile/rules"), u = e3("./data"), h = e3("./compile/util");
      (r2.exports = y).prototype.validate = function(e4, r3) {
        var t3;
        if (typeof e4 == "string") {
          if (!(t3 = this.getSchema(e4)))
            throw new Error('no schema with key or ref "' + e4 + '"');
        } else {
          var a4 = this._addSchema(e4);
          t3 = a4.validate || this._compile(a4);
        }
        var s3 = t3(r3);
        return t3.$async !== true && (this.errors = t3.errors), s3;
      }, y.prototype.compile = function(e4, r3) {
        var t3 = this._addSchema(e4, void 0, r3);
        return t3.validate || this._compile(t3);
      }, y.prototype.addSchema = function(e4, r3, t3, a4) {
        if (Array.isArray(e4)) {
          for (var o3 = 0; o3 < e4.length; o3++)
            this.addSchema(e4[o3], void 0, t3, a4);
          return this;
        }
        var i3 = this._getId(e4);
        if (i3 !== void 0 && typeof i3 != "string")
          throw new Error("schema id must be string");
        return S(this, r3 = s2.normalizeId(r3 || i3)), this._schemas[r3] = this._addSchema(e4, t3, a4, true), this;
      }, y.prototype.addMetaSchema = function(e4, r3, t3) {
        return this.addSchema(e4, r3, t3, true), this;
      }, y.prototype.validateSchema = function(e4, r3) {
        var t3 = e4.$schema;
        if (t3 !== void 0 && typeof t3 != "string")
          throw new Error("$schema must be a string");
        if (!(t3 = t3 || this._opts.defaultMeta || function(e5) {
          var r4 = e5._opts.meta;
          return e5._opts.defaultMeta = typeof r4 == "object" ? e5._getId(r4) || r4 : e5.getSchema(f) ? f : void 0, e5._opts.defaultMeta;
        }(this)))
          return this.logger.warn("meta-schema not available"), !(this.errors = null);
        var a4 = this.validate(t3, e4);
        if (!a4 && r3) {
          var s3 = "schema is invalid: " + this.errorsText();
          if (this._opts.validateSchema != "log")
            throw new Error(s3);
          this.logger.error(s3);
        }
        return a4;
      }, y.prototype.getSchema = function(e4) {
        var r3 = g(this, e4);
        switch (typeof r3) {
          case "object":
            return r3.validate || this._compile(r3);
          case "string":
            return this.getSchema(r3);
          case "undefined":
            return function(e5, r4) {
              var t3 = s2.schema.call(e5, { schema: {} }, r4);
              if (t3) {
                var o3 = t3.schema, n3 = t3.root, l2 = t3.baseId, c3 = a3.call(e5, o3, n3, void 0, l2);
                return e5._fragments[r4] = new i2({ ref: r4, fragment: true, schema: o3, root: n3, baseId: l2, validate: c3 }), c3;
              }
            }(this, e4);
        }
      }, y.prototype.removeSchema = function(e4) {
        if (e4 instanceof RegExp)
          return P(this, this._schemas, e4), P(this, this._refs, e4), this;
        switch (typeof e4) {
          case "undefined":
            return P(this, this._schemas), P(this, this._refs), this._cache.clear(), this;
          case "string":
            var r3 = g(this, e4);
            return r3 && this._cache.del(r3.cacheKey), delete this._schemas[e4], delete this._refs[e4], this;
          case "object":
            var t3 = this._opts.serialize, a4 = t3 ? t3(e4) : e4;
            this._cache.del(a4);
            var o3 = this._getId(e4);
            o3 && (o3 = s2.normalizeId(o3), delete this._schemas[o3], delete this._refs[o3]);
        }
        return this;
      }, y.prototype.addFormat = function(e4, r3) {
        return typeof r3 == "string" && (r3 = new RegExp(r3)), this._formats[e4] = r3, this;
      }, y.prototype.errorsText = function(e4, r3) {
        if (!(e4 = e4 || this.errors))
          return "No errors";
        for (var t3 = (r3 = r3 || {}).separator === void 0 ? ", " : r3.separator, a4 = r3.dataVar === void 0 ? "data" : r3.dataVar, s3 = "", o3 = 0; o3 < e4.length; o3++) {
          var i3 = e4[o3];
          i3 && (s3 += a4 + i3.dataPath + " " + i3.message + t3);
        }
        return s3.slice(0, -t3.length);
      }, y.prototype._addSchema = function(e4, r3, t3, a4) {
        if (typeof e4 != "object" && typeof e4 != "boolean")
          throw new Error("schema should be object or boolean");
        var o3 = this._opts.serialize, n3 = o3 ? o3(e4) : e4, l2 = this._cache.get(n3);
        if (l2)
          return l2;
        a4 = a4 || this._opts.addUsedSchema !== false;
        var c3 = s2.normalizeId(this._getId(e4));
        c3 && a4 && S(this, c3);
        var u2, h2 = this._opts.validateSchema !== false && !r3;
        h2 && !(u2 = c3 && c3 == s2.normalizeId(e4.$schema)) && this.validateSchema(e4, true);
        var d2 = s2.ids.call(this, e4), p2 = new i2({ id: c3, schema: e4, localRefs: d2, cacheKey: n3, meta: t3 });
        return c3[0] != "#" && a4 && (this._refs[c3] = p2), this._cache.put(n3, p2), h2 && u2 && this.validateSchema(e4, true), p2;
      }, y.prototype._compile = function(e4, r3) {
        if (e4.compiling)
          return (e4.validate = o3).schema = e4.schema, o3.errors = null, o3.root = r3 || o3, e4.schema.$async === true && (o3.$async = true), o3;
        var t3, s3;
        e4.compiling = true, e4.meta && (t3 = this._opts, this._opts = this._metaOpts);
        try {
          s3 = a3.call(this, e4.schema, r3, e4.localRefs);
        } catch (r4) {
          throw delete e4.validate, r4;
        } finally {
          e4.compiling = false, e4.meta && (this._opts = t3);
        }
        return e4.validate = s3, e4.refs = s3.refs, e4.refVal = s3.refVal, e4.root = s3.root, s3;
        function o3() {
          var r4 = e4.validate, t4 = r4.apply(this, arguments);
          return o3.errors = r4.errors, t4;
        }
      }, y.prototype.compileAsync = e3("./compile/async");
      var d = e3("./keyword");
      y.prototype.addKeyword = d.add, y.prototype.getKeyword = d.get, y.prototype.removeKeyword = d.remove, y.prototype.validateKeyword = d.validate;
      var p = e3("./compile/error_classes");
      y.ValidationError = p.Validation, y.MissingRefError = p.MissingRef, y.$dataMetaSchema = u;
      var f = "http://json-schema.org/draft-07/schema", m2 = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"], v = ["/properties"];
      function y(r3) {
        if (!(this instanceof y))
          return new y(r3);
        r3 = this._opts = h.copy(r3) || {}, function(e4) {
          var r4 = e4._opts.logger;
          if (r4 === false)
            e4.logger = { log: _, warn: _, error: _ };
          else {
            if (r4 === void 0 && (r4 = console), !(typeof r4 == "object" && r4.log && r4.warn && r4.error))
              throw new Error("logger must implement log, warn and error methods");
            e4.logger = r4;
          }
        }(this), this._schemas = {}, this._refs = {}, this._fragments = {}, this._formats = l(r3.format), this._cache = r3.cache || new o2(), this._loadingSchemas = {}, this._compilations = [], this.RULES = c2(), this._getId = function(e4) {
          switch (e4.schemaId) {
            case "auto":
              return b;
            case "id":
              return E;
            default:
              return w;
          }
        }(r3), r3.loopRequired = r3.loopRequired || 1 / 0, r3.errorDataPath == "property" && (r3._errorDataPathProperty = true), r3.serialize === void 0 && (r3.serialize = n2), this._metaOpts = function(e4) {
          for (var r4 = h.copy(e4._opts), t3 = 0; t3 < m2.length; t3++)
            delete r4[m2[t3]];
          return r4;
        }(this), r3.formats && function(e4) {
          for (var r4 in e4._opts.formats) {
            var t3 = e4._opts.formats[r4];
            e4.addFormat(r4, t3);
          }
        }(this), r3.keywords && function(e4) {
          for (var r4 in e4._opts.keywords) {
            var t3 = e4._opts.keywords[r4];
            e4.addKeyword(r4, t3);
          }
        }(this), function(r4) {
          var t3;
          if (r4._opts.$data && (t3 = e3("./refs/data.json"), r4.addMetaSchema(t3, t3.$id, true)), r4._opts.meta !== false) {
            var a4 = e3("./refs/json-schema-draft-07.json");
            r4._opts.$data && (a4 = u(a4, v)), r4.addMetaSchema(a4, f, true), r4._refs["http://json-schema.org/schema"] = f;
          }
        }(this), typeof r3.meta == "object" && this.addMetaSchema(r3.meta), r3.nullable && this.addKeyword("nullable", { metaSchema: { type: "boolean" } }), function(e4) {
          var r4 = e4._opts.schemas;
          if (r4)
            if (Array.isArray(r4))
              e4.addSchema(r4);
            else
              for (var t3 in r4)
                e4.addSchema(r4[t3], t3);
        }(this);
      }
      function g(e4, r3) {
        return r3 = s2.normalizeId(r3), e4._schemas[r3] || e4._refs[r3] || e4._fragments[r3];
      }
      function P(e4, r3, t3) {
        for (var a4 in r3) {
          var s3 = r3[a4];
          s3.meta || t3 && !t3.test(a4) || (e4._cache.del(s3.cacheKey), delete r3[a4]);
        }
      }
      function E(e4) {
        return e4.$id && this.logger.warn("schema $id ignored", e4.$id), e4.id;
      }
      function w(e4) {
        return e4.id && this.logger.warn("schema id ignored", e4.id), e4.$id;
      }
      function b(e4) {
        if (e4.$id && e4.id && e4.$id != e4.id)
          throw new Error("schema $id is different from id");
        return e4.$id || e4.id;
      }
      function S(e4, r3) {
        if (e4._schemas[r3] || e4._refs[r3])
          throw new Error('schema with key or id "' + r3 + '" already exists');
      }
      function _() {
      }
    }, { "./cache": 1, "./compile": 5, "./compile/async": 2, "./compile/error_classes": 3, "./compile/formats": 4, "./compile/resolve": 6, "./compile/rules": 7, "./compile/schema_obj": 8, "./compile/util": 10, "./data": 11, "./keyword": 39, "./refs/data.json": 40, "./refs/json-schema-draft-07.json": 41, "fast-json-stable-stringify": 43 }] }, {}, [])("ajv");
  }, e2.exports = a2();
}));
const e = { "applicationProperties_schema.json": { title: "applicationProperties", type: "object", description: "Configuration of application and UI elements.", properties: { viewing: { type: "object", $ref: "#/definitions/viewing_schema.json" } }, additionalProperties: false }, "baseMap_schema.json": { title: "baseMap", type: "object", description: "The basemap provides geographic context to the map and scene.", properties: { baseMapLayers: { type: "array", description: "An array of baseMapLayer objects defining the basemaps used in the web scene.", items: { type: "object", $ref: "#/definitions/baseMapLayer_schema.json" }, uniqueItems: true }, elevationLayers: { type: "array", description: '<em>Deprecated, use `ground.layers` instead <a href="#elevationLayers"><sup>1</sup></a>.</em> An array of elevationLayer objects defining the basemaps used in the web scene.', items: { type: "object", $ref: "#/definitions/elevationLayers_schema.json" }, uniqueItems: true }, id: { type: "string", description: "A unique identifying string for the basemap." }, title: { type: "string", description: "Required string title for the basemap that can be used in a table of contents." } }, required: ["baseMapLayers", "title"], additionalProperties: false }, "clippingArea_schema.json": { title: "clippingArea", type: "object", description: "Defines area to be clipped for display.", properties: { clip: { type: "boolean", description: "enable / disable clipping" }, geometry: { type: "object", description: "envelope of clip area", $ref: "#/definitions/extent_schema.json" } } }, "ground_schema.json": { title: "Ground", type: "object", description: "Ground defines the main surface of the web scene, based on elevation layers.", properties: { layers: { type: "array", description: "An array of elevationLayer objects defining the elevation of the ground in the web scene.", items: { type: "object", $ref: "#/definitions/elevationLayers_schema.json" }, uniqueItems: true }, navigationConstraint: { description: "Object determining whether the camera is constrained to navigate only above, or also under the ground surface. If not specified, navigation is constrained to above ground.", $ref: "#/definitions/navigationConstraint_schema.json" }, surfaceColor: { description: "Defines the color of the ground surface, displayed underneath the basemap. If no color, the default grid is shown.", $ref: "#/definitions/color_schema.json" }, transparency: { type: "integer", description: "The transparency of the ground surface. It is used for seeing through the ground, therefore this property also changes the transparency of the basemap. Draped operational layers are not affected by this property. The value has to lie between `100` (full transparency) and `0` (full opacity).", minimum: 0, maximum: 100 } }, required: ["layers"], additionalProperties: false }, "heightModelInfo_schema.json": { title: "heightModelInfo", type: "object", description: "An object that defines the characteristics of the vertical coordinate system used by the web scene.", properties: { heightModel: { type: "string", description: "The surface type or height model of the vertical coordinate system.", enum: ["ellipsoidal", "gravity_related_height"], default: "ellipsoidal" }, heightUnit: { type: "string", description: 'The unit of the vertical coordinate system.<a href="#heightUnit"><sup>1</sup></a>', enum: ["150-kilometers", "50-kilometers", "benoit-1895-b-chain", "clarke-foot", "clarke-link", "clarke-yard", "foot", "gold-coast-foot", "indian-1937-yard", "indian-yard", "meter", "sears-1922-truncated-chain", "sears-chain", "sears-foot", "sears-yard", "us-foot"] }, vertCRS: { type: "string", description: "(Optional) The datum realization of the vertical coordinate system." } }, required: ["heightModel", "heightUnit"], additionalProperties: false }, "initialState_schema.json": { title: "initialState", type: "object", description: "An object that provides information about the initial environment settings and viewpoint of the web scene.", properties: { environment: { type: "object", $ref: "#/definitions/environment_schema.json" }, viewpoint: { type: "object", description: "Describes a point of view for a 2D or 3D view. In a 3D view, it is determined using a camera position.", $ref: "#/definitions/viewpoint_schema.json" } }, required: ["environment", "viewpoint"], additionalProperties: false }, "mapRangeInfo_schema.json": { title: "Map Range Information", description: "Map range information", properties: { activeRangeName: { type: "string", description: "Active range ID that slider/picker acts upon." }, currentRangeExtent: { type: "array", description: "Current range for the active range.", items: { type: "number" }, minItems: 2, maxItems: 2 }, fullRangeExtent: { type: "array", description: "Full range extent for the active range to be presented in the UI.", items: { type: "number" }, minItems: 2, maxItems: 2 } }, required: ["activeRangeName"], additionalProperties: false }, "operationalLayers_schema.json": { title: "operationalLayers", type: "object", description: "Operational layers contain your data. Usually, a basemap sits beneath your operational layers to give them geographic context.", oneOf: [{ $ref: "#/definitions/buildingSceneLayer_schema.json" }, { $ref: "#/definitions/csvLayer_schema.json" }, { $ref: "#/definitions/featureLayer_schema.json" }, { $ref: "#/definitions/groupLayer_schema.json" }, { $ref: "#/definitions/imageServiceLayer_schema.json" }, { $ref: "#/definitions/integratedMeshLayer_schema.json" }, { $ref: "#/definitions/kmlLayer_schema.json" }, { $ref: "#/definitions/mapServiceLayer_schema.json" }, { $ref: "#/definitions/pointCloudLayer_schema.json" }, { $ref: "#/definitions/rasterDataLayer_schema.json" }, { $ref: "#/definitions/sceneLayer_schema.json" }, { $ref: "#/definitions/tiledImageServiceLayer_schema.json" }, { $ref: "#/definitions/tiledMapServiceLayer_schema.json" }, { $ref: "#/definitions/vectorTileLayer_schema.json" }, { $ref: "#/definitions/webTiledLayer_schema.json" }, { $ref: "#/definitions/wmsLayer_schema.json" }] }, "presentation_schema.json": { title: "presentation", type: "object", description: "A presentation consists of multiple slides, where each slide is a specific view into the web scene.", properties: { slides: { type: "array", description: "Array of slide objects.", items: { type: "object", $ref: "#/definitions/slide_schema.json" } } }, additionalProperties: false }, "spatialReference_schema.json": { title: "spatialReference", type: "object", description: "The spatialReference object is located at the top level of the JSON hierarchy. In addition to this, it is also available within the operationalLayer and basemap objects.\n\nMany predefined spatial references have already been defined and are available for use. A spatial reference can be defined using a well-known ID (WKID) or well-known text (WKT). The default tolerance and resolution values for the associated coordinate system are used.\n\nA spatial reference can optionally include a definition for a vertical coordinate system (VCS), which is used to interpret the z values of a geometry.", properties: { latestVcsWkid: { type: "integer", description: "(Optional) The current wkid value of the vertical coordinate system." }, latestWkid: { type: "integer", description: "(Optional) Identifies the current wkid value associated with the same spatial reference. For example a WKID of '102100' (Web Mercator) has a latestWKid of '3857'." }, vcsWkid: { type: "integer", description: "(Optional) The wkid value of the vertical coordinate system." }, wkid: { type: "integer", description: "The well-known ID (WKID) of the coordinate system. Specify either WKID or the well-known text (WKT) of the coordinate system." }, wkt: { type: "string", description: "The well-known text (WKT) of the coordinate system. Specify either WKT or WKID of the coordinate system." } }, oneOf: [{ required: ["wkt"] }, { required: ["wkid"] }], additionalProperties: false }, "table_schema.json": { title: "table", type: "object", description: "Root element in the web scene specifying an array of table objects.", properties: { capabilities: { type: "string", description: "A comma-separated string listing which editing operations are allowed on an editable feature service. Available operations include: `Create`, `Delete`, `Query`, `Update`, and `Editing`." }, definitionEditor: { type: "object", description: "Object indicating the definitionEditor used as a layer's interactive filter.", $ref: "#/definitions/definitionEditor_schema.json" }, id: { type: "string", description: "Unique string identifier for the table." }, itemId: { type: "string", description: "Unique string value indicating an item registered in ArcGIS Online or your organization's portal." }, layerDefinition: { type: "object", description: "A layerDefinition object defining a definition expression for the table.", $ref: "#/definitions/layerDefinition_schema.json" }, path: { type: "string", description: "For offline data, a path to a geodatabase file. A URI format is used starting with `file:` followed by a file system path with a `.geodatabase` extension. A query parameter `itemId` must also be present specifying the ID of a table in the geodatabase's `GDB_ServiceItems` table. A relative path must be from the file which defines the table. For example `file:../p20/northamerica.geodatabase?itemId=5`.", pattern: "^file:.+\\.geodatabase\\?itemId=\\d+$" }, popupInfo: { type: "object", description: "An object defining the content of popup windows when you query a record and the sort option for child related records.", $ref: "#/definitions/popupInfo_schema.json" }, title: { type: "string", description: "String value for the title of the table." }, url: { type: "string", description: "String value indicating the URL reference of the hosted table." } }, required: ["title", "url"], additionalProperties: false }, "transportationNetwork_schema.json": { title: "Transportation Network", type: "object", description: "The transportation network used for routing in the scene.", properties: { name: { type: "string", description: "The name of the transportation network. The name must be unique within a scene." }, path: { type: "string", description: "The path to the geodatabase which contains the network.", pattern: "^file:.+\\.geodatabase?$" }, title: { type: "string", description: "A title or alias of the network layer. This can be used in the client user interface." } }, required: ["name", "path", "title"], additionalProperties: false }, "version_schema.json": { title: "version", type: "string", description: "Root element in the web scene specifying a string value indicating the web scene version.", enum: ["1.8", "1.9", "1.10", "1.11", "1.12", "1.13", "1.14", "1.15", "1.16", "1.17", "1.18", "1.19", "1.20", "1.21", "1.22", "1.23"] }, "widgets_schema.json": { title: "widgets", type: "object", description: "The widgets object contains widgets that should be exposed to the user.", properties: { range: { type: "object", description: "Active range.", $ref: "#/definitions/range_schema.json" } }, additionalProperties: false }, "buildingSceneLayer_filter_schema.json": { title: "Building Scene Layer Filter", type: "object", description: "Filter allows client applications to reduce the drawn elements of a building to specific types and values. Filters on the webscene override the list of existing filters on the service.", properties: { description: { type: "string", description: "Description of the filter." }, filterAuthoringInfo: { type: "object", description: "Metadata about the athoring process for this filter.", $ref: "#/definitions/buildingSceneLayer_filterAuthoringInfoCheckbox_schema.json" }, filterBlocks: { type: "array", description: "Array of filter blocks defining the filter. A filter contains at least one filter block.", items: { type: "object", $ref: "#/definitions/buildingSceneLayer_filterBlock_schema.json" }, minItems: 1 }, id: { type: "string", description: "unique filter id (uuid). Either a new id to extend the list of filters, or an existing id to override properties of an existing filter." }, name: { type: "string", description: "Name of the filter." } }, required: ["filterBlocks", "id", "name"], additionalProperties: false }, "layerDefinition_schema.json": { title: "layerDefinition", type: "object", description: "An object that defines the attribute schema and drawing information for a layer drawn using client-side graphics.", properties: { allowGeometryUpdates: { type: "boolean", description: "Boolean value indicating whether the geometry of the features in the layer can be edited." }, capabilities: { type: "string", description: "A comma separated list of supported capabilities, e.g. `Query,Editing`." }, copyrightText: { type: "string", description: "String value for the copyright text information for the layer." }, currentVersion: { type: "number", description: "Numeric value indicating the server version of the layer." }, defaultVisibility: { type: "boolean", description: "Boolean value indicating whether the layer's visibility is turned on." }, definitionExpression: { type: "string", description: "SQL-based definition expression string that narrows the data to be displayed in the layer." }, description: { type: "string", description: "String value of the layer as defined in the map service." }, displayField: { type: "string", description: "A string value that summarizes the feature." }, drawingInfo: { type: "object", description: "Contains the drawing and labeling information.", $ref: "#/definitions/drawingInfo_schema.json" }, elevationInfo: { type: "object", $ref: "#/definitions/elevationInfo_schema.json" }, extent: { description: "An object defining the rectangular area.", oneOf: [{ $ref: "#/definitions/extent_schema.json" }, { type: "null" }] }, featureReduction: { type: "object", description: "An object that specifies how features are reduced or aggregated, with the goal of decluttering the view or presenting the user with an aggregate visualization. If unset, every feature is rendered individually.", $ref: "#/definitions/featureReduction_select_schema.json" }, fields: { type: "array", description: "An array of field objects containing information about the attribute fields for the feature collection or layer.", items: { type: "object", $ref: "#/definitions/field_schema.json" }, uniqueItems: true }, filters: { type: "array", description: "Filters for PointCloud layers", items: { type: "object", $ref: "#/definitions/pointCloudFilter_schema.json" } }, geometryType: { type: "string", description: "A string defining the type of geometry. Possible geometry types are: `esriGeometryPoint`, `esriGeometryMultipoint`, `esriGeometryPolyline`, `esriGeometryPolygon`, and `esriGeometryEnvelope`." }, globalIdField: { type: "string", description: "The unique identifier for a feature or table row within a geodatabase." }, hasAttachments: { type: "boolean", description: "Indicates whether attachments should be loaded for the layer." }, hasM: { type: "boolean", description: "Boolean value indicating whether layer has M values." }, hasStaticData: { type: "boolean", description: "Boolean value indicating whether data changes. True if it does not." }, hasZ: { type: "boolean", description: "Boolean value indicating whether layer has Z values." }, htmlPopupType: { type: "string", description: "String value indicating the HTML popup type.", enum: ["esriServerHTMLPopupTypeAsHTMLText", "esriServerHTMLPopupTypeAsURL", "esriServerHTMLPopupTypeNone"] }, id: { type: "integer", description: "The identifier assigned to the layer." }, isDataVersioned: { type: "boolean", description: "Boolean value indicating whether the data is versioned." }, maxRecordCount: { type: "integer", description: "Numeric value indicating tbe maximum number of records that will be returned at once for a query." }, maxScale: { type: "number", description: "Represents the maximum scale (most zoomed in) at which the layer is visible in the view. If the web scene is zoomed in beyond this scale, the layer will not be visible. A value of 0 means the layer does not have a maximum scale. If set, the maxScale value should always be smaller than the minScale value, and greater than or equal to the service specification." }, minScale: { type: "number", description: "Represents the minimum scale (most zoomed out) at which the layer is visible in the view. If the web scene is zoomed out beyond this scale, the layer will not be visible. A value of 0 means the layer does not have a minimum scale. If set, the minScale value should always be larger than the maxScale value, and lesser than or equal to the service specification." }, name: { type: "string", description: "Contains a unique name for the layer that can be displayed in a legend." }, objectIdField: { type: "string", description: "Indicates the name of the object ID field in the dataset." }, overrideSymbols: { type: "boolean", description: "Dictates whether a client can support having an end user modify symbols on individual features." }, rangeInfos: { type: "array", description: "Indicates range information", items: { type: "object", $ref: "#/definitions/rangeInfo_schema.json" }, minItems: 1 }, source: { type: "object", description: "An object indicating the layerDefinition's layer source.", $ref: "#/definitions/source_schema.json" }, spatialReference: { type: "object", description: "An object containing the WKID or WKT identifying the spatial reference of the layer's geometry.", $ref: "#/definitions/spatialReference_schema.json" }, supportedQueryFormats: { type: "string", description: "String value indicating the output formats that are supported in a query." }, supportsAdvancedQueries: { type: "boolean", description: "Boolean value indicating whether the layer supports orderByFields in a query operation." }, supportsAttachmentsByUploadId: { type: "boolean", description: "Boolean value indicating whether the layer supports uploading attachments with the Uploads operation. This can then be used in the Add Attachment and Update Attachment operations." }, supportsCalculate: { type: "boolean", description: "Boolean value indicating whether the layer supports the Calculate REST operation when updating features." }, supportsRollbackOnFailureParameter: { type: "boolean", description: "Boolean value indicating whether the layer supports rolling back edits made on a feature layer if some of the edits fail." }, supportsStatistics: { type: "boolean", description: "Boolean value indicating whether feature layer query operations support statistical functions." }, supportsValidateSql: { type: "boolean", description: "Boolean value indicating whether the validateSQL operation is supported across a feature service layer." }, type: { type: "string", description: "Indicates whether the layerDefinition applies to a Feature Layer or a Table.", enum: ["Feature Layer", "Table"], default: "Feature Layer" }, typeIdField: { type: "string", description: "Contains the name of the field holding the type ID for the features." }, types: { type: "array", description: "Contains information about an attribute field.", items: { type: "object", $ref: "#/definitions/type_schema.json" }, uniqueItems: true }, visibilityField: { type: "string", description: "String value indicating the attribute field that is used to control the visibility of a feature. If applicable, when rendering a feature the client should use this field to control visibility. The field's values are 0 = do not display, 1 = display." } }, additionalProperties: false }, "popupInfo_schema.json": { title: "popupInfo", type: "object", description: "Defines the look and feel of popup windows when a user clicks or queries a feature.", properties: { description: { type: ["string"], description: "A string that appears in the body of the popup window as a description. A basic subset of HTML may also be used to enrich the text. The supported HTML for ArcGIS Online can be seen in the [Supported HTML](https://doc.arcgis.com/en/arcgis-online/reference/supported-html.htm) page." }, expressionInfos: { type: "array", description: "List of Arcade expressions added to the pop-up.", items: { type: "object", $ref: "#/definitions/popupExpressionInfo_schema.json" } }, fieldInfos: { type: "array", description: "Array of fieldInfo information properties. This information is provided by the service layer definition.", items: { type: "object", $ref: "#/definitions/fieldInfo_schema.json" } }, layerOptions: { type: "object", description: "Additional options that can be defined for the popup layer.", $ref: "#/definitions/popupLayerOptions_schema.json" }, mediaInfos: { type: "array", description: "Array of various mediaInfo to display. Can be of type `image`, `piechart`, `barchart`, `columnchart`, or `linechart`. The order given is the order in which it displays.", items: { type: "object", $ref: "#/definitions/mediaInfo_schema.json" } }, popupElements: { type: "array", description: "An array of popupElement objects that represent an ordered list of popup elements.", items: { type: "object", $ref: "#/definitions/popupElement_schema.json" } }, relatedRecordsInfo: { type: "object", description: "Indicates whether to enable related records if they exist on a layer.", $ref: "#/definitions/relatedRecordsInfo_schema.json" }, showAttachments: { type: "boolean", description: "Indicates whether attachments will be loaded for feature layers that have attachments." }, showLastEditInfo: { type: "boolean", description: "Indicates whether popup will display information about when and who last edited the feature. Applicable only to layers that have been configured to keep track of such information.", default: true }, title: { type: "string", description: "A string that appears at the top of the popup window as a title." } }, additionalProperties: false }, "buildingSceneLayer_sublayer_schema.json": { title: "Building Scene Sublayer", type: "object", description: "The BuildingSceneLayer sublayer is a part of a building scene layer.", properties: { disablePopup: { type: "boolean", description: "disablePopups allows a client to ignore popups defined by the service item." }, id: { type: "integer", description: "Identifies the sublayer inside the building scene layer." }, layerDefinition: { type: "object", description: "Additional properties that can define drawing information and a definition expression for the sublayer.", allOf: [{ $ref: "#/definitions/layerDefinition_schema.json" }, { properties: { definitionExpression: {}, drawingInfo: { allOf: [{ $ref: "#/definitions/drawingInfo_schema.json" }, { properties: { renderer: {} }, additionalProperties: false }] } }, additionalProperties: false }] }, listMode: { type: "string", description: "To show or hide the sublayer in the layer list.", enum: ["hide", "show"] }, opacity: { type: "number", description: "The degree of transparency applied to the sublayer on the client side, where 0 is full transparency and 1 is no transparency. This is multiplied with the opacity of the containing layers.", minimum: 0, maximum: 1, default: 1 }, popupInfo: { type: "object", description: "A popupInfo object defining the content of pop-up windows when you click or query a feature.", $ref: "#/definitions/popupInfo_schema.json" }, title: { type: "string", description: "A user-friendly string title for the sublayer that can be used in a table of contents." }, visibility: { type: "boolean", description: "Boolean property determining whether the sublayer is initially visible in the web scene" } }, required: ["id"], additionalProperties: false }, "drawingInfo_schema.json": { title: "drawingInfo", type: "object", description: "The drawingInfo object contains drawing information for a feature layer.", properties: { labelingInfo: { type: "array", description: "An array of labelingInfo objects.", items: { type: "object", $ref: "#/definitions/labelingInfo_schema.json" } }, renderer: { $ref: "#/definitions/renderer_schema.json" }, showLabels: { type: "boolean", description: "Labels will display if this property is set to `true` and the layer also has a [labelingInfo](labelingInfo.md) property associated with it.", default: false }, transparency: { type: "number", description: "Number value ranging between 0 (no transparency) to 100 (completely transparent).", minimum: 0, maximum: 100 } }, additionalProperties: false }, "viewing_schema.json": { title: "viewing", type: "object", description: "View-specific properties of application and UI elements.", properties: { search: { type: "object", $ref: "#/definitions/search_schema.json" } }, additionalProperties: false }, "baseMapLayer_schema.json": { title: "baseMapLayer", type: "object", description: "A basemap layer is a layer that provides geographic context to the scene. The following is a list of possible basemap layer types.", oneOf: [{ $ref: "#/definitions/imageServiceLayer_schema.json" }, { $ref: "#/definitions/mapServiceLayer_schema.json" }, { $ref: "#/definitions/openStreetMapLayer_schema.json" }, { $ref: "#/definitions/rasterDataLayer_schema.json" }, { $ref: "#/definitions/tiledImageServiceLayer_schema.json" }, { $ref: "#/definitions/tiledMapServiceLayer_schema.json" }, { $ref: "#/definitions/vectorTileLayer_schema.json" }, { $ref: "#/definitions/webTiledLayer_schema.json" }, { $ref: "#/definitions/wmsLayer_schema.json" }] }, "elevationLayers_schema.json": { title: "elevationLayers", type: "object", description: "Elevation layers provide elevation for the ground.", oneOf: [{ $ref: "#/definitions/rasterDataElevationLayer_schema.json" }, { $ref: "#/definitions/tiledElevationLayer_schema.json" }] }, "extent_schema.json": { title: "extent", type: "object", description: "This object defines the bounding geometry given the lower-left and upper-right corners of the bounding box. A [spatial reference](spatialReference.md) is also required.", properties: { spatialReference: { type: "object", description: "An object used to specify the spatial reference of the given geometry.", $ref: "#/definitions/spatialReference_schema.json" }, xmax: { type: "number", description: "A numeric value indicating the top-right X-coordinate of an extent envelope." }, xmin: { description: "A numeric value indicating the bottom-left X-coordinate of an extent envelope.", oneOf: [{ type: "number" }, { type: "null" }, { type: "string", enum: ["NaN"] }] }, ymax: { type: "number", description: "A numeric value indicating the top-right Y-coordinate of an extent envelope." }, ymin: { type: "number", description: "A numeric value indicating the bottom-left Y-coordinate of an extent envelope." } }, additionalProperties: false }, "navigationConstraint_schema.json": { title: "Navigation Constraint", type: "object", description: "Object determining whether the camera is constrained to navigate only above, or also under the ground surface.", properties: { type: { type: "string", enum: ["none", "stayAbove"] } }, required: ["type"], additionalProperties: false }, "color_schema.json": { title: "color", type: "array", description: "Color is represented as a three or four-element array. The four elements represent values for red, green, blue, and alpha in that order. Values range from 0 through 255. If color is undefined for a symbol, the color value is null.", items: { type: "integer", minimum: 0, maximum: 255 }, minItems: 3, maxItems: 4, additionalProperties: false }, "environment_schema.json": { title: "environment", type: "object", description: "Represents settings that affect the environment in which the web scene is displayed. It is entirely stored as part of the initial state of the web scene, and partially in the slides in the presentation.", properties: { atmosphereEnabled: { type: "boolean", description: "Whether the atmosphere should be visualized. This includes sky and haze effects.", default: true }, background: { type: "object", description: "The background is what is displayed behind any scene objects, stars and atmosphere.", $ref: "#/definitions/environment_background_color_schema.json" }, lighting: { type: "object", $ref: "#/definitions/lighting_schema.json" }, starsEnabled: { type: "boolean", description: "Whether stars should be displayed in the sky.", default: true } }, additionalProperties: false }, "viewpoint_schema.json": { title: "viewpoint", type: "object", description: "The location or camera position from which to view the scene.", properties: { camera: { type: "object", $ref: "#/definitions/camera_schema.json" }, rotation: { type: "number", description: "The rotation of due north in relation to the top of the view in degrees.", minimum: 0, maximum: 360 }, scale: { type: "number", description: "The scale of the viewpoint." }, targetGeometry: { type: "object", description: "The target geometry framed by the viewpoint.", oneOf: [{ description: "", $ref: "#/definitions/geometry_schema.json" }, { description: "", $ref: "#/definitions/extent_schema.json" }] } }, required: ["camera"], additionalProperties: false }, "buildingSceneLayer_schema.json": { title: "Building Scene Layer (BuildingSceneLayer)", type: "object", description: "The BuildingSceneLayer is a layer type designed for on-demand streaming and displaying building data.", properties: { activeFilterId: { type: "string", description: "specifies the id of the currently active filter" }, filters: { type: "array", description: "A list of filters available for this layer. Overrides filters defined on the service.", items: { type: "object", $ref: "#/definitions/buildingSceneLayer_filter_schema.json" }, uniqueItems: true }, id: { type: "string", description: "A unique identifying string for the layer." }, itemId: { type: "string", description: "Optional string containing the item ID of the service if it's registered on ArcGIS Online or your organization's portal." }, layerDefinition: { type: "object", description: "Additional properties that can define an elevation offset for the layer.", allOf: [{ $ref: "#/definitions/layerDefinition_schema.json" }, { properties: { elevationInfo: {}, minScale: {}, maxScale: {} }, additionalProperties: false }] }, layerType: { type: "string", description: "String indicating the layer type.", enum: ["BuildingSceneLayer"] }, listMode: { type: "string", description: "To show or hide the sublayer in the layer list. If the layer has sublayers, selecting `hide-children` will hide them in the layer list.", enum: ["hide", "hide-children", "show"] }, opacity: { type: "number", description: "The degree of transparency applied to the layer on the client side, where 0 is full transparency and 1 is no transparency.", minimum: 0, maximum: 1, default: 1 }, sublayers: { type: "array", description: "An array of objects specifying overrides for building scene layer sublayers", items: { type: "object", $ref: "#/definitions/buildingSceneLayer_sublayer_schema.json" }, uniqueItems: true }, title: { type: "string", description: "A user-friendly string title for the layer that can be used in a table of contents." }, url: { type: "string", description: "The URL to the service." }, visibility: { type: "boolean", description: "Boolean property determining whether the layer is initially visible in the web scene", default: true } }, required: ["id", "layerType", "title", "url"], additionalProperties: false }, "csvLayer_schema.json": { title: "CSV Layer (CSV)", type: "object", description: "The CSV layer type references a CSV or TXT file from a publically-accessible web server. It then dynamically loads into the scene at run time. The CSV layer will maintain a reference to the CSV resource.", properties: { columnDelimiter: { type: "string", description: "A string defining the character used to separate columns in a CSV file.", enum: ["	", " ", ",", ";", "|"] }, disablePopup: { type: "boolean", description: "Indicates whether to allow a client to ignore popups defined by the service item." }, id: { type: "string", description: "A unique identifying string for the layer." }, layerDefinition: { description: "Additional properties that define drawing information and other configurations for the layer.", allOf: [{ $ref: "#/definitions/layerDefinition_schema.json" }, { properties: { definitionExpression: {}, drawingInfo: { allOf: [{ $ref: "#/definitions/drawingInfo_schema.json" }, { properties: { labelingInfo: {}, renderer: {}, transparency: {} }, additionalProperties: false }] }, elevationInfo: {}, featureReduction: {}, fields: {}, maxScale: {}, minScale: {} }, additionalProperties: false }] }, layerType: { type: "string", description: "String indicating the layer type.", enum: ["CSV"] }, listMode: { type: "string", description: "To show or hide the layer in the layer list", enum: ["hide", "show"] }, locationInfo: { type: "object", description: "A locationInfo object defining how location information will be retrieved from a CSV file.", $ref: "#/definitions/locationInfo_schema.json" }, opacity: { type: "number", description: "The degree of transparency applied to the layer on the client side, where 0 is full transparency and 1 is no transparency.", minimum: 0, maximum: 1, default: 1 }, popupInfo: { type: "object", description: "A popupInfo object defining the content of popup windows when you click or query a feature.", $ref: "#/definitions/popupInfo_schema.json" }, refreshInterval: { type: "number", description: "Refresh interval of the layer in minutes. Non-zero value indicates automatic layer refresh at the specified interval. Value of 0 indicates auto refresh is not enabled." }, screenSizePerspective: { type: "boolean", description: "Apply [perspective scaling](https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-FeatureLayer.html#screenSizePerspectiveEnabled) to screen-size symbols.", default: false }, showLabels: { type: "boolean", description: "Labels will display if this property is set to `true` and the layer also has a [labelingInfo](labelingInfo.md) property associated with it.", default: false }, showLegend: { type: "boolean", description: "Boolean value indicating whether to display the layer in the legend. Default value is `true`.", default: true }, title: { type: "string", description: "A user-friendly string title for the layer that can be used in a table of contents." }, url: { type: "string", description: "The URL to the layer." }, visibility: { type: "boolean", description: "Boolean property determining whether the layer is initially visible in the web scene.", default: true } }, required: ["id", "layerType", "title", "url"], additionalProperties: false }, "featureLayer_schema.json": { title: "Feature Layer (ArcGISFeatureLayer)", type: "object", description: "Feature layers can be created by referencing a layer from either a map service or a feature service. Use a map service if you just want to retrieve geometries and attributes from the server and symbolize them yourself. Use a feature service if you want to take advantage of symbols from the service's source map document. Also, use a feature service if you plan on doing editing with the feature layer. Feature layers honor any feature templates configured in the source map document. Feature collection objects are used to create a feature layer based on the supplied definition.", properties: { disablePopup: { type: "boolean", description: "Indicates whether to allow a client to ignore popups defined by the service item." }, id: { type: "string", description: "A unique identifying string for the layer." }, itemId: { type: "string", description: "Optional string containing the item ID of the service if it's registered on ArcGIS Online or your organization's portal." }, layerDefinition: { description: "Additional properties that define drawing information and other configurations for the layer.", allOf: [{ $ref: "#/definitions/layerDefinition_schema.json" }, { properties: { capabilities: {}, definitionExpression: {}, drawingInfo: { allOf: [{ $ref: "#/definitions/drawingInfo_schema.json" }, { properties: { labelingInfo: {}, renderer: {}, transparency: {} }, additionalProperties: false }] }, elevationInfo: {}, featureReduction: {}, maxScale: {}, minScale: {} }, additionalProperties: false }] }, layerType: { type: "string", description: "String indicating the layer type.", enum: ["ArcGISFeatureLayer"] }, listMode: { type: "string", description: "To show or hide layers in the layer list", enum: ["hide", "show"] }, opacity: { type: "number", description: "The degree of transparency applied to the layer on the client side, where 0 is full transparency and 1 is no transparency.", minimum: 0, maximum: 1, default: 1 }, path: { type: "string", description: "For offline data, a path to a geodatabase file. A URI format is used starting with `file:` followed by a file system path with a `.geodatabase` extension. A query parameter `itemId` must also be present specifying the ID of a table in the geodatabase's `GDB_ServiceItems` table. A relative path must be from the file which defines the layer. For example `file:../p20/northamerica.geodatabase?itemId=1`.", pattern: "^file:.+\\.geodatabase\\?itemId=\\d+$" }, popupInfo: { type: "object", description: "A popupInfo object defining the content of popup windows when you click or query a feature.", $ref: "#/definitions/popupInfo_schema.json" }, refreshInterval: { type: "number", description: "Refresh interval of the layer in minutes. Non-zero value indicates automatic layer refresh at the specified interval. Value of 0 indicates auto refresh is not enabled." }, screenSizePerspective: { type: "boolean", description: "Apply [perspective scaling](https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-FeatureLayer.html#screenSizePerspectiveEnabled) to screen-size symbols.", default: false }, showLabels: { type: "boolean", description: "Labels will display if this property is set to `true` and the layer also has a [labelingInfo](labelingInfo.md) property associated with it. This property can get stored in the web scene config and in the item/data.", default: false }, showLegend: { type: "boolean", description: "Boolean value indicating whether to display the layer in the legend. Default value is `true`.", default: true }, title: { type: "string", description: "A user-friendly string title for the layer that can be used in a table of contents." }, url: { type: "string", description: "The URL to the layer. If the layer is not from a web service but rather a feature collection, then the url property is omitted." }, visibility: { type: "boolean", description: "Boolean property determining whether the layer is initially visible in the web scene.", default: true } }, required: ["id", "layerType", "title"], additionalProperties: false }, "groupLayer_schema.json": { title: "Group Layer", type: "object", description: "GroupLayer provides the ability to organize several sublayers into one common layer. Suppose there are several FeatureLayers that all represent water features in different dimensions. For example, wells (points), streams (lines), and lakes (polygons). The GroupLayer provides the functionality to treat them as one layer called Water Features even though they are stored as separate feature layers.<br><br>With respect to scale visibility, sublayers of a group layer will be visible only within the scale range defined for the group layer. A sublayer may further restrict itself to a narrow scale range. In other words, a sublayer will be visible only when the current map scale intersects the scale range of that sublayer as well as the scale range of all its parent group layers.", properties: { id: { type: "string", description: "A unique identifying string for the layer" }, layerType: { type: "string", description: "String indicating the layer type", enum: ["GroupLayer"] }, layers: { type: "array", description: "list of child operationalLayers", items: { type: "object", $ref: "#/definitions/operationalLayers_schema.json" }, uniqueItems: true }, listMode: { type: "string", description: "To show or hide the group layer in the layer list", enum: ["hide", "hide-children", "show"] }, maxScale: { type: "number", description: "A number representing the maximum scale at which the layer will be visible. The number is the scale's denominator.", minimum: 0, default: 0 }, minScale: { type: "number", description: "A number representing the minimum scale at which the layer will be visible. The number is the scale's denominator.", minimum: 0, default: 0 }, opacity: { type: "number", description: "The degree of transparency applied to the layer on the client side, where 0 is full transparency and 1 is no transparency." }, title: { type: "string", description: "A user-friendly string title for the layer that can be used in a table of contents. If this is not included, a title is derived from the service" }, visibility: { type: "boolean", description: "Boolean property determining whether the layer is initially visible in the web scene", default: true }, visibilityMode: { type: "string", description: "How visibility of children is affected:independent, exclusive, inherited", enum: ["exclusive", "independent", "inherited"] } }, required: ["id", "layerType", "title"], additionalProperties: false }, "imageServiceLayer_schema.json": { title: "Image Service Layer (ArcGISImageServiceLayer)", type: "object", description: "An image service provides access to raster data through a web service. Multiple rasters can be served as one image service through mosaic dataset technology, dynamically processed and mosaicked on the fly. An image service supports accessing both the mosaicked image and its catalog, as well as individual rasters in the catalog. Also, image services can be cached (tiled) or uncached (dynamic). This object specifically details properties within uncached image services.", properties: { bandIds: { type: "array", description: "An array of bandIds that are visible for a multispectral dataset. It can specify bands to export or rearrange band order(from image service).", items: { type: "integer" } }, compressionQuality: { type: "number", description: "Controls how much loss the image will be subjected to by the compression algorithm (from image service).", minimum: 0, maximum: 100 }, compressionTolerance: { type: "number", description: "Controls the tolerance of the lerc compression algorithm. The tolerance defines the maximum possible error of pixel values in the compressed image.", minimum: 0, default: 0.01 }, disablePopup: { type: "boolean", description: "Boolean property indicating whether to ignore popups defined by the service item.", default: false }, format: { type: "string", description: "String value representing image format.", enum: ["bmp", "gif", "jpg", "jpgpng", "lerc", "png", "png24", "png32", "png8", "tiff"], default: "png" }, id: { type: "string", description: "A unique identifying string for the layer." }, interpolation: { type: "string", description: "The algorithm used for interpolation.", enum: ["RSP_BilinearInterpolation", "RSP_CubicConvolution", "RSP_Majority", "RSP_NearestNeighbor"] }, isReference: { type: "boolean", description: "This is applicable if used as a baseMapLayer. A boolean value indicating whether or not the baseMapLayer draws on top (true) of other layers, including operationalLayers , or below (false).", default: false }, itemId: { type: "string", description: "Optional string containing the item ID of the service if it's registered on ArcGIS Online or your organization's portal." }, layerDefinition: { allOf: [{ $ref: "#/definitions/layerDefinition_schema.json" }, { properties: { definitionExpression: {}, drawingInfo: { allOf: [{ $ref: "#/definitions/drawingInfo_schema.json" }, { properties: { renderer: {}, transparency: {} }, additionalProperties: false }] } }, additionalProperties: false }] }, layerType: { type: "string", description: "String indicating the layer type.", enum: ["ArcGISImageServiceLayer"] }, listMode: { type: "string", description: "To show or hide layers in the layer list", enum: ["hide", "show"], default: "show" }, maxScale: { type: "number", description: "A number representing the maximum scale at which the layer will be visible. The number is the scale's denominator.", minimum: 0 }, minScale: { type: "number", description: "A number representing the minimum scale at which the layer will be visible. The number is the scale's denominator.", minimum: 0 }, mosaicRule: { type: "object", description: "Specifies the mosaic rule when defining how individual images should be mosaicked.", $ref: "#/definitions/mosaicRule_schema.json" }, noData: { type: "integer", description: "The pixel value that represents no information." }, noDataInterpretation: { type: "string", description: "A string value of interpretation of noData setting. Default is `esriNoDataMatchAny` when noData is a number, and `esriNoDataMatchAll` when noData is an array.", enum: ["esriNoDataMatchAll", "esriNoDataMatchAny"], default: "esriNoDataMatchAny" }, opacity: { type: "number", description: "The degree of transparency applied to the layer on the client side, where 0 is full transparency and 1 is no transparency.", minimum: 0, maximum: 1, default: 1 }, pixelType: { type: "string", description: "Pertains to the type of values stored in the raster, such as signed integer, unsigned integer, or floating point.", enum: ["C128", "C64", "F32", "F64", "S16", "S32", "S8", "U1", "U16", "U2", "U32", "U4", "U8", "UNKNOWN"] }, popupInfo: { type: "object", description: "A popupInfo object defining the content of popup windows when you click on the image.", $ref: "#/definitions/popupInfo_schema.json" }, refreshInterval: { type: "number", description: "Refresh interval of the layer in minutes. Non-zero value indicates automatic layer refresh at the specified interval. Value of 0 indicates auto refresh is not enabled." }, renderingRule: { type: "object", description: "Specifies the rendering rule for how the requested image should be rendered.", $ref: "#/definitions/renderingRule_schema.json" }, showLegend: { type: "boolean", description: "Indicates whether to allow map authors the ability to control what layers should be shown in a client's legend control.", default: true }, title: { type: "string", description: "A user-friendly string title for the layer that can be used in a table of contents." }, url: { type: "string", description: "The URL to the layer." }, visibility: { type: "boolean", description: "Boolean property determining whether the layer is initially visible in the web map.", default: true } }, required: ["layerType", "title", "url"], additionalProperties: false }, "integratedMeshLayer_schema.json": { title: "Integrated Mesh Layer (IntegratedMeshLayer)", type: "object", description: "An integrated mesh can represent built and natural 3D features, such as building walls, trees, valleys, and cliffs, with realistic textures and includes elevation information.", properties: { id: { type: "string", description: "A unique identifying string for the layer." }, itemId: { type: "string", description: "Optional string containing the item ID of the service if it's registered on ArcGIS Online or your organization's portal." }, layerDefinition: { type: "object", description: "A layerDefinition object defining the attribute schema and drawing information for the layer.", allOf: [{ $ref: "#/definitions/layerDefinition_schema.json" }, { properties: { elevationInfo: {}, minScale: {}, maxScale: {} }, additionalProperties: false }] }, layerType: { type: "string", description: "String indicating the layer type.", enum: ["IntegratedMeshLayer"] }, listMode: { type: "string", enum: ["hide", "show"] }, modifications: { type: "string", description: "URL to modifications json file, typically stored in `ITEM/resources`. Content of the file follows the $ref:[Modifications schema](modifications_schema.json)." }, opacity: { type: "number", description: "The degree of transparency applied to the layer on the client side, where 0 is full transparency and 1 is no transparency.", minimum: 0, maximum: 1, default: 1 }, path: { type: "string", description: "For offline data, a path to integrated mesh data in a scene layer package file. A URI format is used, starting with `file:` followed by a file system path with an extension of `.slpk`. A relative path must be from the file which defines the layer. For example `file:../p20/edinburgh.slpk`.", pattern: "^file:.+\\.slpk$" }, title: { type: "string", description: "A user-friendly string title for the layer that can be used in a table of contents. If this is not included, a title is derived from the service." }, url: { type: "string", description: "The URL to the layer. If the layer is not from a web service but rather a feature collection, then the url property is omitted." }, visibility: { type: "boolean", description: "Boolean property determining whether the layer is initially visible in the web scene.", default: true } }, anyOf: [{ required: ["id", "layerType", "title", "url"] }, { required: ["id", "layerType", "path", "title"] }], additionalProperties: false }, "kmlLayer_schema.json": { title: "KML Layer (KML)", type: "object", description: "Keyhole Markup Language (KML) is an XML-based format for storing geographic data and associated content and is an official Open Geospatial Consortium (OGC) standard. KML is a common format for sharing geographic data with non-GIS users as it can be easily delivered on the Internet.", properties: { id: { type: "string", description: "A unique identifying string for the layer." }, itemId: { type: "string", description: "A string containing the item ID of the service if it's registered on ArcGIS Online or your organization's portal." }, layerType: { type: "string", description: "String indicating the layer type.", enum: ["KML"] }, listMode: { type: "string", description: "To show or hide the sublayer in the layer list.", enum: ["hide", "show"] }, maxScale: { type: "number", description: "A number representing the maximum scale at which the layer will be visible. The number is the scale's denominator.", minimum: 0 }, minScale: { type: "number", description: "A number representing the minimum scale at which the layer will be visible. The number is the scale's denominator.", minimum: 0 }, opacity: { type: "number", description: "The degree of transparency applied to the layer on the client side, where 0 is full transparency and 1 is no transparency.", minimum: 0, maximum: 1, default: 1 }, path: { type: "string", description: "For offline data, a path to a KML file. A URI format is used, starting with `file:` followed by a file system path with an extension of `.kml` or `.kmz`.  A relative path must be from the file which defines the layer. For example `file:../commondata/kml/paris.kml`.", pattern: "^file:.+\\.km[lz]$" }, refreshInterval: { type: "number", description: "Refresh interval of the layer in minutes. Non-zero value indicates automatic layer refresh at the specified interval. Value of 0 indicates auto refresh is not enabled." }, showLegend: { type: "boolean", description: "Indicates whether to allow scene authors the ability to control what layers should be shown in a client's legend.", default: true }, title: { type: "string", description: "A user-friendly string title for the layer that can be used in a table of contents." }, url: { type: "string", description: "The URL to the layer." }, visibility: { type: "boolean", description: "Boolean property determining whether the layer is initially visible in the web scene.", default: true }, visibleFolders: { type: "array", description: "Array of numeric IDs of folders that will be made visible.", items: { type: "integer" }, uniqueItems: true } }, anyOf: [{ required: ["id", "layerType", "title", "url"] }, { required: ["id", "layerType", "path", "title"] }], additionalProperties: false }, "mapServiceLayer_schema.json": { title: "Map Service Layer (ArcGISMapServiceLayer)", type: "object", description: "Map services can be cached (tiled) or uncached (dynamic). This object specifically details properties within uncached map services.", properties: { id: { type: "string", description: "A unique identifying string for the layer." }, isReference: { type: "boolean", description: "This is applicable if used as a baseMapLayer. A boolean value indicating whether or not the baseMapLayer draws on top (true) of other layers, including operationalLayers, or below (false).", default: false }, itemId: { type: "string", description: "Optional string containing the item ID of the service if it's registered on ArcGIS Online or your organization's portal." }, layerType: { type: "string", description: "String indicating the layer type.", enum: ["ArcGISMapServiceLayer"] }, layers: { type: "array", description: "An array of layer objects defining the styling, geometry, and attribute information for the features.", items: { allOf: [{ $ref: "#/definitions/layer_schema.json" }, { properties: { defaultVisibility: {}, disablePopup: {}, id: {}, layerDefinition: {}, listMode: {}, maxScale: {}, minScale: {}, name: {}, parentLayerId: {}, popupInfo: {}, showLabels: {}, showLegend: {}, subLayerIds: {} }, additionalProperties: false }] }, uniqueItems: true }, listMode: { type: "string", description: "To show or hide the sublayer in the layer list. If the layer has sublayers, selecting `hide-children` will hide them in the layer list.", enum: ["hide", "hide-children", "show"] }, maxScale: { type: "number", description: "A number representing the maximum scale at which the layer will be visible. The number is the scale's denominator.", minimum: 0 }, minScale: { type: "number", description: "A number representing the minimum scale at which the layer will be visible. The number is the scale's denominator.", minimum: 0 }, opacity: { type: "number", description: "The degree of transparency applied to the layer on the client side, where 0 is full transparency and 1 is no transparency.", minimum: 0, maximum: 1, default: 1 }, refreshInterval: { type: "number", description: "Refresh interval of the layer in minutes. Non-zero value indicates automatic layer refresh at the specified interval. Value of 0 indicates auto refresh is not enabled." }, showLegend: { type: "boolean", description: "Boolean value indicating whether to display the layer in the legend. Default value is `true`.", default: true }, title: { type: "string", description: "A user-friendly string title for the layer that can be used in a table of contents." }, url: { type: "string", description: "The URL to the layer." }, visibility: { type: "boolean", description: "Boolean property determining whether the layer is initially visible in the web scene.", default: true }, visibleLayers: { type: "array", description: "An array of sublayer ids that should appear visible. Used with map service layers that are not tiled.", items: { type: "integer" }, uniqueItems: true } }, required: ["id", "layerType", "title", "url"], additionalProperties: false }, "pointCloudLayer_schema.json": { title: "PointCloud Layer", type: "object", description: "Point cloud data is post-processed spatially organized lidar data that consists of large collections of 3D points. Elevations for the ground, buildings, forest canopy, highway overpasses, and anything else encountered during the lidar survey make up the point cloud data. Point cloud layers allow for fast visualisation of point cloud data in the browser.", properties: { disablePopup: { type: "boolean", description: "disablePopups allows a client to ignore popups defined by the service item." }, id: { type: "string", description: "A unique identifying string for the layer" }, itemId: { type: "string", description: "Optional string containing the item ID of the service if it's registered on ArcGIS Online or your organization's portal" }, layerDefinition: { type: "object", description: "A layerDefinition object defining the attribute schema and drawing information for the layer.", allOf: [{ $ref: "#/definitions/layerDefinition_schema.json" }, { properties: { drawingInfo: { allOf: [{ $ref: "#/definitions/drawingInfo_schema.json" }, { properties: { renderer: {}, transparency: {} }, additionalProperties: false }] }, elevationInfo: {}, filters: {}, minScale: {}, maxScale: {} }, additionalProperties: false }] }, layerType: { type: "string", description: "String indicating the layer type", enum: ["PointCloudLayer"] }, listMode: { type: "string", description: "To show or hide the layer in the layer list", enum: ["hide", "show"] }, path: { type: "string", description: "For offline data, a path to point cloud layer data in a scene layer package file. A URI format is used, starting with `file:` followed by a file system path with an extension of `.slpk`. A relative path must be from the file which defines the layer. For example `file:../p20/zurich.slpk`.", pattern: "^file:.+\\.slpk$" }, popupInfo: { type: "object", description: "A popupInfo object defining the content of pop-up windows when you click a point.", $ref: "#/definitions/popupInfo_schema.json" }, showLegend: { type: "boolean", description: "Boolean value indicating whether to display the layer in the legend. Default value is `true`.", default: true }, title: { type: "string", description: "A user-friendly string title for the layer that can be used in a table of contents. If this is not included, a title is derived from the service" }, url: { type: "string", description: "The URL to the layer." }, visibility: { type: "boolean", description: "Boolean property determining whether the layer is initially visible", default: true } }, anyOf: [{ required: ["id", "layerType", "title", "url"] }, { required: ["id", "layerType", "path", "title"] }], additionalProperties: false }, "rasterDataLayer_schema.json": { title: "Raster Data Layer", type: "object", description: "A layer for displaying raster data. This layer only applies to offline data.", properties: { copyright: { type: "string", description: "Attribution to the Raster Data Layer provider. It is displayed in the attribution on the scene. Input required by the user when the layer is added to the scene." }, id: { type: "string", description: "A unique identifying string for the layer." }, layerType: { type: "string", description: "String indicating the layer type.", enum: ["RasterDataLayer"] }, listMode: { type: "string", description: "To show or hide the sublayer in the layer list.", enum: ["hide", "show"] }, maxScale: { type: "number", description: "A number representing the maximum scale at which the layer will be visible. The number is the scale's denominator.", minimum: 0 }, minScale: { type: "number", description: "A number representing the minimum scale at which the layer will be visible. The number is the scale's denominator.", minimum: 0 }, opacity: { type: "number", description: "The degree of transparency applied to the layer on the client side, where 0 is full transparency and 1 is no transparency.", minimum: 0, maximum: 1, default: 1 }, path: { type: "string", description: "For offline data, a path to a raster data file. A URI format is used, starting with `file:` followed by a file system path. A relative path must be from the file which defines the layer. For example `file:../commondata/raster_data/beijing.tif`.", pattern: "^file:.+$" }, title: { type: "string", description: "A user-friendly string title for the layer that can be used in a table of contents." }, visibility: { type: "boolean", description: "Boolean property determining whether the layer is initially visible in the scene.", default: true } }, required: ["id", "layerType", "path", "title"], additionalProperties: false }, "sceneLayer_schema.json": { title: "Scene Layer (ArcGISSceneServiceLayer)", type: "object", description: "The SceneLayer is a layer type designed for on-demand streaming and displaying large amounts of data in a SceneView. SceneLayers support two geometry types: Point and 3D Objects (e.g. buildings). The SceneLayer displays data published to a Scene Service. Scene Services can hold large volumes of features in an open format that is suitable for web streaming. The SceneLayer loads these features progressively, starting from coarse representations and refines them to higher detail as necessary for close-up views.", properties: { disablePopup: { type: "boolean", description: "disablePopups allows a client to ignore popups defined by the service item." }, id: { type: "string", description: "A unique identifying string for the layer." }, itemId: { type: "string", description: "Optional string containing the item ID of the service if it's registered on ArcGIS Online or your organization's portal." }, layerDefinition: { type: "object", description: "A layerDefinition object defining the attribute schema and drawing information for the layer.", allOf: [{ $ref: "#/definitions/layerDefinition_schema.json" }, { properties: { definitionExpression: {}, drawingInfo: { allOf: [{ $ref: "#/definitions/drawingInfo_schema.json" }, { properties: { labelingInfo: {}, renderer: {}, transparency: {} }, additionalProperties: false }] }, elevationInfo: {}, featureReduction: {}, minScale: {}, maxScale: {}, rangeInfos: {} }, additionalProperties: false }] }, layerType: { type: "string", description: "String indicating the layer type.", enum: ["ArcGISSceneServiceLayer"] }, listMode: { type: "string", description: "To show or hide layers in the layer list", enum: ["hide", "show"] }, opacity: { type: "number", description: "The degree of transparency applied to the layer on the client side, where 0 is full transparency and 1 is no transparency.", minimum: 0, maximum: 1, default: 1 }, path: { type: "string", description: "For offline data, a path to a scene layer package file. A URI format is used, starting with `file:` followed by a file system path with an extension of `.slpk`. A relative path must be from the file which defines the layer. For example `file:../p20/northamerica.slpk`.", pattern: "^file:.+\\.slpk$" }, popupInfo: { type: "object", description: "A popupInfo object defining the content of pop-up windows when you click or query a feature.", $ref: "#/definitions/popupInfo_schema.json" }, screenSizePerspective: { type: "boolean", description: "Apply [perspective scaling](https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-FeatureLayer.html#screenSizePerspectiveEnabled) to screen-size symbols.", default: false }, showLabels: { type: "boolean", description: "If the layer has a labelingInfo property then labels show on the scene only if the showLabels property it true.", default: false }, showLegend: { type: "boolean", description: "Boolean value indicating whether to display the layer in the legend. Default value is `true`.", default: true }, title: { type: "string", description: "A user-friendly string title for the layer that can be used in a table of contents." }, url: { type: "string", description: "The URL to the service." }, visibility: { type: "boolean", description: "Boolean property determining whether the layer is initially visible in the web scene", default: true } }, anyOf: [{ required: ["id", "layerType", "title", "url"] }, { required: ["id", "layerType", "path", "title"] }], additionalProperties: false }, "tiledImageServiceLayer_schema.json": { title: "Tiled Image Service Layer (ArcGISTiledImageServiceLayer)", type: "object", description: "An ArcGIS Tiled Image Service layer displays content from an ArcGIS Server Image service that has been cached (tiled).", properties: { bandIds: { type: "array", description: "An array of bandIds that are visible for a multispectral dataset. It can specify bands to export or rearrange band order(from image service).", items: { type: "integer" }, minItems: 1 }, disablePopup: { type: "boolean", description: "Indicates whether to allow a client to ignore popups defined by the service item." }, id: { type: "string", description: "A unique identifying string for the layer." }, interpolation: { type: "string", description: "String indicating the interpolation type.", enum: ["RSP_BilinearInterpolation", "RSP_CubicConvolution", "RSP_Majority", "RSP_NearestNeighbor"] }, isReference: { type: "boolean", description: "Applicable if used as a baseMapLayer. A boolean value indicating whether or not the baseMapLayer draws on top (true) of other layers, including operationalLayers , or below (false)." }, itemId: { type: "string", description: "Optional string containing the item ID of the service if it's registered on ArcGIS Online or your organization's portal." }, layerDefinition: { allOf: [{ $ref: "#/definitions/layerDefinition_schema.json" }, { properties: { drawingInfo: { allOf: [{ $ref: "#/definitions/drawingInfo_schema.json" }, { properties: { renderer: {}, transparency: {} }, additionalProperties: false }] } }, additionalProperties: false }] }, layerType: { type: "string", description: "String indicating the layer type.", enum: ["ArcGISTiledImageServiceLayer"] }, listMode: { type: "string", description: "To show or hide the sublayer in the layer list.", enum: ["hide", "show"] }, maxScale: { type: "number", description: "A number representing the maximum scale at which the layer will be visible. The number is the scale's denominator.", minimum: 0 }, minScale: { type: "number", description: "A number representing the minimum scale at which the layer will be visible. The number is the scale's denominator.", minimum: 0 }, multidimensionalDefinition: { type: "array", description: "An array of objects representing a slice from multidimensional data.", items: { type: "object", $ref: "#/definitions/multidimensionalDefinition_schema.json" } }, opacity: { type: "number", description: "The degree of transparency applied to the layer on the client side, where 0 is full transparency and 1 is no transparency.", minimum: 0, maximum: 1, default: 1 }, popupInfo: { type: "object", description: "A popupInfo object defining the content of popup windows when you click on the image.", $ref: "#/definitions/popupInfo_schema.json" }, refreshInterval: { type: "number", description: "Refresh interval of the layer in minutes. Non-zero value indicates automatic layer refresh at the specified interval. Value of 0 indicates auto refresh is not enabled." }, showLegend: { type: "boolean", description: "Boolean value indicating whether to display the layer in the legend. Default value is `true`.", default: true }, title: { type: "string", description: "A user-friendly string title for the layer that can be used in a table of contents." }, url: { type: "string", description: "URL to the ArcGIS Server Image Service." }, visibility: { type: "boolean", description: "Boolean property determining whether the layer is initially visible.", default: true } }, required: ["id", "layerType", "title", "url"], additionalProperties: false }, "tiledMapServiceLayer_schema.json": { title: "Tiled Map Service Layer (ArcGISTiledMapServiceLayer)", type: "object", description: "An ArcGIS Tiled Map Service layer displays map content from an ArcGIS Server Map service that has been cached (tiled).", properties: { id: { type: "string", description: "A unique identifying string for the layer." }, isReference: { type: "boolean", description: "This property is applicable if used as a baseMapLayer. A boolean value indicating whether or not the baseMapLayer draws on top (true) of other layers, including operationalLayers , or below (false)." }, itemId: { type: "string", description: "Optional string containing the item ID of the service if it's registered on ArcGIS Online or your organization's portal." }, layerType: { type: "string", description: "String indicating the layer type.", enum: ["ArcGISTiledMapServiceLayer"] }, layers: { type: "array", description: "An array of layer objects defining a URL for queries and the popup window content.", items: { allOf: [{ $ref: "#/definitions/layer_schema.json" }, { properties: { disablePopup: {}, id: {}, popupInfo: {}, showLegend: {}, listMode: {}, layerUrl: {}, name: {} }, additionalProperties: false }] }, uniqueItems: true }, listMode: { type: "string", description: "To show or hide the sublayer in the layer list. If the layer has sublayers, selecting `hide-children` will hide them in the layer list.", enum: ["hide", "hide-children", "show"] }, maxScale: { type: "number", description: "A number representing the maximum scale at which the layer will be visible. The number is the scale's denominator.", minimum: 0 }, minScale: { type: "number", description: "A number representing the minimum scale at which the layer will be visible. The number is the scale's denominator.", minimum: 0 }, opacity: { type: "number", description: "The degree of transparency applied to the layer on the client side, where 0 is full transparency and 1 is no transparency.", minimum: 0, maximum: 1, default: 1 }, path: { type: "string", description: "For offline data, a path to a tile package file. A URI format is used, starting with `file:` followed by a file system path with an extension of `.tpk` or `.tpkx`. A relative path must be from the file which defines the layer. For example `file:../p20/northamerica.tpk`.", pattern: "^file:.+\\.tpkx?$" }, refreshInterval: { type: "number", description: "Refresh interval of the layer in minutes. Non-zero value indicates automatic layer refresh at the specified interval. Value of 0 indicates auto refresh is not enabled.", default: 0 }, showLegend: { type: "boolean", description: "Boolean value indicating whether to display the layer in the legend. Default value is `true`.", default: true }, title: { type: "string", description: "A user-friendly string title for the layer that can be used in a table of contents. If this is not included, a title is derived from the service." }, url: { type: "string", description: "URL to the ArcGIS Server tiled Map Service" }, visibility: { type: "boolean", description: "Boolean property determining whether the layer is initially visible in the map.", default: true } }, anyOf: [{ required: ["id", "layerType", "title", "url"] }, { required: ["id", "layerType", "path", "title"] }], additionalProperties: false }, "vectorTileLayer_schema.json": { title: "Vector Tile Layer (VectorTileLayer)", type: "object", description: "A vector tile layer references a set of web-accessible vector tiles and the corresponding style for how those tiles should be drawn.", properties: { id: { type: "string", description: "A unique identifying string for the layer." }, isReference: { type: "boolean", description: "This property is applicable if used as a baseMapLayer. A boolean value indicating whether or not the baseMapLayer draws on top (true) of other layers, including operationalLayers, or below (false)." }, itemId: { type: "string", description: "Optional string containing the item ID of the service if it's registered on ArcGIS Online or your organization's portal." }, layerType: { type: "string", description: "String indicating the layer type.", enum: ["VectorTileLayer"] }, listMode: { type: "string", description: "To show or hide the layer in the layer list", enum: ["hide", "show"] }, maxScale: { type: "number", description: "A number representing the maximum scale at which the layer will be visible. The number is the scale's denominator." }, minScale: { type: "number", description: "A number representing the minimum scale at which the layer will be visible. The number is the scale's denominator." }, opacity: { type: "number", description: "The degree of transparency applied to the layer on the client side, where 0 is full transparency and 1 is no transparency.", minimum: 0, maximum: 1, default: 1 }, styleUrl: { type: "string", description: "A url to a JSON file containing the stylesheet information used to render the layer. You may also pass an object containing the stylesheet information identical to the JSON file." }, title: { type: "string", description: "A user-friendly string title for the layer that can be used in a table of contents." }, visibility: { type: "boolean", description: "Boolean property determining whether the layer is initially visible.", default: true } }, required: ["id", "layerType", "styleUrl", "title"], additionalProperties: false }, "webTiledLayer_schema.json": { title: "Web Tiled Layer (WebTiledLayer)", type: "object", description: "A tile layer is a derived from a set of web-accessible tiles which reside on a server. The tiles are accessed by a direct URL request from the web browser. Because the tiles in a tile layer are not available as a service, they must be in a specific format for a web app such as the ArcGIS.com scene viewer to display the layer on a scene.", properties: { copyright: { type: "string", description: "Attribution to the Web Tiled Layer provider. It is displayed in the attribution on the web scene. Input required by the user when the layer is added to the web scene." }, fullExtent: { type: "object", description: "An extent object representing the full extent envelope for the layer.", $ref: "#/definitions/extent_schema.json" }, id: { type: "string", description: "A unique identifying string for the layer." }, isReference: { type: "boolean", description: "This is applicable if used as a basesceneLayer. A boolean value indicating whether or not the basesceneLayer draws on top (true) of other layers, including operationalLayers , or below (false)." }, itemId: { type: "string", description: "Unique string value indicating an item registered in ArcGIS Online or your organization's portal." }, layerType: { type: "string", description: "String indicating the layer type.", enum: ["WebTiledLayer"] }, listMode: { type: "string", description: "To show or hide the layer in the layer list", enum: ["hide", "show"] }, maxScale: { type: "number", description: "A number representing the maximum scale at which the layer will be visible. The number is the scale's denominator.", minimum: 0 }, minScale: { type: "number", description: "A number representing the minimum scale at which the layer will be visible. The number is the scale's denominator.", minimum: 0 }, opacity: { type: "number", description: "The degree of transparency applied to the layer on the client side, where 0 is full transparency and 1 is no transparency.", minimum: 0, maximum: 1, default: 1 }, refreshInterval: { type: "number", description: "Refresh interval of the layer in minutes. Non-zero value indicates automatic layer refresh at the specified interval. Value of 0 indicates auto refresh is not enabled." }, subDomains: { type: "array", description: "If subdomains are detected, they must be specified. The scene viewer detects if the Web Tiled Layer has subdomains by parsing the templateURL value for {subDomain}.", items: { type: "string" } }, templateUrl: { type: "string", description: "URL to the Web Tiled Layer. Input required by the user when the layer is added to the web scene. The template URL contains a parameterized URL. The URL can contain the following templated parameters: `level`, `col`, `row`, and `subDomain`." }, tileInfo: { type: "object", description: "Contains the spatial reference and the tiling scheme of the layer. Typically retrieved from a WMTS OGC Web Service. If missing the layer must be in the WGS 1984 Web Mercator (Auxiliary Sphere) tiling scheme.", $ref: "#/definitions/tileInfo_schema.json" }, title: { type: "string", description: "A user-friendly string title for the layer that can be used in a table of contents." }, visibility: { type: "boolean", description: "Boolean property determining whether the layer is initially visible in the web scene.", default: true }, wmtsInfo: { type: "object", description: "Object containing information about the chosen WMTS service layer and tiling schema.", $ref: "#/definitions/wmtsInfo_schema.json" } }, required: ["id", "layerType", "title"], additionalProperties: false }, "wmsLayer_schema.json": { title: "WMS Layer (WMS)", type: "object", description: "A layer consuming a Web Map Service (WMS). The WMS specification is an international specification for serving and consuming dynamic maps on the web.", properties: { copyright: { type: "string", description: "A string containing copyright and access information for a WMS layer. This is copied from the capabilities document exposed by the WMS service." }, customLayerParameters: { type: "object", description: "A sequence of custom parameters to WMS layer requests. These parameters are applied to `GetMap` and `GetFeatureInfo` requests. The `customLayerParameters` property takes precedence if `customParameters` is also present.", patternProperties: { ".*": { type: "string" } } }, customParameters: { type: "object", description: "A sequence of custom parameters to all WMS requests. These parameters are applied to `GetCapabilities`, `GetMap`, and `GetFeatureinfo` requests. If used with the `customLayerParameters` property, `customParameters` will not take precedence.", patternProperties: { ".*": { type: "string" } } }, extent: { type: "array", description: "The minimum bounding rectangle, in decimal degrees, of the area covered by the layer as specified in the capabilities.", items: { type: "array", items: { type: "number" }, minItems: 2, maxItems: 2 }, minItems: 2, maxItems: 2 }, featureInfoFormat: { type: "string", description: "Format of the feature, e.g.`text/plain`" }, featureInfoUrl: { type: "string", description: "The URL for the WMS GetFeatureInfo call." }, format: { type: "string", description: "A string containing the image format to be requested from a WMS service. Default is `png`.", enum: ["bmp", "gif", "jpg", "png", "svg"], default: "png" }, id: { type: "string", description: "A unique identifying string for the layer." }, isReference: { type: "boolean", description: "This is applicable if used as a baseMapLayer. A boolean value indicating whether or not the baseMapLayer draws on top (true) of other layers, including operationalLayers, or below (false).", default: false }, itemId: { type: "string", description: "Unique string value indicating an item registered in ArcGIS Online or your organization's portal." }, layerType: { type: "string", description: "String indicating the layer type.", enum: ["WMS"] }, layers: { type: "array", description: "An array of layer objects from the WMS service.", items: { type: "object", $ref: "#/definitions/wmsLayer_layer_schema.json" }, uniqueItems: true }, listMode: { type: "string", description: "To show or hide the sublayer in the layer list. If the layer has sublayers, selecting `hide-children` will hide them in the layer list.", enum: ["hide", "hide-children", "show"] }, mapUrl: { type: "string", description: "A string containing the URL of the WMS map. When using a WMS layer, you should also supply the url property. `mapUrl` is the URL returned by the capabilities to be used for the getMap requests." }, maxHeight: { type: "number", description: "A number defining the maximum height, in pixels, that should be requested from the service." }, maxScale: { type: "number", description: "A number representing the maximum scale at which the layer will be visible. The number is the scale's denominator.", minimum: 0 }, maxWidth: { type: "number", description: "A number defining the maximum width, in pixels, that should be requested from the service." }, minScale: { type: "number", description: "A number representing the minimum scale at which the layer will be visible. The number is the scale's denominator.", minimum: 0 }, opacity: { type: "number", description: "The degree of transparency applied to the layer on the client side, where 0 is full transparency and 1 is no transparency.", minimum: 0, maximum: 1, default: 1 }, refreshInterval: { type: "number", description: "Refresh interval of the layer in minutes. Non-zero value indicates automatic layer refresh at the specified interval. Value of 0 indicates auto refresh is not enabled." }, showLegend: { type: "boolean", description: "Boolean value indicating whether to display the layer in the legend." }, spatialReferences: { type: "array", description: "An array of numbers containing well-known IDs for spatial references supported by the service.", items: { type: "integer", description: "well-known ID" } }, title: { type: "string", description: "A user-friendly string title for the layer that can be used in a table of contents." }, url: { type: "string", description: "The URL to the WMS service (`getCapabilities` URL)." }, version: { type: "string", description: "A string containing the version number of the service." }, visibility: { type: "boolean", description: "Boolean property determining whether the layer is initially visible in the web map.", default: true }, visibleLayers: { type: "array", description: "An array of layers that should appear visible. The array contains the names of the visible layers.", items: { type: "string" }, uniqueItems: true } }, required: ["layerType", "title"], additionalProperties: false }, "slide_schema.json": { title: "slide", type: "object", description: "A slide object used within a presentation.", properties: { baseMap: { description: "The basemap to be displayed on the slide.", allOf: [{ $ref: "#/definitions/baseMap_schema.json" }, { properties: { baseMapLayers: {}, title: {}, id: {}, transparency: {} }, additionalProperties: false }] }, description: { type: "object", description: "Text description of the individual presentation slide.", $ref: "#/definitions/description_schema.json" }, environment: { type: "object", description: "Represents settings that affect the environment in which the web scene is displayed.", allOf: [{ $ref: "#/definitions/environment_schema.json" }, { properties: { lighting: {} }, additionalProperties: false }] }, ground: { description: "The ground properties to be set in the slide.", $ref: "#/definitions/slide_ground_schema.json" }, id: { type: "string", description: "The unique id of a slide within the slides property of a Presentation." }, thumbnail: { type: "object", $ref: "#/definitions/thumbnail_schema.json" }, title: { type: "object", $ref: "#/definitions/title_schema.json" }, viewpoint: { type: "object", $ref: "#/definitions/viewpoint_schema.json" }, visibleLayers: { type: "array", description: "An array of objects used to indicate the visible layers of the web scene.", items: { type: "object", $ref: "#/definitions/visibleLayer_schema.json" } } }, required: ["id", "thumbnail", "title", "viewpoint", "visibleLayers"], additionalProperties: false }, "definitionEditor_schema.json": { title: "definitionEditor", type: "object", description: "The definitionEditor stores interactive filters at the same level as layerDefinition.", properties: { inputs: { type: "array", description: "An array of input objects.", items: { type: "object", $ref: "#/definitions/input_schema.json" } }, parameterizedExpression: { type: "string", description: "A string value representing the where clause for the interactive filter." } }, additionalProperties: false }, "range_schema.json": { title: "Range", description: "Range object.", properties: { interactionMode: { type: "string", description: "Indicates the mode in which the active range should be presented to the user.", enum: ["picker", "slider"] }, numberOfStops: { type: "integer", description: "This is used to generate the activeRangeValues if activeRangeValues are not specified." }, stopInterval: { type: "number", description: "Interval in which stops should be generated." } }, oneOf: [{ required: ["interactionMode", "numberOfStops"] }, { required: ["interactionMode", "stopInterval"] }], additionalProperties: false }, "buildingSceneLayer_filterAuthoringInfoCheckbox_schema.json": { title: "Metadata for checkbox based filter UI", type: "object", description: "Client UI with checkbox representation for each filter type and filter value.", properties: { filterBlocks: { type: "array", description: "Array of filter block authoring infos.", items: { type: "object", $ref: "#/definitions/buildingSceneLayer_filterAuthoringInfo_filterBlock_schema.json" } }, type: { type: "string", description: "Type of filter authoring info.", enum: ["checkbox"] } }, required: ["filterBlocks", "type"], additionalProperties: false }, "buildingSceneLayer_filterBlock_schema.json": { title: "Building Scene Layer Filter Block", type: "object", description: "A filter block defines what elements will be filtered with a specific filter mode.  To ensure performance on client applications, it is not recommended to declare multiple filter blocks with the same filter mode. Filter blocks are contained in a filter for a building scene layer. Each filter includes at least one filter block.", properties: { filterExpression: { type: "string", description: "SQL expression to select features that belong to this filter block." }, filterMode: { type: "object", $ref: "#/definitions/buildingSceneLayer_filterMode_schema.json" }, title: { type: "string", description: "Title of the filter block." } }, required: ["filterExpression", "filterMode", "title"], additionalProperties: false }, "elevationInfo_schema.json": { title: "elevationInfo", type: "object", description: "Elevation info defines how features are aligned to ground or other layers.", properties: { featureExpression: { type: "object", description: '<em>Deprecated with 1.8, use `featureExpressionInfo` instead</em>. `{"value":0}` ignores geometry z-values.', properties: { value: { type: "number", enum: [0] } }, minProperties: 1, additionalProperties: false }, featureExpressionInfo: { type: "object", description: "An object that defines an expression for per-feature elevation. If not set, geometry.z values are used for elevation. `unit` is applied to the resulting expression value.", $ref: "#/definitions/featureExpressionInfo_schema.json" }, mode: { type: "string", description: "Determines how the service elevation values are combined with the elevation of the scene.", enum: ["absoluteHeight", "onTheGround", "relativeToGround", "relativeToScene"] }, offset: { type: "number", description: "Offset is always added to the result of the above logic except for onTheGround where offset is ignored." }, unit: { type: "string", description: 'A string value indicating the unit for the values in elevationInfo. Applies to both `offset` and `featureExpressionInfo`. Defaults to `meter` if not set. <a href="#unit"><sup>1</sup></a>', default: "meter" } }, required: ["mode"], additionalProperties: false }, "featureReduction_select_schema.json": { title: "Feature Reduction: Selection", type: "object", description: "Feature reduction of type `selection` declutters the screen by hiding features that would otherwise intersect with other features on screen. The default behavior of this feature reduction type is to select features by depth order, i.e. hide all features that would otherwise be overlapped by at least one other feature which is closer to the viewer.", properties: { type: { type: "string", description: "A string value indicating the feature reduction type.", enum: ["selection"] } } }, "field_schema.json": { title: "field", type: "object", description: "Contains information about an attribute field.", properties: { alias: { type: "string", description: "A string defining the field alias." }, defaultValue: { type: ["null", "number", "string"], description: "The default value set for the field." }, domain: { type: "object", description: "The domain objects if applicable.", $ref: "#/definitions/domain_schema.json" }, editable: { type: "boolean", description: "A Boolean defining whether this field is editable." }, length: { type: "integer", description: "A number defining how many characters are allowed in a string field." }, name: { type: "string", description: "A string defining the field name." }, nullable: { type: "boolean", description: "A Boolean defining whether this field can have a null value." }, type: { type: "string", description: "A string defining the field type.", enum: ["esriFieldTypeBlob", "esriFieldTypeDate", "esriFieldTypeDouble", "esriFieldTypeGUID", "esriFieldTypeGeometry", "esriFieldTypeGlobalID", "esriFieldTypeInteger", "esriFieldTypeLong", "esriFieldTypeOID", "esriFieldTypeRaster", "esriFieldTypeSingle", "esriFieldTypeSmallInteger", "esriFieldTypeString", "esriFieldTypeXML"] } }, additionalProperties: false }, "pointCloudFilter_schema.json": { title: "PointCloud Filter", type: "object", description: "Filters applied to the pointCloud which will hide a point.", oneOf: [{ $ref: "#/definitions/pointCloudBitfieldFilter_schema.json" }, { $ref: "#/definitions/pointCloudReturnFilter_schema.json" }, { $ref: "#/definitions/pointCloudValueFilter_schema.json" }] }, "rangeInfo_schema.json": { title: "Range Information", description: "Range Information.", properties: { currentRangeExtent: { type: "array", description: "Contains the min and max values within which the features are visible.", items: { type: "number" }, minItems: 2, maxItems: 2 }, field: { type: "string", description: "Field name to used for the range." }, fullRangeExtent: { type: "array", description: "Contains the min and max values of all the features for this rangeInfo.", items: { type: "number" }, minItems: 2, maxItems: 2 }, name: { type: "string", description: "A unique name that can be referenced by webMap.activeRanges." }, type: { type: "string", description: "Type of range object.", enum: ["rangeInfo"] } }, required: ["field", "name", "type"], additionalProperties: false }, "source_schema.json": { title: "source", type: "object", description: "Contains [dynamicDataLayer](dynamicDataLayer_source.md) object and [dynamicMapLayer](dynamicDataLayer_source.md) object. If the service supports dynamic layers, the [layerDefinition's ](layerDefinition.md) source property must be specified.", oneOf: [{ $ref: "#/definitions/dynamicDataLayer_source_schema.json" }, { $ref: "#/definitions/dynamicMapLayer_source_schema.json" }] }, "type_schema.json": { title: "type", type: "object", description: "Contains information about an attribute field.", properties: { domains: { type: "object", description: "A comma-delimited series of domain objects for each domain in the type.", patternProperties: { ".*": { type: "object", $ref: "#/definitions/domain_schema.json" } } }, id: { type: ["number", "string"], description: "A unique string or numerical ID for the type." }, name: { type: "string", description: "A user-friendly name for the type." }, templates: { type: "array", description: "Defined as a property of the layer definition when there are no types defined; otherwise, templates are defined as properties of the types.", items: { type: "object", $ref: "#/definitions/template_schema.json" }, uniqueItems: true } }, required: ["id"], additionalProperties: false }, "popupExpressionInfo_schema.json": { title: "popupExpressionInfo", description: "Arcade expression added to the pop-up.", properties: { expression: { type: "string", description: "The Arcade expression." }, name: { type: "string", description: "Unique identifier for the expression." }, returnType: { type: "string", description: "Return type of the Arcade expression, can be number or string. Defaults to string value. Number values are assumed to be `double`. This can be determined by the authoring client by executing the expression using a sample feature(s), although it can be corrected by the user. Knowing the returnType allows the authoring client to present fields in relevant contexts. For example, numeric fields in numeric contexts such as charts.", enum: ["number", "string"] }, title: { type: "string", description: "Title of the expression." } }, additionalProperties: false }, "fieldInfo_schema.json": { title: "fieldInfo", type: "object", description: "Defines how a field in the dataset participates (or does not participate) in a popup window.", properties: { fieldName: { type: "string", description: "A string containing the field name as defined by the service. Anywhere that a fieldname is referenced as `{field-name} in popupInfo, an Arcade expression can also be referenced as `{expression/<expression-name>}`." }, format: { type: "object", description: "A format object used with numerical or date fields to provide more detail about how the value should be displayed in a popup window.", $ref: "#/definitions/format_schema.json" }, isEditable: { type: "boolean", description: "A Boolean determining whether users can edit this field. Not applicable to Arcade expressions.", default: false }, label: { type: "string", description: "A string containing the field alias. This can be overridden by the web map author. Not applicable to Arcade expressions as `title` is used instead." }, statisticType: { type: "string", description: "Used in a 1:many or many:many relationship to compute the statistics on the field to show in the popup.", enum: ["avg", "count", "max", "min", "stddev", "sum", "var"] }, stringFieldOption: { type: "string", description: "A string determining what type of input box editors see when editing the field. Applies only to string fields. Not applicable to Arcade expressions.", enum: ["richtext", "textarea", "textbox"], default: "textbox" }, tooltip: { type: "string", description: "A string providing an editing hint for editors of the field. Not applicable to Arcade expressions." }, visible: { type: "boolean", description: "A Boolean determining whether the field is visible in the popup window." } }, additionalProperties: false }, "popupLayerOptions_schema.json": { title: "Layer Options", type: "object", description: "Additional options available for the popup layer.", properties: { returnTopmostRaster: { type: "boolean", description: "Indicates whether or not only the topmost raster should be displayed." }, showNoDataRecords: { type: "boolean", description: "Indicates whether or not the NoData records should be displayed." } } }, "mediaInfo_schema.json": { title: "mediaInfo", type: "object", description: "Defines an image or a chart to be displayed in a popup window.", oneOf: [{ $ref: "#/definitions/mediaInfo_chart_schema.json" }, { $ref: "#/definitions/mediaInfo_image_schema.json" }] }, "popupElement_schema.json": { title: "popupElement", type: "object", description: "Popup elements allow users to author popups, using multiple elements such as tabular views, string description, media (charts and images), and attachments of the attributes and control the order in which they appear. Specifically, popupElements do the following: 1) provide the ability to explicitly add a field/ value table in addition to a description, 2) allow adding multiple description elements, and 3) allow a user to author and consume elements of a popup in the order of their choosing.", oneOf: [{ $ref: "#/definitions/popupElement_attachments_schema.json" }, { $ref: "#/definitions/popupElement_fields_schema.json" }, { $ref: "#/definitions/popupElement_media_schema.json" }, { $ref: "#/definitions/popupElement_text_schema.json" }] }, "relatedRecordsInfo_schema.json": { title: "relatedRecordsInfo", type: "object", description: "The sort in the popupInfo for the parent feature. This impacts the sorting order for the returned child records.", properties: { orderByFields: { type: "array", description: "Array of orderByFields objects indicating the field display order for the related records and whether they should be sorted in ascending `asc` or descending `desc` order.", items: { type: "object", $ref: "#/definitions/orderByFields_schema.json" } }, showRelatedRecords: { type: "boolean", description: "Required boolean value indicating whether to display related records. If <code>true</code>, client should let the user navigate to the related records. Defaults to <code>true</code> if the layer participates in a relationship AND the related layer/table has already been added to the scene (either as an operationalLayer or as a table)." } } }, "labelingInfo_schema.json": { title: "labelingInfo", type: "object", description: "The labelingInfo object specifies the label definition for a layer.", properties: { labelExpression: { type: "string", description: "Defines the expression for text of labels. <em>Deprecated on FeatureLayer, Use `labelExpressionInfo` instead.</em>" }, labelExpressionInfo: { type: "object", $ref: "#/definitions/labelExpressionInfo_schema.json" }, labelPlacement: { type: "string", description: "This string property specifies the label placement with respect to that of its feature. A list of label placement values categorized by feature geometry types.", enum: ["esriServerLinePlacementAboveAfter", "esriServerLinePlacementAboveAlong", "esriServerLinePlacementAboveBefore", "esriServerLinePlacementAboveEnd", "esriServerLinePlacementAboveStart", "esriServerLinePlacementBelowAfter", "esriServerLinePlacementBelowAlong", "esriServerLinePlacementBelowBefore", "esriServerLinePlacementBelowEnd", "esriServerLinePlacementBelowStart", "esriServerLinePlacementCenterAfter", "esriServerLinePlacementCenterAlong", "esriServerLinePlacementCenterBefore", "esriServerLinePlacementCenterEnd", "esriServerLinePlacementCenterStart", "esriServerPointLabelPlacementAboveCenter", "esriServerPointLabelPlacementAboveLeft", "esriServerPointLabelPlacementAboveRight", "esriServerPointLabelPlacementBelowCenter", "esriServerPointLabelPlacementBelowLeft", "esriServerPointLabelPlacementBelowRight", "esriServerPointLabelPlacementCenterCenter", "esriServerPointLabelPlacementCenterLeft", "esriServerPointLabelPlacementCenterRight", "esriServerPolygonPlacementAlwaysHorizontal"] }, maxScale: { type: "number", description: "Represents the maximum scale at which the layer definition will be applied." }, minScale: { type: "number", description: "Represents the minimum scale at which the layer definition will be applied." }, name: { type: "string", description: "The name of the label class." }, symbol: { type: "object", description: "The text symbol used to label.", $ref: "#/definitions/labelSymbol3D_schema.json" }, useCodedValues: { type: "boolean", description: "Boolean value indicating whether to display the coded values for the specified field name(s)." }, where: { type: "string", description: "String template used to determine which features to label." } }, additionalProperties: false }, "renderer_schema.json": { title: "renderer", type: "object", description: "The renderer object contains the drawing information for the operationalLayer. This is a list of links to all the renderer objects.", oneOf: [{ $ref: "#/definitions/classBreaksRenderer_schema.json" }, { $ref: "#/definitions/pointCloudRenderers_schema.json" }, { $ref: "#/definitions/rasterRenderers_schema.json" }, { $ref: "#/definitions/simpleRenderer_schema.json" }, { $ref: "#/definitions/uniqueValueFromStyleRenderer_schema.json" }, { $ref: "#/definitions/uniqueValueRenderer_schema.json" }] }, "search_schema.json": { title: "search", type: "object", description: "An object specifying the search parameters set within the web scene.", properties: { enabled: { type: "boolean", description: "A boolean value indicating whether search functionality is enabled in the web scene.", default: true }, hintText: { type: "string", description: "A string value used to indicate the hint provided with the search dialog." }, layers: { type: "array", description: "An array of layers to be included in search.", items: { type: "object", $ref: "#/definitions/search_layer_schema.json" }, minItems: 1, uniqueItems: true } }, required: ["layers"], additionalProperties: false }, "openStreetMapLayer_schema.json": { title: "OpenStreetMap Layer (OpenStreetMap)", type: "object", description: "Allows use of OpenStreetMap data for use in basemaps only.", properties: { id: { type: "string", description: "An identifying string for the layer, unique per scene.", default: "defaultBasemap" }, layerType: { type: "string", description: "String indicating the layer type.", enum: ["OpenStreetMap"] }, listMode: { type: "string", description: "To show or hide layers in the layer list", enum: ["hide", "show"] }, maxScale: { type: "number", description: "A numeric property used to determine the maximum scale at which the layer is displayed.", minimum: 0 }, minScale: { type: "number", description: "A numeric property used to determine the minimum scale at which the layer is displayed.", minimum: 0 }, opacity: { type: "number", description: "The degree of transparency applied to the layer on the client side, where 0 is full transparency and 1 is no transparency.", minimum: 0, maximum: 1, default: 1 }, title: { type: "string", description: "String title for the basemap layer." }, visibility: { type: "boolean", description: "Boolean property determining whether the layer is initially visible.", default: true } }, required: ["id", "layerType", "title"], additionalProperties: false }, "rasterDataElevationLayer_schema.json": { title: "Raster Data Elevation Layer", type: "object", description: "RasterDataElevationLayer is a single-band raster layer used for rendering elevation.", properties: { id: { type: "string", description: "A unique identifying string for the layer" }, layerType: { type: "string", description: "String indicating the layer type", enum: ["RasterDataElevationLayer"] }, listMode: { type: "string", description: "To show or hide the elevation layer in the layer list", enum: ["hide", "show"] }, path: { type: "string", description: "For offline data, a path to an ArcGIS Runtime supported raster data file. A URI format is used, starting with file: followed by a file system path. A relative path must be from the file which defines the layer. For example `file:../commondata/raster_data/beijing.tif`", pattern: "^file:.+$" }, title: { type: "string", description: "A user-friendly string title for the layer that can be used in a table of contents. If this is not included, a title is derived from the service." }, visibility: { type: "boolean", description: "Boolean property determining whether the layer is initially visible in the web scene.", default: true } }, required: ["id", "layerType", "path", "title"], additionalProperties: false }, "tiledElevationLayer_schema.json": { title: "Tiled Elevation Layer", type: "object", description: "Tiled Elevation Layer is a tile layer used for rendering elevation.", properties: { id: { type: "string", description: "A unique identifying string for the layer" }, itemId: { type: "string", description: "Optional string containing the item ID of the service if it's registered on ArcGIS Online or your organization's portal." }, layerType: { type: "string", description: "String indicating the layer type", enum: ["ArcGISTiledElevationServiceLayer"] }, listMode: { type: "string", description: "To show or hide the elevation layer in the layer list", enum: ["hide", "show"] }, path: { type: "string", description: "For offline data, a path to a tile package containing elevation data. A URI format is used, starting with `file:` followed by a file system path with an extension of `.tpk` or `.tpkx`. A relative path must be from the file which defines the layer. For example `file:../p20/portland.tpk`.", pattern: "^file:.+\\.tpkx?$" }, title: { type: "string", description: "A user-friendly string title for the layer that can be used in a table of contents. If this is not included, a title is derived from the service." }, url: { type: "string", description: "The URL to the layer.If the layer is not from a web service but rather a feature collection, then the url property is omitted" }, visibility: { type: "boolean", description: "Boolean property determining whether the layer is initially visible in the web scene.", default: true } }, anyOf: [{ required: ["id", "layerType", "title", "url"] }, { required: ["id", "layerType", "path", "title"] }], additionalProperties: false }, "environment_background_color_schema.json": { title: "color background", type: "object", description: "Specifies a single color to fill the background of the scene with. The scene background is displayed behind any scene objects, stars and atmosphere.", properties: { color: { $ref: "#/definitions/color_schema.json" }, transparency: { type: "integer", description: "The value has to lie between `100` (full transparency) and `0` (full opacity).", minimum: 0, maximum: 100 }, type: { type: "string", description: "The type of background.", enum: ["color"] } }, required: ["color", "type"], default: { type: "color", color: [0, 0, 0] }, additionalProperties: false }, "lighting_schema.json": { title: "lighting", type: "object", description: "Object containing information on how the scene is lit.", properties: { datetime: { type: "number", description: "The current date and time of the simulated sun. It is a number representing the number of milliseconds since 1 January, 1970 UTC." }, directShadows: { type: "boolean", description: "Indicates whether to show shadows cast by the sun.", default: false }, displayUTCOffset: { type: "number", description: "UTC offset in decimal hours. Not to be applied to datetime for sun position, only to adjust display of datetime in UI. If displayUTCOffset is null, offset is calculated for the current location (approximate only)." } }, additionalProperties: false }, "camera_schema.json": { title: "Camera", type: "object", description: "The camera defines the position, tilt, and heading of the point from which the SceneView's visible extent is observed.", properties: { heading: { type: "number", description: "The heading of the camera in degrees. Heading is zero when north is the top of the screen. It increases as the view rotates clockwise." }, position: { description: "The position of the camera defined by a map point.", $ref: "#/definitions/point_geometry_schema.json" }, tilt: { type: "number", description: "The tilt of the camera in degrees with respect to the surface as projected down from the camera position. Tilt is zero when looking straight down at the surface and 90 degrees when the camera is looking parallel to the surface." } }, required: ["heading", "position", "tilt"], additionalProperties: false }, "geometry_schema.json": { title: "geometry", type: "object", description: "Please refer to the links below for objects which define the JSON formats of geometry and spatial reference objects.", oneOf: [{ $ref: "#/definitions/multipoint_geometry_schema.json" }, { $ref: "#/definitions/point_geometry_schema.json" }, { $ref: "#/definitions/polygon_geometry_schema.json" }, { $ref: "#/definitions/polyline_geometry_schema.json" }] }, "locationInfo_schema.json": { title: "locationInfo", type: "object", description: "Defines how location information will be retrieved from a [CSV](csvLayer.md) file referenced through the web, ie. referenced by URL.", properties: { latitudeFieldName: { type: "string", description: "A string defining the field name that holds the latitude (Y) coordinate." }, locationType: { type: "string", description: "String value indicating location type.", enum: ["coordinates"] }, longitudeFieldName: { type: "string", description: "A string defining the field name that holds the longitude (X) coordinate." } }, required: ["locationType"], additionalProperties: false }, "mosaicRule_schema.json": { title: "mosaicRule", type: "object", description: "The image service uses a mosaic rule to mosaick multiple rasters on the fly. The mosaic rule parameter is used by many image service operations, for example, export image and identify operations.", properties: { ascending: { type: "boolean", description: "Indicate whether to use ascending or descending order.", default: true }, fids: { type: "array", description: "A list that defines a subset of rasters used in the mosaic, be aware that the rasters may not be visible at all scales.", items: { type: "integer" } }, itemRenderingRule: { type: "object", description: "The rendering rule applies on items before mosaicking.", $ref: "#/definitions/renderingRule_schema.json" }, lockRasterIds: { type: "array", description: "Lock a few rasters in the image service. Used together with `esriMosaicLockRaster`.", items: { type: "integer" } }, mosaicMethod: { type: "string", description: "A string value that determines how the selected rasters are ordered.", enum: ["esriMosaicAttribute", "esriMosaicCenter", "esriMosaicLockRaster", "esriMosaicNadir", "esriMosaicNone", "esriMosaicNorthwest", "esriMosaicSeamline", "esriMosaicViewpoint"] }, mosaicOperation: { type: "string", description: "Use the mosaic operation to resolve overlap pixel values: from first or last raster, use the min, max or mean of the pixel values, or blend them.", enum: ["MT_BLEND", "MT_FIRST", "MT_LAST", "MT_MAX", "MT_MEAN", "MT_MIN", "MT_SUM"], default: "MT_FIRST" }, multidimensionalDefinition: { type: "array", description: "Definition of multidimentional variables.", items: { type: "object", $ref: "#/definitions/multidimensionalDefinition_schema.json" } }, sortField: { type: "string", description: "The field name used together with `esriMosaicAttribute` method." }, sortValue: { type: ["null", "number", "string"], description: "The base sort value used together with `esriMosaicAttribute` method and `sortField` parameter.", default: 0 }, viewpoint: { type: "object", description: "Use a view point along with `esriMosaicViewpoint`.", $ref: "#/definitions/point_geometry_schema.json" }, where: { type: "string", description: "<em>Deprecated. Use `layerDefinition.definitionExpression` instead.</em>" } }, required: ["mosaicMethod"], additionalProperties: false }, "renderingRule_schema.json": { title: "renderingRule", type: "object", description: "Specifies the rendering rule for how the requested image should be rendered.", properties: { outputPixelType: { type: "string", description: "the output pixel type defines the output image's pixel type.", enum: ["C128", "C64", "F32", "F64", "S16", "S32", "S8", "U1", "U16", "U2", "U32", "U4", "U8", "UNKNOWN"], default: "UNKNOWN" }, rasterFunction: { type: "string", description: "The raster function name identifies the processing or rendering to be performed. For a list of possible types, please see the [Raster Functions](http://resources.arcgis.com/en/help/arcgis-rest-api/#/Raster_Function_Objects/02r3000000rv000000/) help topic for additional information on this." }, rasterFunctionArguments: { type: "object", description: "The arguments for the referenced `rasterFunction`. For a description of arguments per raster function type, please see the [Raster Functions](http://resources.arcgis.com/en/help/arcgis-rest-api/#/Raster_Function_Objects/02r3000000rv000000/) help topic for additional information on this." }, variableName: { type: "string", description: "Variable name for the raster function." } }, additionalProperties: false }, "layer_schema.json": { title: "layer", type: "object", description: "A layer object may allow overrides on popup content and drawing behavior for individual layers of a web service. This object also contains geographic features and their attributes when used in a feature collection.", properties: { defaultVisibility: { type: "boolean", description: "Default visibility of the layers in the map service." }, disablePopup: { type: "boolean", description: "Indicates whether to allow a client to ignore the popups defined on the layer. The popupInfo object could be saved in the map or item.", default: false }, id: { type: "integer", description: "The layer id, as a numeric value." }, layerDefinition: { description: "Additional properties that define drawing information and other configurations for the layer.", allOf: [{ $ref: "#/definitions/layerDefinition_schema.json" }, { properties: { definitionExpression: {}, drawingInfo: { allOf: [{ $ref: "#/definitions/drawingInfo_schema.json" }, { properties: { labelingInfo: {}, renderer: {}, showLabels: {}, transparency: {} }, additionalProperties: false }] }, source: {} }, additionalProperties: false }] }, layerUrl: { type: "string", description: "A URL to a service that should be used for all queries against the layer." }, listMode: { type: "string", description: "To show or hide the sublayer in the layer list. If the layer has sublayers, selecting `hide-children` will hide them in the layer list.", enum: ["hide", "hide-children", "show"] }, maxScale: { type: "number", description: "A number representing the maximum scale at which the layer will be visible. The number is the scale's denominator." }, minScale: { type: "number", description: "A number representing the minimum scale at which the layer will be visible. The number is the scale's denominator." }, name: { type: "string", description: "The name of the layer." }, parentLayerId: { type: "integer", description: "If working with nested layers, this is the numeric value indicating the layer id of the next layer (parent) directly above the current referenced layer." }, popupInfo: { type: "object", description: "A popupInfo object defining the popup window content for the layer.", $ref: "#/definitions/popupInfo_schema.json" }, showLegend: { type: "boolean", description: "A Boolean indicating if the layer should be shown in the legend in client applications.", default: true }, subLayerIds: { type: "array", description: "If the layer is a parent layer, it will have one or more sub layers included in an array.", items: { type: "integer" } } }, additionalProperties: false }, "multidimensionalDefinition_schema.json": { title: "Multi-dimensional Definition", type: "object", properties: { dimensionName: { type: "string", description: "Type of dimension being used (ex. StdTime)." }, isSlice: { type: "boolean", description: "Is slice?", default: true }, values: { type: "array", description: "Array where every element is either a single value, or an array of two values (lower and upper bound).", items: { oneOf: [{ type: "number" }, { type: "array", items: { type: "number" }, minItems: 2, maxItems: 2 }] } }, variableName: { type: "string", description: "Name of the variable." } }, anyOf: [{ required: ["variableName"] }, { required: ["dimensionName", "values"] }], additionalProperties: false, dependencies: { dimensionName: ["values"], values: ["dimensionName"] } }, "tileInfo_schema.json": { title: "tileInfo", type: "object", description: "Tile information, returned from the WMTS OGC Web Service. The tileInfo will contain the spatial reference of the layer. tileInfo is the same json representation as the ArcGIS Map/Image service tileInfo except that it may contain a levelValue on the lod objects that should be used instead of the level in the templateUrl.", properties: { cols: { type: "integer", description: "Requested tile's column." }, compressionQuality: { type: "number", description: "Compression quality of the tile.", minimum: 0, maximum: 100 }, dpi: { type: "number", description: "The dpi of the tiling scheme." }, lods: { type: "array", description: "An array of levels of detail that define the tiling scheme.", items: { type: "object", $ref: "#/definitions/lod_schema.json" }, uniqueItems: true }, origin: { type: "object", description: "The tiling scheme origin.", $ref: "#/definitions/point_geometry_schema.json" }, rows: { type: "integer", description: "Requested tile's row." }, spatialReference: { type: "object", description: "The spatial reference of the tiling schema.", $ref: "#/definitions/spatialReference_schema.json" } }, additionalProperties: false }, "wmtsInfo_schema.json": { title: "Web Map Tile Service Info", type: "object", description: "Object defines and provides information about layers in a [WMTSLayer](webTiledLayer.md) service.", properties: { customLayerParameters: { type: "object", description: "A sequence of parameters used to append different custom parameters to a WMTS tile request. These parameters are applied to `GetTile`. The `customLayerParameters` property takes precedence if `customParameters` is also present.", patternProperties: { ".*": { type: "string" } } }, customParameters: { type: "object", description: "A sequence of parameters used to append custom parameters to all WMTS requests. These parameters are applied to `GetCapabilities` and `GetTile`. If used with the `customLayerParameters` property, `customParameters` will not take precedence.", patternProperties: { ".*": { type: "string" } } }, layerIdentifier: { type: "string", description: "Identifier for the specific layer used in the WMTS service. Required input by the user." }, tileMatrixSet: { type: "string", description: "Tiling schema, set by the WMTS service." }, url: { type: "string", description: "URL to the WMTS web service. Required input by the user." } }, additionalProperties: false }, "wmsLayer_layer_schema.json": { title: "WMSLayer layer", type: "object", description: "A layer object may allow overrides on popup content and drawing behavior for individual layers of a web service.", properties: { legendUrl: { type: "string", description: "A string URL to a legend graphic for the layer." }, name: { type: "string", description: "A string containing a unique name for the layer." }, queryable: { type: "boolean", description: "Boolean specifying whether a layer is queryable or not." }, showPopup: { type: "boolean", description: "Boolean specifying whether to display popup or not." }, title: { type: "string", description: "A user-friendly string title for the layer that can be used in a table of contents." } }, additionalProperties: false }, "description_schema.json": { title: "description", type: "object", description: "Description object with text.", properties: { text: { type: "string", description: "Text to display as slide description." } }, required: ["text"], additionalProperties: false }, "slide_ground_schema.json": { title: "Ground", type: "object", description: "Ground defines the main surface of the web scene, based on elevation layers. This object defines the ground properties to be set in the slides.", properties: { transparency: { type: "integer", description: "The transparency of the ground surface (including basemap). The value has to lie between `100` (full transparency) and `0` (full opacity).", minimum: 0, maximum: 100 } }, additionalProperties: false }, "thumbnail_schema.json": { title: "thumbnail", type: "object", description: "Object containing a thumbnail image.", properties: { url: { type: "string", description: "The URI pointing to the thumbnail image. Can be a URL or a base64-encoded image." } }, required: ["url"], additionalProperties: false }, "title_schema.json": { title: "title", type: "object", description: "Text for the title of the individual slide.", properties: { text: { type: "string", description: "Text to display as slide title." } }, required: ["text"], additionalProperties: false }, "visibleLayer_schema.json": { title: "visibleLayer", type: "object", description: "Object with layer id, used to indicate layer visibility in a slide.", properties: { id: { type: "string", description: "The id of the layer as listed on the operational layer." }, subLayerIds: { type: "array", description: "List of visible sublayer ids, as listed on the service of the layer.", items: { type: "integer" } } }, additionalProperties: false }, "input_schema.json": { title: "input", type: "object", description: "The input objects specified by the [definitionEditor](definitionEditor.md).", properties: { hint: { type: "string", description: "A string value representing a hint for the input." }, parameters: { type: "array", description: "An array of parameter objects.", items: { type: "object", $ref: "#/definitions/parameter_schema.json" } }, prompt: { type: "string", description: "A string value representing the prompt for the input." } }, additionalProperties: false }, "buildingSceneLayer_filterAuthoringInfo_filterBlock_schema.json": { title: "Filter Authoring Info for Filter Blocks", type: "object", description: "The filter authoring info object contains metadata about the authoring process for creating a filter block object. This allows the authoring client to save specific, overridable settings.  The next time it is accessed via an authoring client, their selections are remembered. Non-authoring clients can ignore it.", properties: { filterTypes: { type: "array", description: "Array of defined filter types. Each filter type has an array of filter values.", items: { type: "object", $ref: "#/definitions/buildingSceneLayer_filterAuthoringInfo_filterType_schema.json" } } }, required: ["filterTypes"], additionalProperties: false }, "buildingSceneLayer_filterMode_schema.json": { title: "Filter Mode", type: "object", description: "Filter mode represents the way elements draw when participating in a filter block.", oneOf: [{ $ref: "#/definitions/buildingSceneLayer_filterModeSolid_schema.json" }, { $ref: "#/definitions/buildingSceneLayer_filterModeWireFrame_schema.json" }, { $ref: "#/definitions/buildingSceneLayer_filterModeXray_schema.json" }] }, "featureExpressionInfo_schema.json": { title: "featureExpressionInfo", type: "object", description: "An object that defines an expression for per-feature elevation.", properties: { expression: { type: "string", description: "An [Arcade expression](https://developers.arcgis.com/arcade/) evaluating to a number.", minLength: 1 }, title: { type: "string", description: "Title of the expression.", minLength: 1 } }, required: ["expression"], additionalProperties: false }, "domain_schema.json": { title: "domain", type: "object", description: "Domains specify the set of valid values for a field. The links below are the available domains.", oneOf: [{ $ref: "#/definitions/codedValue_domain_schema.json" }, { $ref: "#/definitions/inherited_domain_schema.json" }, { $ref: "#/definitions/range_domain_schema.json" }] }, "pointCloudBitfieldFilter_schema.json": { title: "PointCloud Bitfield Filter", type: "object", description: "Filters points based on the value of the specified bitfield attribute.", properties: { field: { type: "string", description: "The name of the field that is used for the filter." }, requiredClearBits: { type: "array", description: "List ALL bit numbers that must cleared (=0) for the point to be kept. bit 0 is LSB.", items: { type: "integer" } }, requiredSetBits: { type: "array", description: " List ALL bit numbers that must set (=1) for the point to be kept. bit 0 is LSB.", items: { type: "integer" } }, type: { type: "string", enum: ["pointCloudBitfieldFilter"] } }, anyOf: [{ required: ["requiredClearBits"] }, { required: ["requiredSetBits"] }], required: ["field", "type"], additionalProperties: false }, "pointCloudReturnFilter_schema.json": { title: "PointCloud Return Filter", type: "object", description: "Filters points based on the value of the return number/return count.", properties: { field: { type: "string", description: "The name of the field that is used for the filter." }, includedReturns: { type: "array", description: "All points with at least one specified return status will be kept. Status values: `last`, `firstOfMany`, `lastOfMany`, `single`", items: { type: "string", enum: ["last", "firstOfMany", "lastOfMany", "single"] } }, type: { type: "string", enum: ["pointCloudReturnFilter"] } }, required: ["field", "includedReturns", "type"], additionalProperties: false }, "pointCloudValueFilter_schema.json": { title: "PointCloud Value Filter", type: "object", description: "Filters points based on the value of an specified attribute.", properties: { field: { type: "string", description: "The name of the field that is used for the filter." }, mode: { type: "string", description: "Defines if values should be included or excluded.", enum: ["exclude", "include"] }, type: { type: "string", description: "Filters points based on the value of an specified attribute.", enum: ["pointCloudValueFilter"] }, values: { type: "array", description: "list of values", items: { type: "number" } } }, required: ["field", "mode", "type", "values"], additionalProperties: false }, "dynamicDataLayer_source_schema.json": { title: "Dynamic data layer", type: "object", description: "A dynamic data layer derived from a registered workspace. More information on this can be found in the [ArcGIS REST API help](http://resources.arcgis.com/en/help/rest/apiref/layersource.html).", properties: { dataSource: { type: "object", description: "The layer's data source.", $ref: "#/definitions/dataSource_schema.json" }, fields: { type: "array", description: "An array of objects specifying information about an attribute field.", items: { type: "object", $ref: "#/definitions/field_schema.json" }, uniqueItems: true }, type: { type: "string", description: "A string value indicating the type.", enum: ["dataLayer"] } }, required: ["dataSource", "type"], additionalProperties: false }, "dynamicMapLayer_source_schema.json": { title: "Dynamic map layer", type: "object", description: "A dynamic map layer refers to a layer in the current map service. More information on this can be found in the [ArcGIS REST API help](http://resources.arcgis.com/en/help/rest/apiref/layersource.html).", properties: { gdbVersion: { type: "string", description: "If applicable, specify this to use an alternate geodatabase version." }, mapLayerId: { type: "integer", description: "The current map layer's id." }, type: { type: "string", description: "A string value indicating the type.", enum: ["mapLayer"] } }, required: ["mapLayerId", "type"], additionalProperties: false }, "template_schema.json": { title: "template", type: "object", description: "Templates describe features that can be created in a layer. They are generally used with feature collections and editable web-based CSV layers. Templates are not used with ArcGIS feature services as these already have templates defined in the service. They are also defined as properties of the layer definition when there are no defined types. Otherwise, templates are defined as properties of the types.", properties: { description: { type: "string", description: "A string value containing a detailed description of the template." }, drawingTool: { type: "string", description: "An optional string that can define a client-side drawing tool to be used with this feature.", enum: ["esriFeatureEditToolAutoCompletePolygon", "esriFeatureEditToolCircle", "esriFeatureEditToolDownArrow", "esriFeatureEditToolEllipse", "esriFeatureEditToolFreehand", "esriFeatureEditToolLeftArrow", "esriFeatureEditToolLine", "esriFeatureEditToolNone", "esriFeatureEditToolPoint", "esriFeatureEditToolPolygon", "esriFeatureEditToolRectangle", "esriFeatureEditToolRightArrow", "esriFeatureEditToolText", "esriFeatureEditToolTriangle", "esriFeatureEditToolUpArrow"] }, name: { type: "string", description: "A string containing a user-friendly name for the template." }, prototype: { type: "object", description: "A feature object representing a prototypical feature for the template.", $ref: "#/definitions/feature_schema.json" } }, additionalProperties: false }, "format_schema.json": { title: "format", type: "object", description: "The format object can be used with numerical or date fields to provide more detail about how values should be formatted for display.", properties: { dateFormat: { type: "string", description: "A string used with date fields to specify how the date should be formatted.", enum: ["dayShortMonthYear", "dayShortMonthYearLongTime", "dayShortMonthYearLongTime24", "dayShortMonthYearShortTime", "dayShortMonthYearShortTime24", "longDate", "longDateLongTime", "longDateLongTime24", "longDateShortTime", "longDateShortTime24", "longMonthDayYear", "longMonthDayYearLongTime", "longMonthDayYearLongTime24", "longMonthDayYearShortTime", "longMonthDayYearShortTime24", "longMonthYear", "shortDate", "shortDateLE", "shortDateLELongTime", "shortDateLELongTime24", "shortDateLEShortTime", "shortDateLEShortTime24", "shortDateLongTime", "shortDateLongTime24", "shortDateShortTime", "shortDateShortTime24", "shortMonthYear", "year"] }, digitSeparator: { type: "boolean", description: "A Boolean used with numerical fields. A value of true allows the number to have a digit (or thousands) separator. Depending on the locale, this separator is a decimal point or a comma. A value of false means that no separator will be used." }, places: { type: "integer", description: "An integer used with numerical fields to specify the number of decimal places. Any places beyond this value are rounded." } }, additionalProperties: false }, "mediaInfo_chart_schema.json": { title: "mediaInfo chart", type: "object", description: "Defines a chart to be displayed in a popup window.", properties: { altText: { type: "string", description: "A string providing the alternate text for the media." }, caption: { type: "string", description: "A string caption describing the media." }, title: { type: "string", description: "A string title for the media." }, type: { type: "string", description: "A string defining the type of media.", enum: ["barchart", "columnchart", "linechart", "piechart"] }, value: { $ref: "#/definitions/mediaInfo_chart_value_schema.json" } }, required: ["type", "value"], additionalProperties: false }, "mediaInfo_image_schema.json": { title: "mediaInfo image", type: "object", description: "Defines an image to be displayed in a popup window.", properties: { altText: { type: "string", description: "A string providing the alternate text for the media." }, caption: { type: "string", description: "A string caption describing the media." }, refreshInterval: { type: "number", description: "Refresh interval of the layer in minutes. Non-zero value indicates automatic layer refresh at the specified interval. Value of 0 indicates auto refresh is not enabled. If the property does not exist, it's equivalent to having a value of 0." }, title: { type: "string", description: "A string title for the media." }, type: { type: "string", description: "A string defining the type of media.", enum: ["image"] }, value: { $ref: "#/definitions/mediaInfo_image_value_schema.json" } }, required: ["type", "value"], additionalProperties: false }, "popupElement_attachments_schema.json": { title: "popupElement attachments", type: "object", description: "Configures attachments in popup elements.", properties: { displayType: { type: "string", description: "A string value indicating how to display the attachment. If `list` is specified, attachments show as links.", enum: ["list", "preview"] }, type: { type: "string", enum: ["attachments"] } }, required: ["type"], additionalProperties: false }, "popupElement_fields_schema.json": { title: "popupElement fields", type: "object", description: "Configures fields in popup elements.", properties: { fieldInfos: { type: "array", description: "It is an array of `fieldInfo` objects representing a field/value pair displayed as a table within the popupElement. If the `fieldInfos` property is not provided, the popupElement will display whatever is specified directly in the `popupInfo.fieldInfos` property.", items: { type: "object", $ref: "#/definitions/fieldInfo_schema.json" } }, type: { type: "string", enum: ["fields"] } }, required: ["type"], additionalProperties: false }, "popupElement_media_schema.json": { title: "popupElement media", type: "object", description: "Configures media in popup elements.", properties: { mediaInfos: { type: "array", description: "An array of `mediaInfo` objects representing an image or chart for display. If no `mediaInfos` property is provided, the popupElement will display whatever is specified in the `popupInfo.mediaInfos` property.", items: { type: "object", $ref: "#/definitions/mediaInfo_schema.json" } }, type: { type: "string", enum: ["media"] } }, required: ["type"], additionalProperties: false }, "popupElement_text_schema.json": { title: "popupElement text", type: "object", description: "Configures text in popup elements.", properties: { text: { type: "string", description: "This property applies to elements of type `text`. This is string value indicating the text to be displayed within the popupElement. If no `text` property is provided, the popupElement will display whatever is specified in the [popupInfo.description](popupInfo.md) property." }, type: { type: "string", enum: ["text"] } }, required: ["type"], additionalProperties: false }, "orderByFields_schema.json": { title: "orderByFields", type: "object", description: "Object indicating the field display order for the related records and whether they should be sorted in ascending or descending order.", properties: { field: { type: "string", description: "The attribute value of the field selected that will drive the sorting of related records." }, order: { type: "string", description: "Set the ascending or descending sort order of the returned related records.", enum: ["asc", "desc"] } } }, "labelExpressionInfo_schema.json": { title: "labelExpressionInfo", type: "object", description: "The labelExpressionInfo allows label text to be read similar to that of Popups's description property.", properties: { expression: { type: "string", description: "An [Arcade expression](https://developers.arcgis.com/arcade/) evaluating to either a string or a number." } }, additionalProperties: false }, "labelSymbol3D_schema.json": { title: "LabelSymbol3D", type: "object", description: "LabelSymbol3D is used to render labels for features from a FeatureLayer in a 3D SceneView.", properties: { callout: { $ref: "#/definitions/callout_schema.json" }, symbolLayers: { type: "array", description: "A Collection of Symbol3DLayer objects used to visualize the graphic or feature.", items: { oneOf: [{ $ref: "#/definitions/textSymbol3DLayer_schema.json" }] } }, type: { type: "string", description: "Specifies the type of symbol used.", enum: ["LabelSymbol3D"] }, verticalOffset: { $ref: "#/definitions/verticalOffset_schema.json" } }, required: ["symbolLayers", "type"], additionalProperties: false }, "classBreaksRenderer_schema.json": { title: "ClassBreaks Renderer", type: "object", description: "A class breaks renderer symbolizes based on the value of some numeric attribute. The classBreakInfo define the values at which the symbology changes.", properties: { authoringInfo: { type: "object", description: "An object containing metadata about the authoring process for creating a renderer object. This allows the authoring clients to save specific overridable settings so that next time it is accessed via the UI, their selections are remembered. Non-authoring clients can ignore it.", $ref: "#/definitions/authoringInfo_schema.json" }, backgroundFillSymbol: { type: "object", description: "Supported only for polygon features.", $ref: "#/definitions/polygonSymbol3D_schema.json" }, classBreakInfos: { type: "array", description: "Array of classBreakInfo objects.", items: { type: "object", $ref: "#/definitions/classBreakInfo_schema.json" } }, defaultLabel: { type: "string", description: "Label for the default symbol used to draw unspecified values." }, defaultSymbol: { type: "object", description: "Symbol used when a value cannot be classified.", $ref: "#/definitions/symbol3D_schema.json" }, field: { type: "string", description: "Attribute field used for renderer." }, legendOptions: { type: "object", description: "A legend containing one title, which is a string describing the renderer in the legend.", $ref: "#/definitions/rendererLegendOptions_schema.json" }, minValue: { type: "number", description: "The minimum numeric data value needed to begin class breaks." }, normalizationField: { type: "string", description: "Used when normalizationType is field. The string value indicating the attribute field by which the data value is normalized." }, normalizationTotal: { type: "number", description: "Used when normalizationType is percent-of-total, this number property contains the total of all data values." }, normalizationType: { type: "string", description: "Determine how the data was normalized.", enum: ["esriNormalizeByField", "esriNormalizeByLog", "esriNormalizeByPercentOfTotal"] }, type: { type: "string", description: "Specifies the type of renderer used.", enum: ["classBreaks"] }, valueExpression: { type: "string", description: "An [Arcade expression](https://developers.arcgis.com/arcade/) evaluating to a number." }, valueExpressionTitle: { type: "string", description: "The title identifying and describing the associated [Arcade](https://developers.arcgis.com/arcade/) expression as defined in the `valueExpression` property." }, visualVariables: { type: "array", description: "An array of objects used to set rendering properties.", items: { type: "object", $ref: "#/definitions/visualVariable_schema.json" } } }, required: ["classBreakInfos", "type"], additionalProperties: false }, "pointCloudRenderers_schema.json": { title: "PointCloud Renderers", type: "object", description: "Renderers for PointCloud Layers.", oneOf: [{ $ref: "#/definitions/pointCloudClassBreaksRenderer_schema.json" }, { $ref: "#/definitions/pointCloudRGBRenderer_schema.json" }, { $ref: "#/definitions/pointCloudStretchRenderer_schema.json" }, { $ref: "#/definitions/pointCloudUniqueValueRenderer_schema.json" }] }, "rasterRenderers_schema.json": { title: "Raster Renderers", type: "object", description: "Renderers for Raster Layers.", oneOf: [{ $ref: "#/definitions/rasterClassBreaksRenderer_schema.json" }, { $ref: "#/definitions/rasterColormapRenderer_schema.json" }, { $ref: "#/definitions/rasterShadedReliefRenderer_schema.json" }, { $ref: "#/definitions/rasterStretchRenderer_schema.json" }, { $ref: "#/definitions/rasterUniqueValueRenderer_schema.json" }] }, "simpleRenderer_schema.json": { title: "Simple Renderer", type: "object", description: "A simple renderer is a renderer that uses one symbol only.", properties: { authoringInfo: { type: "object", description: "An object containing metadata about the authoring process for creating a renderer object. This allows the authoring clients to save specific overridable settings so that next time it is accessed via the UI, their selections are remembered. Non-authoring clients can ignore it.", $ref: "#/definitions/authoringInfo_schema.json" }, description: { type: "string", description: "Description of the renderer." }, label: { type: "string", description: "The text string that is displayed in the table of contents." }, symbol: { type: "object", description: "An object that represents how all features will be drawn.", $ref: "#/definitions/symbol3D_schema.json" }, type: { type: "string", description: "Specifies the type of renderer used.", enum: ["simple"] }, visualVariables: { type: "array", description: "An array of objects used to set rendering properties.", items: { type: "object", $ref: "#/definitions/visualVariable_schema.json" } } }, required: ["symbol", "type"], additionalProperties: false }, "uniqueValueFromStyleRenderer_schema.json": { title: "UniqueValueFromStyle Renderer", type: "object", description: "This is a special version of UniqueValue Renderer, which loads uniqueValue infos from a style definition.", properties: { defaultLabel: { type: "string", description: "Default string for the default symbol used to draw unspecified values." }, defaultSymbol: { description: "The defaultSymbol on the renderer that get assigned to features with no value or features that do not fall within the configured data.", $ref: "#/definitions/symbol3D_schema.json" }, field1: { type: "string", description: "String value specifying the first field used to render matching values." }, styleName: { type: "string", description: "A registered web style name. Can not be used in conjunction with styleUrl." }, styleUrl: { type: "string", description: "URL that points to the web style definition. Can not be used in conjunction with styleName." }, type: { type: "string", description: "Specifies the type of renderer used.", enum: ["uniqueValue"] }, visualVariables: { type: "array", description: "An array of visualVariable objects used for continuous color or size, simple, and unique values with feature opacity.", items: { $ref: "#/definitions/visualVariable_schema.json" } } }, oneOf: [{ required: ["type", "styleName"] }, { required: ["type", "styleUrl"] }], additionalProperties: false }, "uniqueValueRenderer_schema.json": { title: "UniqueValue Renderer", type: "object", description: "A unique value renderer symbolizes based on the value of an attribute.", properties: { authoringInfo: { type: "object", description: "An object containing metadata about the authoring process for creating a renderer object. This allows the authoring clients to save specific overridable settings so that next time it is accessed via the UI, their selections are remembered. Non-authoring clients can ignore it.", $ref: "#/definitions/authoringInfo_schema.json" }, backgroundFillSymbol: { type: "object", description: "Used for polygon features. It can only be used for bivariate types and size rendering.", $ref: "#/definitions/polygonSymbol3D_schema.json" }, defaultLabel: { type: "string", description: "Default label for the default symbol used to draw unspecified values." }, defaultSymbol: { description: "The defaultSymbol on the renderer that get assigned to features with no value or features that do not fall within the configured data.", $ref: "#/definitions/symbol3D_schema.json" }, field1: { type: "string", description: "Attribute field renderer uses to match values." }, field2: { type: "string", description: "If needed, specify an additional attribute field the renderer uses to match values." }, field3: { type: "string", description: "If needed, specify an additional attribute field the renderer uses to match values." }, fieldDelimiter: { type: "string", description: "String inserted between the values if multiple attribute fields are specified.", default: ", " }, legendOptions: { type: "object", description: "A legend containing one title, which is a string describing the renderer in the legend.", $ref: "#/definitions/rendererLegendOptions_schema.json" }, type: { type: "string", description: "Specifies the type of renderer used.", enum: ["uniqueValue"] }, uniqueValueInfos: { type: "array", description: "An array of uniqueValueInfo objects.", items: { type: "object", $ref: "#/definitions/uniqueValueInfo_schema.json" } }, valueExpression: { type: "string", description: "An [Arcade expression](https://developers.arcgis.com/arcade/) evaluating to either a string or a number." }, valueExpressionTitle: { type: "string", description: "The title identifying and describing the associated [Arcade](https://developers.arcgis.com/arcade/) expression as defined in the `valueExpression` property." }, visualVariables: { type: "array", description: "An array of objects used to set rendering properties.", items: { type: "object", $ref: "#/definitions/visualVariable_schema.json" } } }, required: ["type", "uniqueValueInfos"], additionalProperties: false }, "search_layer_schema.json": { title: "search layer", type: "object", description: "Layer configuration for search.", properties: { field: { $ref: "#/definitions/search_layer_field_schema.json" }, id: { type: "string", description: "A string identifying the layer." }, subLayer: { type: "integer", description: "Optional index for a sublayer." } }, required: ["field", "id"], additionalProperties: false }, "point_geometry_schema.json": { title: "pointGeometry", type: "object", description: "Defines the JSON formats of the point and spatial reference objects.", properties: { m: { type: "number", description: "M coordinate which contains measures used for linear referencing." }, spatialReference: { type: "object", description: "The spatial reference can be defined using a well-known ID (WKID) or well-known text (WKT).", $ref: "#/definitions/spatialReference_schema.json" }, x: { description: "X coordinate which is measured along the east/west axis.", oneOf: [{ type: "number" }, { type: "null" }, { type: "string", enum: ["NaN"] }] }, y: { type: "number", description: "Y coordinate which is measured along the north/south axis." }, z: { type: "number", description: "Z coordinate which measures height or elevation." } }, required: ["x"], additionalProperties: false }, "multipoint_geometry_schema.json": { title: "multipointGeometry", type: "object", description: "Contains an array of points, along with a spatial reference field.", properties: { hasM: { type: "boolean", description: "Indicates whether the geometry contains M coordinate values." }, hasZ: { type: "boolean", description: "Indicates whether the geometry contains Z coordinate values." }, points: { type: "array", description: "An array that corresponds to 2D and 3D points.", items: { type: "array", items: { type: "number" }, minItems: 2, maxItems: 4 } }, spatialReference: { type: "object", description: "The spatial reference can be defined using a well-known ID (WKID) or well-known text (WKT).", $ref: "#/definitions/spatialReference_schema.json" } }, required: ["points"], additionalProperties: false }, "polygon_geometry_schema.json": { title: "polygonGeometry", type: "object", description: "A polygon contains an array of rings and a spatial reference.", properties: { hasM: { type: "boolean", description: "Indicates whether the geometry contains M coordinate values." }, hasZ: { type: "boolean", description: "Indicates whether the geometry contains Z coordinate values." }, rings: { type: "array", description: "Represents an array of rings. Each ring is an array of points.", items: { type: "array", items: { type: "array", items: { type: "number" }, minItems: 2, maxItems: 4 }, minItems: 3 }, minItems: 1 }, spatialReference: { type: "object", description: "The spatial reference can be defined using a well-known ID (WKID) or well-known text (WKT).", $ref: "#/definitions/spatialReference_schema.json" } }, required: ["rings"], additionalProperties: false }, "polyline_geometry_schema.json": { title: "polylineGeometry", type: "object", description: "Contains an array of paths and a spatialReference.", properties: { hasM: { type: "boolean", description: "Indicates whether the geometry contains M coordinate values." }, hasZ: { type: "boolean", description: "Indicates whether the geometry contains Z coordinate values." }, paths: { type: "array", description: "Three nested array levels describing a polyline. The first level describes individual paths; the second describes the points of these paths; and the third gives the coordinates of the points.", items: { type: "array", items: { type: "array", items: { type: "number" }, minItems: 2, maxItems: 4 }, minItems: 2 } }, spatialReference: { type: "object", description: "The spatial reference can be defined using a well-known ID (WKID) or well-known text (WKT).", $ref: "#/definitions/spatialReference_schema.json" } }, required: ["paths"], additionalProperties: false }, "lod_schema.json": { title: "lod", type: "object", properties: { level: { type: "integer", description: "ID for each level." }, levelValue: { type: "string", description: "String to be used when constructing URL to access a tile from this LOD." }, resolution: { type: "number", description: "Resolution in map units of each pixel in a tile for each level." }, scale: { type: "number", description: "Scale for each level." } }, additionalProperties: false }, "parameter_schema.json": { title: "parameter", type: "object", description: "Objects defined by a [definitionEditor](definitionEditor.md) input.", properties: { defaultValue: { type: ["number", "string"], description: "The default value that is automatically given is nothing is provided." }, fieldName: { type: "string", description: "A string value representing the name of the field to query." }, parameterId: { type: "integer", description: "Number given to uniquely identify the specified parameter." }, type: { type: "string", description: "The field type for the specified field parameter.", enum: ["esriFieldTypeBlob", "esriFieldTypeDate", "esriFieldTypeDouble", "esriFieldTypeGUID", "esriFieldTypeGeometry", "esriFieldTypeGlobalID", "esriFieldTypeInteger", "esriFieldTypeOID", "esriFieldTypeRaster", "esriFieldTypeSingle", "esriFieldTypeSmallInteger", "esriFieldTypeString", "esriFieldTypeXML"] }, utcValue: { type: "integer", description: "An integer value representing exact UNIX time used when `defaultValue` is a date string." } }, additionalProperties: false }, "buildingSceneLayer_filterAuthoringInfo_filterType_schema.json": { title: "Filter Type", type: "object", description: "The file authoring information for a filter, including the filter type and its value settings.", properties: { filterType: { type: "string", description: "Represents the filter type name. Name is a unique identifier." }, filterValues: { type: "array", description: "Array of filter values. Filter values are the attributes that can be stored for individual fields in a layer.", items: { type: "string" } } }, required: ["filterType", "filterValues"], additionalProperties: false }, "buildingSceneLayer_filterModeSolid_schema.json": { title: "Filter mode solid", type: "object", description: "Draw elements of this filter block in solid mode. This mode does not change the display of features.", properties: { type: { type: "string", description: "Declares filter mode of type solid.", enum: ["solid"] } }, required: ["type"], additionalProperties: false }, "buildingSceneLayer_filterModeWireFrame_schema.json": { title: "Filter mode wire frame", type: "object", description: "Draw elements of this filter block in wireframe mode. This mode draws only the edges of the features with the specified edge style.", properties: { edges: { type: "object", description: "An object defining edges of a feature.", $ref: "#/definitions/edges_schema.json" }, type: { type: "string", description: "Declares filter mode of type wire frame.", enum: ["wireFrame"] } }, required: ["edges", "type"], additionalProperties: false }, "buildingSceneLayer_filterModeXray_schema.json": { title: "Filter mode x-ray", type: "object", description: "Draw elements of this filter block in x-ray mode. `x-ray` renders elements semi-transparent with white color.", properties: { type: { type: "string", description: "Declares filter mode of type x-ray.", enum: ["x-ray"] } }, required: ["type"], additionalProperties: false }, "codedValue_domain_schema.json": { title: "codedValue", type: "object", description: "The coded value domain includes both the actual value that is stored in a database and a description of what the code value means.", properties: { codedValues: { type: "array", description: "A set of valid values with unique names.", items: { type: "object", $ref: "#/definitions/codedValue_schema.json" }, uniqueItems: true }, name: { type: "string", description: "The domain name." }, type: { type: "string", description: "String value representing the domain type.", enum: ["codedValue"] } }, required: ["codedValues", "type"], additionalProperties: false }, "inherited_domain_schema.json": { title: "inheritedDomain", type: "object", description: "This domain applies to domains on subtypes. It implies that the domain for a field at the subtype level is the same as the domain for the field at the layer level.", properties: { name: { type: "string", description: "The domain name." }, type: { type: "string", description: "String value representing the domain type.", enum: ["inherited"] } }, required: ["type"], additionalProperties: false }, "range_domain_schema.json": { title: "rangeDomain", type: "object", description: "Range domain specifies a range of valid values for a field.", properties: { name: { type: "string", description: "The domain name." }, range: { type: "array", description: "The first element is the minValue and the second element is the maxValue.", items: { type: "number" }, minItems: 2, maxItems: 2, uniqueItems: true }, type: { type: "string", description: "String value representing the domain type.", enum: ["range"] } }, required: ["range", "type"], additionalProperties: false }, "dataSource_schema.json": { title: "dataSource", type: "object", description: "This object applies if the [layerDefinition](layerDefinition.md) source is set to `DynamicDataLayer`.", oneOf: [{ $ref: "#/definitions/joinTableDataSource_schema.json" }, { $ref: "#/definitions/queryTableDataSource_schema.json" }, { $ref: "#/definitions/rasterDataSource_schema.json" }, { $ref: "#/definitions/tableDataSource_schema.json" }] }, "feature_schema.json": { title: "feature", type: "object", description: "Contains information about an attribute field and feature geometry.", properties: { attributes: { type: "object", description: "The feature attributes. A JSON object that contains a dictionary of name-value pairs. The names are the feature field names. The values are the field values, and they can be any of the standard JSON types: string, number, and boolean. Note that date values are encoded as numbers. The number represents the number of milliseconds since epoch (January 1, 1970) in UTC." }, geometry: { type: "object", description: "It can be any of the supported geometry types.", $ref: "#/definitions/geometry_schema.json" }, symbol: { type: "object", description: "Symbol used for drawing the feature.", $ref: "#/definitions/symbol3D_schema.json" } }, additionalProperties: false }, "mediaInfo_chart_value_schema.json": { title: "mediaInfo chart value", type: "object", description: "The value object contains information for popup windows about how charts should be constructed.", properties: { fields: { type: "array", description: "An array of strings, with each string containing the name of a field to display in the chart.", items: { type: "string" }, uniqueItems: true }, normalizeField: { type: "string", description: "An optional string containing the name of a field. The values of all fields in the chart will be normalized (divided) by the value of this field." }, tooltipField: { type: "string", description: "String value indicating the tooltip for a chart specified from another field. This field is needed when related records are not used. It is used for showing tooltips from another field in the same layer or related layer/table." } }, required: ["fields"], additionalProperties: false }, "mediaInfo_image_value_schema.json": { title: "mediaInfo image value", type: "object", description: "The value object contains information for popup windows about how images should be retrieved.", properties: { linkURL: { type: "string", description: "A string containing a URL to be launched in a browser when a user clicks the image." }, sourceURL: { type: "string", description: "A string containing the URL to the image." } }, required: ["sourceURL"], additionalProperties: false }, "callout_schema.json": { title: "Callout", type: "object", description: "Callout configuration for a symbol.", properties: { border: { $ref: "#/definitions/border_schema.json" }, color: { description: "The color of the line.", $ref: "#/definitions/color_schema.json" }, size: { type: "number", description: "The width of the line in points.", minimum: 0 }, transparency: { type: "integer", description: "A value between `100` (full transparency) and `0` (full opacity).", minimum: 0, maximum: 100, default: 0 }, type: { type: "string", description: "The type of the callout. A callout of type `line` connects an offset symbol or label with its location.", enum: ["line"] } }, required: ["color", "size", "type"], additionalProperties: false }, "textSymbol3DLayer_schema.json": { title: "TextSymbol3DLayer", type: "object", description: "Symbol layer for text and font definitions.", properties: { enable: { type: "boolean" }, font: { $ref: "#/definitions/font_schema.json" }, halo: { $ref: "#/definitions/halo_schema.json" }, material: { $ref: "#/definitions/material_schema.json" }, size: { type: "number", description: "Font size in points, positive only", minimum: 0 }, text: { type: "string", description: "Text content in the label. Typically this property is not set, as text content is read from labeling field." }, type: { type: "string", description: "Specifies the type of symbol used.", enum: ["Text"] } }, required: ["type"], additionalProperties: false }, "verticalOffset_schema.json": { title: "verticalOffset", type: "object", description: "Shifts the symbol along the vertical world axis by a given length. The length is set in screen space units.", properties: { maxWorldLength: { type: "number", description: "The maximum vertical symbol lift in world units. It acts as an upper bound to avoid lift becoming too big." }, minWorldLength: { type: "number", description: "The minimum vertical symbol lift in world units. It acts as a lower bound to avoid lift becoming too small.", default: 0 }, screenLength: { type: "number", description: "Maximal screen length of lift in points." } }, required: ["screenLength"], additionalProperties: false }, "authoringInfo_schema.json": { title: "authoringInfo", type: "object", description: "The authoringInfo is an object containing metadata about the authoring process for creating a renderer object. This allows the authoring clients to save specific overridable settings so that next time it is accessed via an authoring client, their selections are remembered. Non-authoring clients can ignore it. Properties for color/size/transparency sliders, theme selection, classification information, and additional properties are saved within this object.", properties: { classificationMethod: { type: "string", description: "Used for classed color or size. The default value is `esriClassifyManual`.", enum: ["esriClassifyDefinedInterval", "esriClassifyEqualInterval", "esriClassifyManual", "esriClassifyNaturalBreaks", "esriClassifyQuantile", "esriClassifyStandardDeviation"], default: "esriClassifyManual" }, colorRamp: { type: "object", $ref: "#/definitions/colorRamp_schema.json" }, field1: { $ref: "#/definitions/field_authoringInfo_schema.json" }, field2: { $ref: "#/definitions/field_authoringInfo_schema.json" }, fields: { type: "array", description: "An array of string values representing field names used for creating predominance renderers.", items: { type: "string" } }, focus: { type: "string", description: "Optional. Used for Relationship renderer. If not set, the legend will default to being square.", enum: ["HH", "HL", "LH", "LL"] }, lengthUnit: { type: "string", description: "Unit used in user interfaces to display world/map sizes and distances", enum: ["centimeters", "decimal-degrees", "decimeters", "feet", "inches", "kilometers", "meters", "miles", "millimeters", "nautical-miles", "yards"] }, numClasses: { type: "integer", description: "Number of classes to be associated with the relationship. Used for Relationship renderer.", minimum: 2, maximum: 4 }, standardDeviationInterval: { type: "number", description: "Use this property if the classificationMethod is `esriClassifyStandardDeviation`.", enum: [0.25, 0.33, 0.5, 1] }, type: { type: "string", enum: ["classedColor", "classedSize", "dotDensity", "predominance", "relationship", "univariateColorSize"] }, visualVariables: { type: "array", description: "An array of visualVariable objects containing additional information needed when authoring the renderer.", items: { type: "object", $ref: "#/definitions/authoringInfo_visualVariable_schema.json" } } }, additionalProperties: false }, "polygonSymbol3D_schema.json": { title: "PolygonSymbol3D", type: "object", description: "PolygonSymbol3D is used to render features with Polygon geometry in a 3D SceneView. Polygon features may also be rendered as points with icons or objects at the centroid of each polygon.", properties: { styleOrigin: { $ref: "#/definitions/styleOrigin_schema.json" }, symbolLayers: { type: "array", description: "A Collection of Symbol3DLayer objects used to visualize the graphic or feature.", items: { oneOf: [{ $ref: "#/definitions/fillSymbol3DLayer_schema.json" }, { $ref: "#/definitions/extrudeSymbol3DLayer_schema.json" }, { $ref: "#/definitions/waterSymbol3DLayer_schema.json" }, { $ref: "#/definitions/iconSymbol3DLayer_schema.json" }, { $ref: "#/definitions/objectSymbol3DLayer_schema.json" }, { $ref: "#/definitions/textSymbol3DLayer_schema.json" }, { description: "<em>Deprecated</em>, use [fillSymbol3DLayer with outline](fillSymbol3DLayer.md) instead", $ref: "#/definitions/lineSymbol3DLayer_schema.json" }] } }, type: { type: "string", description: "Specifies the type of symbol used.", enum: ["PolygonSymbol3D"] } }, required: ["symbolLayers", "type"], additionalProperties: false }, "classBreakInfo_schema.json": { title: "classBreakInfo", type: "object", description: "The classBreaksInfo object provides information about the class breaks associated with the renderer.", properties: { classMaxValue: { type: "number", description: "A numeric value used to specify the maximum value for a break." }, classMinValue: { type: "number", description: "A numeric value used to specify discontinuous class breaks. If this value is null or is missing, the map server will calculate the minimum value based on the preceding class' maximum value." }, description: { type: "string", description: "String value used to describe the drawn symbol." }, label: { type: "string", description: "String value used to label the drawn symbol." }, symbol: { type: "object", description: "An object used to display the value.", $ref: "#/definitions/symbol3D_schema.json" } }, required: ["symbol"], additionalProperties: false }, "symbol3D_schema.json": { title: "Symbol3D", type: "object", description: "Symbol3D is the base class for all 3D symbols. It is used to render 2D Point, Polyline, and Polygon features in a FeatureLayer and 3D mesh features in a SceneLayer. All 3D symbols must be used in a SceneView instance; there is no support for 3D rendering in MapViews.", oneOf: [{ $ref: "#/definitions/lineSymbol3D_schema.json" }, { $ref: "#/definitions/meshSymbol3D_schema.json" }, { $ref: "#/definitions/pointSymbol3D_schema.json" }, { $ref: "#/definitions/polygonSymbol3D_schema.json" }, { $ref: "#/definitions/styleSymbolReference_schema.json" }] }, "rendererLegendOptions_schema.json": { title: "Renderer Legend Options", type: "object", description: "Options available for the renderer legend.", properties: { title: { type: "string", description: "The title of the legend." } } }, "visualVariable_schema.json": { title: "visualVariable", type: "object", description: "An object used to set rendering options. Please see the individual visual variable for specific information on how it is used.", oneOf: [{ $ref: "#/definitions/colorInfo_visualVariable_schema.json" }, { $ref: "#/definitions/rotationInfo_visualVariable_schema.json" }, { $ref: "#/definitions/sizeInfo_visualVariable_schema.json" }, { $ref: "#/definitions/transparencyInfo_visualVariable_schema.json" }] }, "pointCloudClassBreaksRenderer_schema.json": { title: "PointCloud ClassBreaks Renderer", type: "object", description: "PointCloudClassBreaksRenderer defines the color of each point in a PointCloudLayer based on the value of a numeric attribute. Colors are assigned based on classes or ranges of data. Each point is assigned a symbol based on the class break in which the value of the attribute falls.", properties: { colorClassBreakInfos: { type: "array", description: "Each element in the array is an object that provides information about a class break associated with the renderer.", items: { type: "object", $ref: "#/definitions/colorClassBreakInfo_schema.json" } }, colorModulation: { $ref: "#/definitions/colorModulationInfo_schema.json" }, field: { type: "string", description: "  The name of the field that is used for the renderer." }, fieldTransformType: { type: "string", description: "A transform that is applied to the field value before evaluating the renderer.", enum: ["absoluteValue", "highFourBit", "lowFourBit", "moduloTen", "none"] }, legendOptions: { type: "object", description: "A legend containing one title, which is a string describing the renderer in the legend.", $ref: "#/definitions/rendererLegendOptions_schema.json" }, pointSizeAlgorithm: { $ref: "#/definitions/pointSizeAlgorithm_schema.json" }, pointsPerInch: { type: "number", description: "Number of point to draw per display inch." }, type: { type: "string", description: "Specifies the type of renderer used.", enum: ["pointCloudClassBreaksRenderer"] } }, required: ["colorClassBreakInfos", "field", "type"], additionalProperties: false }, "pointCloudRGBRenderer_schema.json": { title: "PointCloud RGB Renderer", type: "object", description: "PointCloudRGBRenderer defines the color of each point in a PointCloudLayer based on the value of a color attribute.", properties: { colorModulation: { description: "", $ref: "#/definitions/colorModulationInfo_schema.json" }, field: { type: "string", description: "The name of the field that is used for the renderer." }, pointSizeAlgorithm: { description: "", $ref: "#/definitions/pointSizeAlgorithm_schema.json" }, pointsPerInch: { type: "number", description: "Number of point to draw per display inch." }, type: { type: "string", description: "Specifies the type of renderer used.", enum: ["pointCloudRGBRenderer"] } }, required: ["field", "type"], additionalProperties: false }, "pointCloudStretchRenderer_schema.json": { title: "PointCloud Stretch Renderer", type: "object", description: "PointCloudStretchRenderer defines the color of each point in a PointCloudLayer based on the value of a numeric attribute. They allow you to easily map continuous color ramps to minimum and maximum data values of one of the layer's numeric attribute fields.", properties: { colorModulation: { description: "", $ref: "#/definitions/colorModulationInfo_schema.json" }, field: { type: "string", description: "The name of the field that is used for the renderer." }, fieldTransformType: { type: "string", description: "A transform that is applied to the field value before evaluating the renderer.", enum: ["absoluteValue", "highFourBit", "lowFourBit", "moduloTen", "none"] }, legendOptions: { type: "object", description: "A legend containing one title, which is a string describing the renderer in the legend.", $ref: "#/definitions/rendererLegendOptions_schema.json" }, pointSizeAlgorithm: { description: "", $ref: "#/definitions/pointSizeAlgorithm_schema.json" }, pointsPerInch: { type: "number", description: "Number of points to draw per display inch." }, stops: { type: "array", description: "An array of color value pairs.", items: { type: "object", $ref: "#/definitions/colorStop_schema.json" } }, type: { type: "string", description: "Specifies the type of renderer used.", enum: ["pointCloudStretchRenderer"] } }, required: ["field", "stops", "type"], additionalProperties: false }, "pointCloudUniqueValueRenderer_schema.json": { title: "PointCloud UniqueValue Renderer", type: "object", description: "PointCloudUniqueValueRenderer allows you to colorize points in a PointCloudLayer based on an attribute. This is done by using unique colors to represent points with equal attribute values.", properties: { colorModulation: { description: "", $ref: "#/definitions/colorModulationInfo_schema.json" }, colorUniqueValueInfos: { type: "array", description: "Unique value infos.", items: { type: "object", $ref: "#/definitions/colorUniqueValueInfo_schema.json" } }, field: { type: "string", description: "The name of the field that is used for the renderer." }, fieldTransformType: { type: "string", description: "A transform that is applied to the field value before evaluating the renderer.", enum: ["absoluteValue", "highFourBit", "lowFourBit", "moduloTen", "none"] }, legendOptions: { type: "object", description: "A legend containing one title, which is a string describing the renderer in the legend.", $ref: "#/definitions/rendererLegendOptions_schema.json" }, pointSizeAlgorithm: { description: "", $ref: "#/definitions/pointSizeAlgorithm_schema.json" }, pointsPerInch: { type: "number", description: "Number of points to draw per display inch." }, type: { type: "string", description: "Specifies the type of renderer used.", enum: ["pointCloudUniqueValueRenderer"] } }, required: ["colorUniqueValueInfos", "field", "type"], additionalProperties: false }, "rasterClassBreaksRenderer_schema.json": { title: "Raster ClassBreaks Renderer", type: "object", description: "Defines the color of each raster cell based on the value of a numeric attribute. Colors are assigned based on classed ranges of data.", properties: { authoringInfo: { type: "object", description: "An object containing metadata about the authoring process for creating a renderer object. This allows the authoring clients to save specific overridable settings so that next time it is accessed via the UI, their selections are remembered. Non-authoring clients can ignore it.", $ref: "#/definitions/authoringInfo_schema.json" }, colorClassBreakInfos: { type: "array", description: "Each element in the array is an object that provides information about a class break associated with the renderer.", items: { type: "object", $ref: "#/definitions/colorClassBreakInfo_schema.json" } }, defaultColor: { description: "The defaultColor on the renderer that get assigned to features with no value or features that do not fall within the configured data.", $ref: "#/definitions/color_schema.json" }, defaultLabel: { type: "string", description: "Default label for the default symbol used to draw unspecified values." }, field: { type: "string", description: "The name of the field that is used for the renderer." }, legendOptions: { type: "object", description: "A legend containing one title, which is a string describing the renderer in the legend.", $ref: "#/definitions/rendererLegendOptions_schema.json" }, normalizationField: { type: "string", description: "Used when normalizationType is field. The string value indicating the attribute field by which the data value is normalized." }, normalizationTotal: { type: "number", description: "Used when normalizationType is percent-of-total, this number property contains the total of all data values." }, normalizationType: { type: "string", description: "Determine how the data was normalized.", enum: ["esriNormalizeByField", "esriNormalizeByLog", "esriNormalizeByPercentOfTotal"] }, type: { type: "string", description: "Specifies the type of renderer used.", enum: ["rasterClassBreaksRenderer"] } }, required: ["colorClassBreakInfos", "field", "type"], additionalProperties: false }, "rasterColormapRenderer_schema.json": { title: "Raster Colormap Renderer", type: "object", description: "A value/color look up table used for rendering raster data only.", properties: { colormapInfos: { type: "array", description: "An array of colormapInfo objects.", items: { type: "object", $ref: "#/definitions/colormapInfo_schema.json" } }, type: { type: "string", description: "Specifies the type of renderer used.", enum: ["rasterColormap"] } }, required: ["colormapInfos", "type"], additionalProperties: false }, "rasterShadedReliefRenderer_schema.json": { title: "Raster Shaded Relief Renderer", type: "object", description: "This renderer produces a grayscale or a colored 3D representation of a shaded relief. This renderer can be used on either layers of type: [ImageServiceLayer](imageServiceLayer.md) or [TiledImageServiceLayer](tiledImageServiceLayer.md).", properties: { altitude: { type: "number", description: "Used when the `hillshadeType` is `traditional`. The  altitude of the illumination source." }, azimuth: { type: "number", description: "Used when the `hillshadeType` is `traditional`. The azimuth of the illumination source." }, colorRamp: { type: "object", description: "The color ramp to display the shaded relief. When not specified, a grayscale hillshade is produced. When this is specified, grayscale hillshade is fused with colorized elevation.", $ref: "#/definitions/colorRamp_schema.json" }, hillshadeType: { type: "string", description: "Use single (traditional), or multiple illumination sources to generate hillshade.", enum: ["multi-directional", "traditional"] }, pixelSizeFactor: { type: "number", description: "Accounts for changes in scale as the viewer zooms in and out on the map display." }, pixelSizePower: { type: "number", description: "Accounts for the altitude changes (or scale) as the viewer zooms in and out on the map display." }, scalingType: { type: "string", description: "Apply a constant or adjusted z-factor based on resolution changes. The `adjusted` type is suitable for worldwide elevation dataset. An adjusted `zFactor` is determined using this equation: `Adjusted Z-Factor = (Z Factor) + (Pixel Size)` <sup>(Pixel Size Power)</sup> `x Pixel Size Factor`.", enum: ["adjusted", "none"] }, type: { type: "string", description: "Specifies the type of renderer used.", enum: ["rasterShadedRelief"] }, zFactor: { type: "number", description: "A conversion factor that adjusts the units of measure for the vertical (or elevation) units when they are different from the horizontal coordinate (x,y) units of the input surface. It is the number of ground x,y units in one surface z-unit." } }, required: ["altitude", "azimuth", "hillshadeType", "scalingType", "type", "zFactor"], additionalProperties: false }, "rasterStretchRenderer_schema.json": { title: "Raster Stretch Renderer", description: "Displays continuous raster cell values across a gradual ramp of colors. Use this renderer to draw a single band of continuous data. This renderer works well when you have a large range of values to display, such as with imagery or scientific data.", properties: { colorRamp: { type: "object", $ref: "#/definitions/colorRamp_schema.json" }, computeGamma: { type: "boolean", description: "Indicates if gamma values should be computed by default." }, dra: { type: "boolean", description: "Indicates if Dynamic Range Adjustment should be applied." }, gamma: { type: "array", description: "The list of Gamma value(s).", items: { type: "number" } }, max: { type: "number", description: "The current maximum output value." }, maxPercent: { type: "number", description: "The current maximum percent value." }, min: { type: "number", description: "The current minimum output value." }, minPercent: { type: "number", description: "The current minimum percent value." }, numberOfStandardDeviations: { type: "integer", description: "The number of standard deviations for standard deviation stretch." }, sigmoidStrengthLevel: { type: "number", description: "Set this from (1 to 6) to adjust the curvature of Sigmoid curve used in color stretch." }, statistics: { type: "array", description: "The custom raster stretch statistics.", items: { type: "array", items: { type: "number", minItems: 4, maxItems: 4 } } }, stretchType: { type: "string", description: "The stretch types for stretch raster function.", enum: ["histogramEqualization", "minMax", "none", "percentClip", "sigmoid", "standardDeviation"] }, type: { type: "string", description: "Specifies the type of renderer used.", enum: ["rasterStretch"] }, useGamma: { type: "boolean", description: "Indicates if the renderer applies Gamma stretch." } }, additionalProperties: false }, "rasterUniqueValueRenderer_schema.json": { title: "Raster UniqueValue Renderer", type: "object", description: "Defines the color of each raster cell based on an attribute. This is done by using unique colors to represent cells with equal attribute values.", properties: { authoringInfo: { type: "object", description: "An object containing metadata about the authoring process for creating a renderer object. This allows the authoring clients to save specific overridable settings so that next time it is accessed via the UI, their selections are remembered. Non-authoring clients can ignore it.", $ref: "#/definitions/authoringInfo_schema.json" }, colorUniqueValueInfos: { type: "array", description: "Unique value infos.", items: { type: "object", $ref: "#/definitions/colorUniqueValueInfo_schema.json" } }, defaultColor: { description: "The defaultColor on the renderer that get assigned to features with no value or features that do not fall within the configured data.", $ref: "#/definitions/color_schema.json" }, defaultLabel: { type: "string", description: "Default label for the default symbol used to draw unspecified values." }, field: { type: "string", description: "The name of the field that is used for the renderer." }, legendOptions: { type: "object", description: "A legend containing one title, which is a string describing the renderer in the legend.", $ref: "#/definitions/rendererLegendOptions_schema.json" }, type: { type: "string", description: "Specifies the type of renderer used.", enum: ["rasterUniqueValueRenderer"] } }, required: ["colorUniqueValueInfos", "field", "type"], additionalProperties: false }, "uniqueValueInfo_schema.json": { title: "uniqueValueInfo", type: "object", description: "Info item for the Unique Value Renderer. Its symbol gets selected if the feature's field matches its value.", properties: { description: { type: "string", description: "String value used to describe the drawn symbol." }, label: { type: "string", description: "String value used to label the drawn symbol." }, symbol: { type: "object", description: "An object used to display the value.", $ref: "#/definitions/symbol3D_schema.json" }, value: { type: "string", description: "String value indicating the unique value." } }, additionalProperties: false }, "search_layer_field_schema.json": { title: "search layer field", type: "object", description: "Contains information about an attribute field in search layer configuration.", properties: { exactMatch: { type: "boolean", description: "A Boolean defining whether or not the field is an exact match." }, name: { type: "string", description: "A string defining the field name." }, type: { type: "string", description: "A string defining the field type.", enum: ["esriFieldTypeBlob", "esriFieldTypeDate", "esriFieldTypeDouble", "esriFieldTypeGUID", "esriFieldTypeGeometry", "esriFieldTypeGlobalID", "esriFieldTypeInteger", "esriFieldTypeLong", "esriFieldTypeOID", "esriFieldTypeRaster", "esriFieldTypeSingle", "esriFieldTypeSmallInteger", "esriFieldTypeString", "esriFieldTypeXML"] } }, additionalProperties: false }, "edges_schema.json": { title: "Edges", type: "object", description: "Specifies an edge visualization style (only applies to MeshSymbol3D). Edges describe the style applied to visually important edges of 3D objects.", oneOf: [{ $ref: "#/definitions/sketchEdges_schema.json" }, { $ref: "#/definitions/solidEdges_schema.json" }] }, "codedValue_schema.json": { title: "codedValue", type: "object", description: "A set of valid coded values with unique names.", properties: { code: { type: ["number", "string"], description: "The value stored in the feature attribute." }, name: { type: "string", description: "User-friendly name for what the code means." } }, required: ["code", "name"], additionalProperties: false }, "joinTableDataSource_schema.json": { title: "Join Table DataSource", type: "object", description: "Join Table data source is the result of a join operation. Nested joins are supported. To use nested joins, set either leftTableSource or rightTableSource to be a joinTable.", properties: { joinType: { type: "string", description: "The type of join (left outer or left inner).", enum: ["esriLeftInnerJoin", "esriLeftOuterJoin"] }, leftTableKey: { type: "string", description: "Field name from the left table." }, leftTableSource: { type: "object", description: "The left source. If the leftTableSource is a table, the resulting joinTable is a table. If the leftTableSource is a layer, the resulting joinTable is a layer.", $ref: "#/definitions/source_schema.json" }, rightTableKey: { type: "string", description: "Field name from the right table." }, rightTableSource: { type: "object", description: "The right table source.", $ref: "#/definitions/source_schema.json" }, type: { type: "string", description: "String value indicating the type for the dataSource.", enum: ["joinTable"] } }, required: ["type"], additionalProperties: false }, "queryTableDataSource_schema.json": { title: "Query Table DataSource", type: "object", description: "Query table data source is a layer/table that is defined by a SQL query.", properties: { geometryType: { type: "string", description: "The geometry type. When querying a table that does not have a geometry column, do not include geometryType.", enum: ["esriGeometryMultipoint", "esriGeometryPoint", "esriGeometryPolygon", "esriGeometryPolyline"] }, oidFields: { type: "string", description: "Comma separated list of identifier fields. There are only certain field types that can be used as a unique identifier. These field types include integer, string, GUID, and date. If a single integer field is specified, map server uses the values in that field directly to uniquely identify all features and rows returned from a queryTable. However, if a single string field or a group of fields is used as the unique identifier, map server maps those unique values to an integer." }, query: { type: "string", description: "The SQL query." }, spatialReference: { type: "object", description: "The spatial reference of the geometry column. When querying a table that does not have a geometry column, do not include spatialReference.", $ref: "#/definitions/spatialReference_schema.json" }, type: { type: "string", description: "String value indicating the type for the dataSource.", enum: ["queryTable"] }, workspaceId: { type: "string", description: "The unique string value used to identify the datasource's workspace." } }, required: ["type"], additionalProperties: false }, "rasterDataSource_schema.json": { title: "Raster DataSource", type: "object", description: "Raster data source is a file-based raster that resides in a registered raster workspace.", properties: { dataSourceName: { type: "string", description: "The raster datasource's name." }, type: { type: "string", description: "String value indicating the type for the dataSource.", enum: ["raster"] }, workspaceId: { type: "string", description: "The unique string value used to identify the datasource's workspace." } }, required: ["type"], additionalProperties: false }, "tableDataSource_schema.json": { title: "Table DataSource", type: "object", description: "Table data source is a table, feature class, or raster that resides in a registered workspace (either a folder or geodatabase). In the case of a geodatabase, if versioned, use version to switch to an alternate geodatabase version. If version is empty or missing, the registered geodatabase version will be used.", properties: { dataSourceName: { type: "string", description: "The fully-qualified string value used to specify where the dataSource is derived." }, gdbVersion: { type: "string", description: "If applicable, the value indicating the version of the geodatabase." }, type: { type: "string", description: "String value indicating the type for the dataSource. The value for a Table DataSource is `table`.", enum: ["table"] }, workspaceId: { type: "string", description: "The unique string value used to identify the datasource's workspace." } }, required: ["type"], additionalProperties: false }, "border_schema.json": { title: "border", type: "object", description: "Optional border on the line that is used to improve the contrast of the line color against various background colors.", properties: { color: { $ref: "#/definitions/color_schema.json" }, transparency: { type: "integer", description: "A value between `100` (full transparency) and `0` (full opacity).", minimum: 0, maximum: 100, default: 0 } }, required: ["color"], additionalProperties: false }, "font_schema.json": { title: "font", type: "object", description: "Font used for text symbols.", properties: { decoration: { type: "string", description: "The text decoration.", enum: ["line-through", "none", "underline"], default: "none" }, family: { type: "string", description: "The font family." }, size: { type: "number", description: "The font size in points. Ignored when font is used on TextSymbol3DLayer." }, style: { type: "string", description: "The text style.", enum: ["italic", "normal", "oblique"], default: "normal" }, weight: { type: "string", description: "The text weight.", enum: ["bold", "bolder", "lighter", "normal"], default: "normal" } }, additionalProperties: false }, "halo_schema.json": { title: "halo", type: "object", description: "Halo definition.", properties: { color: { $ref: "#/definitions/color_schema.json" }, size: { type: "number", description: "Width of the halo in points." }, transparency: { type: "integer", description: "A value between `100` (full transparency) and `0` (full opacity).", minimum: 0, maximum: 100, default: 0 } }, additionalProperties: false }, "material_schema.json": { title: "Material", type: "object", description: "The material used to shade the geometry.", properties: { color: { $ref: "#/definitions/color_schema.json" }, transparency: { type: "integer", description: "A value between `100` (full transparency) and `0` (full opacity). Ignored if no color is specified.", minimum: 0, maximum: 100 } }, additionalProperties: false }, "colorRamp_schema.json": { title: "Color Ramp", description: "A colorRamp object is used to specify a range of colors that are applied to a group of symbols.", oneOf: [{ $ref: "#/definitions/colorRamp_algorithmic_schema.json" }, { $ref: "#/definitions/colorRamp_multipart_schema.json" }] }, "field_authoringInfo_schema.json": { title: "AuthoringInfo Field", type: "object", description: "Contains information about an attribute field relating to Relationship renderers.", properties: { classBreakInfos: { type: "array", items: { type: "object", $ref: "#/definitions/classBreakInfo_authoringInfo_schema.json" } }, field: { type: "string", description: "Attribute field used for renderer." }, label: { type: "string", description: "The label used to describe the field or attribute in the legend." }, normalizationField: { type: "string", description: "Attribute field used to normalize the data." } }, additionalProperties: false }, "authoringInfo_visualVariable_schema.json": { title: "AuthoringInfo Visual Variable", type: "object", description: "This visual variable pertains specifically to [authoringInfo](authoringInfo.md) and is different from visual variables directly on the [renderer](renderer.md).", properties: { endTime: { type: ["number", "string"], description: "A Unix stamp. Both `startTime` or `endTime` can be fields. If this is the case, their names must be different." }, field: { type: "string", description: "The attribute field the user chose in the Smart Mapping gallery. Must be the same as in either `startTime` or `endTime`." }, maxSliderValue: { type: "number", description: "A numeric value indicating the maximum value displayed." }, minSliderValue: { type: "number", description: "A numeric value indicating the minimum value displayed." }, startTime: { type: ["number", "string"], description: "A Unix time stamp. Both `startTime` or `endTime` can be fields. If this is the case, their names must be different." }, style: { type: "string", description: "(This property is used for comparison rendering). It is used to map the ratio between two numbers. It is possible to express that relationship as percentages, simple ratios, or an overall percentage.", enum: ["percent", "percentTotal", "ratio"] }, theme: { type: "string", description: "Theme to be used only when working with visual variables of type `colorInfo`. Default is `high-to-low`.", enum: ["above-and-below", "centered-on", "extremes", "high-to-low"] }, type: { type: "string", description: "A string value specifying the type of renderer's visual variable.", enum: ["colorInfo", "rotationInfo", "sizeInfo", "transparencyInfo"] }, units: { type: "string", description: "(This property is used only with age renderers.) Units for startTime and endTime.", enum: ["days", "hours", "minutes", "months", "seconds", "years"] } }, additionalProperties: false }, "styleOrigin_schema.json": { title: "styleOrigin", type: "object", description: "The origin of the style from which the symbol was originally referenced. A reference to the style origin can be either by styleName or by styleUrl (but not both). It may be used to understand where a symbol was originally sourced from, but does not affect actual appearance or rendering of the symbol.", properties: { name: { type: "string", description: "Identifies a symbol in the style by name." }, styleName: { type: "string", description: "A registered web style name, such as `EsriThematicShapesStyle`" }, styleUrl: { description: "URL to a style definition.", oneOf: [{ type: "string", description: "An absolute URL" }, { type: "string", description: "A relative path starting with ./", pattern: "^\\./.+$" }] } }, oneOf: [{ required: ["name", "styleName"] }, { required: ["name", "styleUrl"] }], additionalProperties: false }, "fillSymbol3DLayer_schema.json": { title: "FillSymbol3DLayer", type: "object", description: "FillSymbol3DLayer is used to render the surfaces of flat 2D Polygon geometries and 3D volumetric meshes in a SceneView.", properties: { castShadows: { type: "boolean", description: "Boolean to control the shadow casting behaviour of the rendered geometries (only applies to MeshSymbol3D).", default: true }, edges: { $ref: "#/definitions/edges_schema.json" }, enable: { type: "boolean" }, material: { $ref: "#/definitions/materialColorMixMode_schema.json" }, outline: { description: "The outline of the symbol layer (only applies to PolygonSymbol3D).", $ref: "#/definitions/outline_schema.json" }, pattern: { $ref: "#/definitions/polygonPattern_schema.json" }, type: { type: "string", description: "Specifies the type of symbol used.", enum: ["Fill"] } }, required: ["material", "type"], additionalProperties: false }, "extrudeSymbol3DLayer_schema.json": { title: "ExtrudeSymbol3DLayer", type: "object", description: "ExtrudeSymbol3DLayer is used to render Polygon geometries by extruding them upward from the ground, creating a 3D volumetric object.", properties: { castShadows: { type: "boolean", description: "Boolean to control the shadow casting behaviour of the rendered geometries.", default: true }, edges: { type: "object", description: "Specifies an edge visualization style.", $ref: "#/definitions/edges_schema.json" }, enable: { type: "boolean" }, material: { $ref: "#/definitions/material_schema.json" }, size: { type: "number", description: "Extrusion height in meters." }, type: { type: "string", description: "Specifies the type of symbol used.", enum: ["Extrude"] } }, required: ["size", "type"], additionalProperties: false }, "waterSymbol3DLayer_schema.json": { title: "WaterSymbol3DLayer", type: "object", description: "Symbol Layer that describes a water appearance on surfaces in a SceneView.", properties: { color: { description: "The dominant water color.", $ref: "#/definitions/color_schema.json", default: [0, 119, 190] }, enable: { type: "boolean" }, type: { type: "string", description: "Specifies the type of symbol used.", enum: ["Water"] }, waterbodySize: { type: "string", description: "Size of the waterbody the symbol layer represents. Applications will display waves that are appropriate for the chosen body of water, for example ocean versus marina versus swimming pool.", enum: ["large", "medium", "small"], default: "medium" }, waveDirection: { type: "number", description: "Azimuthal bearing for direction of the waves. If ommitted, waves appear directionless. The value is interpreted as 'geographic' rotation, i.e. clockwise starting from north.", minimum: 0, maximum: 360 }, waveStrength: { type: "string", description: "The magnitude of the waves displayed on the waterbody. Strings roughly follow the [Douglas sea scale](https://en.wikipedia.org/wiki/Douglas_sea_scale), currently limited to lower degrees.", enum: ["calm", "moderate", "rippled", "slight"], default: "moderate" } }, required: ["type"], additionalProperties: false }, "iconSymbol3DLayer_schema.json": { title: "IconSymbol3DLayer", type: "object", description: "IconSymbol3DLayer is used to render Point geometries using a flat 2D icon (e.g. a circle) with a PointSymbol3D in a SceneView.", properties: { anchor: { type: "string", enum: ["bottom", "bottomLeft", "bottomRight", "center", "left", "relative", "right", "top", "topLeft", "topRight"], default: "center" }, anchorPosition: { type: "array", description: "When `anchor` equals `relative`, this property specifies the position within the icon that should coincide with the feature geometry. Otherwise it is ignored. The position is defined as a factor of the icon dimensions that is added to the icon center: `positionInIcon = (0.5 + anchorPosition) * size`, where `size` is the original size of the icon resource.", items: { type: "number" }, minItems: 2, maxItems: 2 }, enable: { type: "boolean" }, material: { $ref: "#/definitions/material_schema.json" }, outline: { $ref: "#/definitions/outline_schema.json" }, resource: { $ref: "#/definitions/iconSymbol3DLayer_resource_schema.json" }, size: { type: "number", description: "Icon size in points, positive only", minimum: 0 }, type: { type: "string", description: "Specifies the type of symbol used.", enum: ["Icon"] } }, required: ["size", "type"], additionalProperties: false }, "objectSymbol3DLayer_schema.json": { title: "ObjectSymbol3DLayer", type: "object", description: "ObjectSymbol3DLayer is used to render Point geometries using a volumetric 3D shape (e.g., a sphere or cylinder) with a Symbol3D in a SceneView.", properties: { anchor: { type: "string", description: "The positioning of the object relative to the geometry.", enum: ["bottom", "center", "origin", "relative", "top"], default: "origin" }, anchorPosition: { type: "array", description: "When `anchor` equals `relative`, this property specifies the positioning of the object relative to the geometry as a fraction of the symbol layer's bounding box. Otherwise it is ignored.", items: { type: "number" }, minItems: 3, maxItems: 3 }, castShadows: { type: "boolean", description: "Boolean to control the shadow casting behaviour of the rendered geometries.", default: true }, depth: { type: "number", description: "Object depth in meters, positive only", minimum: 0 }, enable: { type: "boolean" }, heading: { type: "number", description: "Rotation angle around Z axis in degrees. At 0 degrees, the model points in the direction of the Y-axis. Positive values indicate clockwise rotation (when looked at from the top). [Detailed description](static/objectSymbolLayerOrientation.md)." }, height: { type: "number", description: "Object height in meters, positive only", minimum: 0 }, material: { $ref: "#/definitions/material_schema.json" }, resource: { $ref: "#/definitions/objectSymbol3DLayer_resource_schema.json" }, roll: { type: "number", description: "Rotation angle around Y axis in degrees. At 0 degrees, the model is level. A positive value lifts the left part and lowers the right part of the model. [Detailed description](static/objectSymbolLayerOrientation.md)." }, tilt: { type: "number", description: "Rotation angle around X axis in degrees. At 0 degrees, the model is level. A positive value lifts the front and lowers the back of the model. [Detailed description](static/objectSymbolLayerOrientation.md)." }, type: { type: "string", description: "Specifies the type of symbol used.", enum: ["Object"] }, width: { type: "number", description: "Object width in meters, positive only", minimum: 0 } }, required: ["type"], additionalProperties: false }, "lineSymbol3DLayer_schema.json": { title: "LineSymbol3DLayer", type: "object", description: "LineSymbol3DLayer renders Polyline geometries using a flat 2D line with a LineSymbol3D in a 3D SceneView.", properties: { cap: { type: "string", description: "Shape of the beginning and the end of each line geometry.", enum: ["butt", "round", "square"], default: "butt" }, enable: { type: "boolean" }, join: { type: "string", description: "Shape of the intersection of two line segments.", enum: ["bevel", "miter", "round"], default: "miter" }, material: { $ref: "#/definitions/material_schema.json" }, size: { type: "number", description: "Line width in points, positive only", minimum: 0 }, type: { type: "string", description: "Specifies the type of symbol used.", enum: ["Line"] } }, required: ["size", "type"], additionalProperties: false }, "lineSymbol3D_schema.json": { title: "LineSymbol3D", type: "object", description: "LineSymbol3D is used to render features with Polyline geometry in a 3D SceneView.", properties: { styleOrigin: { $ref: "#/definitions/styleOrigin_schema.json" }, symbolLayers: { type: "array", description: "A Collection of Symbol3DLayer objects used to visualize the graphic or feature.", items: { oneOf: [{ $ref: "#/definitions/lineSymbol3DLayer_schema.json" }, { $ref: "#/definitions/pathSymbol3DLayer_schema.json" }] } }, type: { type: "string", description: "Specifies the type of symbol used.", enum: ["LineSymbol3D"] } }, required: ["symbolLayers", "type"], additionalProperties: false }, "meshSymbol3D_schema.json": { title: "MeshSymbol3D", type: "object", description: "MeshSymbol3D is used to render 3D mesh features in a SceneLayer in a 3D SceneView.", properties: { styleOrigin: { $ref: "#/definitions/styleOrigin_schema.json" }, symbolLayers: { type: "array", description: "A Collection of Symbol3DLayer objects used to visualize the graphic or feature.", items: { oneOf: [{ $ref: "#/definitions/fillSymbol3DLayer_schema.json" }] } }, type: { type: "string", description: "Specifies the type of symbol used", enum: ["MeshSymbol3D"] } }, required: ["symbolLayers", "type"], additionalProperties: false }, "pointSymbol3D_schema.json": { title: "PointSymbol3D", type: "object", description: "PointSymbol3D is used to render features with Point geometry in a 3D SceneView.", properties: { callout: { $ref: "#/definitions/callout_schema.json" }, styleOrigin: { $ref: "#/definitions/styleOrigin_schema.json" }, symbolLayers: { type: "array", description: "A Collection of Symbol3DLayer objects used to visualize the graphic or feature.", items: { oneOf: [{ $ref: "#/definitions/iconSymbol3DLayer_schema.json" }, { $ref: "#/definitions/objectSymbol3DLayer_schema.json" }] } }, type: { type: "string", description: "Specifies the type of symbol used", enum: ["PointSymbol3D"] }, verticalOffset: { $ref: "#/definitions/verticalOffset_schema.json" } }, required: ["symbolLayers", "type"], additionalProperties: false }, "styleSymbolReference_schema.json": { title: "StyleSymbolReference", type: "object", description: "The StyleSymbolReference is used to reference a symbol from a portal styleItem", properties: { name: { type: "string", description: "Identifies a symbol in the style by name." }, styleName: { type: "string", description: "A registered web style name, such as `EsriThematicTreesStyle`" }, styleUrl: { type: "string", description: "URL to a style definition." }, type: { type: "string", description: "The type of the symbol", enum: ["styleSymbolReference"] } }, oneOf: [{ required: ["type", "name", "styleUrl"] }, { required: ["type", "name", "styleName"] }], additionalProperties: false }, "colorInfo_visualVariable_schema.json": { title: "ColorInfo Visual Variable", type: "object", description: "The colorInfo visual variable defines how a continuous color ramp is applied to features based on the values of a numeric field attribute.", properties: { field: { type: "string", description: "Attribute field used for color rendering if no valueExpression is provided." }, legendOptions: { type: "object", allOf: [{ $ref: "#/definitions/visualVariableLegendOptions_schema.json" }, { properties: { title: {}, showLegend: {} }, additionalProperties: false }] }, normalizationField: { type: "string", description: "Attribute field used to normalize the data." }, stops: { type: "array", description: "An array of stop objects.", items: { type: "object", $ref: "#/definitions/colorStop_schema.json" } }, type: { type: "string", description: "Specifies the type of visual variable.", enum: ["colorInfo"] }, valueExpression: { type: "string", description: "An [Arcade expression](https://developers.arcgis.com/arcade/) that computes a value in lieu of a value provided by an attribute `field`." }, valueExpressionTitle: { type: "string", description: "The title identifying and describing the associated [Arcade](https://developers.arcgis.com/arcade/) expression as defined in the `valueExpression` property." } }, required: ["type"], additionalProperties: false }, "rotationInfo_visualVariable_schema.json": { title: "RotationInfo Visual Variable", type: "object", description: "The rotation visual variable defines how features rendered with marker symbols are rotated. The rotation value is determined by a value in a field or an Arcade expression calculating a value. Use either the `field` property or `valueExpression` when specifying rotation values.", properties: { axis: { type: "string", description: "Defines the rotation axis the visual variable should be applied to when rendering features with an ObjectSymbol3DLayer. [Detailed description](static/objectSymbolLayerOrientation.md).", enum: ["heading", "roll", "tilt"], default: "heading" }, field: { type: "string", description: "Attribute field used for setting the rotation of a symbol if no `valueExpression` is provided." }, legendOptions: { type: "object", allOf: [{ $ref: "#/definitions/visualVariableLegendOptions_schema.json" }, { properties: { title: {}, showLegend: {} }, additionalProperties: false }] }, rotationType: { type: "string", description: "Defines the origin and direction of rotation depending on how the angle of rotation was measured. Possible values are `geographic` which rotates the symbol from the north in a clockwise direction and `arithmetic` which rotates the symbol from the east in a counter-clockwise direction.", enum: ["arithmetic", "geographic"], default: "geographic" }, type: { type: "string", description: "A string value indicating the type of visual variable used for the renderer.", enum: ["rotationInfo"] }, valueExpression: { type: "string", description: "An [Arcade expression](https://developers.arcgis.com/arcade/) evaluating to a number." }, valueExpressionTitle: { type: "string", description: "The title identifying and describing the associated [Arcade expression] (https://developers.arcgis.com/arcade/) as defined in the `valueExpression` property." } }, required: ["type"], additionalProperties: false }, "sizeInfo_visualVariable_schema.json": { title: "SizeInfo Visual Variable", type: "object", description: "The sizeInfo visual variable defines how size is applied to features based on the values of a numeric field attribute. The minimum and maximum values of the data should be indicated along with their respective size values. You must specify either `minSize` and `maxSize`, or `stops`, or `valueUnit` to construct the size ramp. All features with values falling in between the specified min and max data values (or stops) will be scaled proportionally between the provided min and max sizes.", properties: { axis: { type: "string", description: "Defines the axis the size visual variable should be applied to when rendering features with an ObjectSymbol3DLayer.", enum: ["all", "depth", "height", "width", "widthAndDepth"], default: "all" }, field: { type: "string", description: "Attribute field used for size rendering if no valueExpression is provided." }, legendOptions: { type: "object", allOf: [{ $ref: "#/definitions/visualVariableLegendOptions_schema.json" }, { properties: { customValues: {}, title: {}, showLegend: {} }, additionalProperties: false }] }, maxDataValue: { type: "number", description: "The maximum data value." }, maxSize: { type: "number", description: "Specifies the maximum size to be applied to the symbol. This is required if valueUnit is set to `unknown`." }, minDataValue: { type: "number", description: "The minimum data value." }, minSize: { type: "number", description: "Specifies the minimum size to be applied to the symbol. This is required if valueUnit is set to `unknown`." }, normalizationField: { type: "string", description: "Attribute field used to normalize the data." }, stops: { type: "array", description: "An array of objects that defines the thematic size ramp in a sequence of data or expression stops. At least two stops are required. The stops must be listed in ascending order based on the value of the `value` property in each stop. This property is required if `minDataValue`, `maxDataValue`, `minSize`, and `maxSize` are not defined.", items: { type: "object", $ref: "#/definitions/sizeStop_schema.json" } }, target: { type: "string", description: "Only used when sizeInfo is used for polygon outlines.", enum: ["outline"] }, type: { type: "string", description: "Specifies the type of visual variable.", enum: ["sizeInfo"] }, useSymbolValue: { type: "boolean", description: "When setting a size visual variable on a renderer using an ObjectSymbol3DLayer, this property indicates whether to apply the value defined by the height, width, or depth properties to the corresponding axis of this visual variable instead of proportionally scaling this axis' value after other axes." }, valueExpression: { type: "string", description: "An [Arcade expression](https://developers.arcgis.com/arcade/) evaluating to a number." }, valueExpressionTitle: { type: "string", description: "The title identifying and describing the associated [Arcade](https://developers.arcgis.com/arcade/) expression as defined in the `valueExpression` property." }, valueRepresentation: { type: "string", description: "Specifies how to apply the data value when mapping real-world sizes. See table below for supported values.", enum: ["area", "diameter", "distance", "radius", "width"] }, valueUnit: { type: "string", description: "A string value indicating the unit of measurement. Defaults to `meters` if not set.", enum: ["centimeters", "decimal-degrees", "decimeters", "feet", "inches", "kilometers", "meters", "miles", "millimeters", "nautical-miles", "unknown", "yards"], default: "meters" } }, required: ["type"], additionalProperties: false }, "transparencyInfo_visualVariable_schema.json": { title: "TransparencyInfo Visual Variable", type: "object", description: "The transparencyInfo visual variable defines the transparency, or opacity, of each feature's symbol based on a numeric attribute field value.", properties: { field: { type: "string", description: "Attribute field used for setting the transparency of a feature if no `valueExpression` is provided." }, legendOptions: { type: "object", allOf: [{ $ref: "#/definitions/visualVariableLegendOptions_schema.json" }, { properties: { title: {}, showLegend: {} }, additionalProperties: false }] }, normalizationField: { type: "string", description: "Attribute field used to normalize the data." }, stops: { type: "array", description: "An array of transparencyStop objects.", items: { type: "object", $ref: "#/definitions/transparencyStop_schema.json" } }, type: { type: "string", description: "Specifies the type of visual variable.", enum: ["transparencyInfo"] }, valueExpression: { type: "string", description: "An [Arcade expression](https://developers.arcgis.com/arcade/) evaluating to a number." }, valueExpressionTitle: { type: "string", description: "The title identifying and describing the associated [Arcade](https://developers.arcgis.com/arcade/) expression as defined in the `valueExpression` property." } }, required: ["type"], additionalProperties: false }, "colorClassBreakInfo_schema.json": { title: "colorClassBreakInfo", type: "object", description: "The classBreaksInfo object provides information about the class breaks associated with the renderer.", properties: { classMaxValue: { type: "number", description: "A numeric value used to specify the maximum value for a break." }, classMinValue: { type: "number", description: "A numeric value used to specify discontinuous class breaks. If this value is null or is missing, the map server will calculate the minimum value based on the preceding class' maximum value." }, color: { $ref: "#/definitions/color_schema.json" }, description: { type: "string", description: "String value used to describe the class." }, label: { type: "string", description: "String value used to label the class." } }, required: ["classMaxValue", "classMinValue", "color"], additionalProperties: false }, "colorModulationInfo_schema.json": { title: "colorModulationInfo", type: "object", description: "Indicates whether modulation should be used to render the point.", properties: { field: { type: "string", description: "the attribute to use as a source for the modulation amplitude" }, maxValue: { type: "number", description: "maximum value to compute modulation linear mapping" }, minValue: { type: "number", description: "minimum value to compute modulation linear mapping" } }, required: ["field", "maxValue", "minValue"], additionalProperties: false }, "pointSizeAlgorithm_schema.json": { title: "PointCloud Size Algorithm", type: "object", description: "Size algorithms for point cloud performance.", oneOf: [{ $ref: "#/definitions/pointCloudFixedSizeAlgorithm_schema.json" }, { $ref: "#/definitions/pointCloudSplatAlgorithm_schema.json" }] }, "colorStop_schema.json": { title: "colorStop", description: "A colorStop object describes the renderer's color ramp with more specificity than just colors.", properties: { color: { description: "A CSS color string or an array of rbga values. The color to place at the stop indicated by either a ratio or value.", $ref: "#/definitions/color_schema.json" }, label: { type: "string", description: "Value if a label is needed on the legend for a stop." }, value: { type: "number", description: "The pixel intensity value. Describes the pixel intensity value that the color should be associated with. Just like in colorInfo, using value will ignore `maxPixelIntensity` and `minPixelIntensity` properties. It will actually set those properties to maximum and minimum values you set in the colorStops array. The hard values are converted to ratios to create the color gradient that is used in the heatmap calculations. Setting `minPixelIntensity` or `maxPixelIntensity`, after setting colorStops with values, removes the hard link between the color ramp and the pixel intensity values that were used to create it." } }, required: ["color"] }, "colorUniqueValueInfo_schema.json": { title: "colorUniqueValueInfo", type: "object", description: "The colorUniqueValueInfo object matches a unique value with a specific color.", properties: { color: { $ref: "#/definitions/color_schema.json" }, description: { type: "string", description: "String value used to describe the class." }, label: { type: "string", description: "String value used to label the class." }, values: { type: "array", description: "List of string values used to classify points.", items: { oneOf: [{ type: "string" }] } } }, required: ["color", "values"], additionalProperties: false }, "colormapInfo_schema.json": { title: "ColormapInfo", type: "object", description: "The colormap information used when rendering raster data.", properties: { color: { description: "The pixel color.", $ref: "#/definitions/color_schema.json" }, label: { type: "string", description: "The label used for the pixel value." }, value: { type: "number", description: "The raster pixel value." } }, required: ["color", "value"], additionalProperties: false }, "sketchEdges_schema.json": { title: "Sketch Edges", type: "object", description: "The sketch edge rendering configuration of a symbol layer. Edges of type `sketch` are rendered with a hand-drawn look in mind.", properties: { color: { $ref: "#/definitions/color_schema.json" }, extensionLength: { type: "number", description: "A size in points by which to extend edges beyond their original end points." }, size: { type: "number", description: "Edge size in points, positive only", minimum: 0 }, transparency: { type: "integer", description: "The value has to lie between `100` (full transparency) and `0` (full opacity).", minimum: 0, maximum: 100 }, type: { type: "string", description: "The type of edge visualization.", enum: ["sketch"] } }, required: ["color", "type"], additionalProperties: false }, "solidEdges_schema.json": { title: "Solid Edges", type: "object", description: "The solid edge rendering configuration of a symbol layer. Edges of type `solid` are rendered in a single color, unaffected by scene lighting.", properties: { color: { $ref: "#/definitions/color_schema.json" }, extensionLength: { type: "number", description: "A size in points by which to extend edges beyond their original end points." }, size: { type: "number", description: "Edge size in points, positive only", minimum: 0 }, transparency: { type: "integer", description: "The value has to lie between `100` (full transparency) and `0` (full opacity).", minimum: 0, maximum: 100 }, type: { type: "string", description: "The type of edge visualization.", enum: ["solid"] } }, required: ["color", "type"], additionalProperties: false }, "colorRamp_algorithmic_schema.json": { title: "Color Ramp Algorithmic", description: "A colorRamp object is used to specify a range of colors that are applied to a group of symbols.", properties: { algorithm: { type: "string", description: "Algorithm used for calculating the ramp.", enum: ["esriCIELabAlgorithm", "esriHSVAlgorithm", "esriLabLChAlgorithm"] }, fromColor: { description: "Array representing the initial color to start the ramp from.", $ref: "#/definitions/color_schema.json" }, toColor: { description: "Array representing the final color to end the ramp with.", $ref: "#/definitions/color_schema.json" }, type: { type: "string", description: "Value indicating the type of colorRamp.", enum: ["algorithmic"] } }, additionalProperties: false }, "colorRamp_multipart_schema.json": { title: "Color Ramp Multipart", description: "A colorRamp object is used to specify a range of colors that are applied to a group of symbols.", properties: { colorRamps: { type: "array", description: "A multipart color ramp is defined by a list of constituent color ramps.", items: { type: "object", $ref: "#/definitions/colorRamp_algorithmic_schema.json" } }, type: { type: "string", description: "Value indicating the type of colorRamp.", enum: ["multipart"] } }, additionalProperties: false }, "classBreakInfo_authoringInfo_schema.json": { title: "AuthoringInfo classBreakInfo", type: "object", description: "The classBreaksInfo object provides information about the class breaks associated with the Relationship renderer.", properties: { maxValue: { type: "number", description: "A numeric value used to specify the maximum value for a break." }, minValue: { type: "number", description: "A numeric value used to specify the minimum value for a break." } }, additionalProperties: false }, "materialColorMixMode_schema.json": { title: "Material", type: "object", description: "The material used to shade the geometry, including colorMixMode options.", properties: { color: { $ref: "#/definitions/color_schema.json" }, colorMixMode: { type: "string", description: "Controls how symbolLayer or visualVariable color is applied onto the underlying geometry color/texture. This property only applies to FillSymbol3DLayer within MeshSymbol3D.<br><ul><li>`tint`: the feature's appearance (in terms of color) should be altered to match the symbol / visual variable color.</li><li>`replace`: the feature's color is replaced with the symbol / visual variable color.</li><li>`multiply`: the feature's color is multiplied with the symbol color.</li></ul>", enum: ["multiply", "replace", "tint"] }, transparency: { type: "integer", description: "A value between `100` (full transparency) and `0` (full opacity). Ignored if no color is specified.", minimum: 0, maximum: 100 } }, additionalProperties: false }, "outline_schema.json": { title: "Outline", type: "object", description: "The outline of the symbol layer.", properties: { color: { $ref: "#/definitions/color_schema.json" }, size: { type: "number", description: "Outline size in points, positive only", minimum: 0 }, transparency: { type: "integer", description: "The value has to lie between `100` (full transparency) and `0` (full opacity).", minimum: 0, maximum: 100 } }, required: ["color", "size"], additionalProperties: false }, "polygonPattern_schema.json": { title: "Pattern", type: "object", description: "The pattern used to render the fill of the polygon (only applies to PolygonSymbol3D).", properties: { style: { type: "string", description: "String value representing predefined styles that can be set as polygon fills.", enum: ["backward-diagonal", "cross", "diagonal-cross", "forward-diagonal", "horizontal", "none", "solid", "vertical"] }, type: { type: "string", description: "The type of pattern applied to the polygon fill.", enum: ["style"] } }, required: ["style", "type"], additionalProperties: false }, "iconSymbol3DLayer_resource_schema.json": { title: "IconSymbol3DLayer Resource", type: "object", description: "The shape (primitive) or image URL (href) used to visualize the features.", properties: { dataURI: { type: "string", description: "an image encoded as base64 string, starting with `data:image/`", pattern: "^data:image/(.|\\n|\\r)+$" }, href: { description: "URL to the returned image.", oneOf: [{ type: "string", description: "An absolute URL", pattern: "^https?://.+$" }, { type: "string", description: "A relative path starting with ./", pattern: "^\\./.+$" }] }, primitive: { type: "string", description: "Specifies the type of symbol used.", enum: ["circle", "cross", "kite", "square", "triangle", "x"] } }, oneOf: [{ required: ["primitive"] }, { required: ["href"] }, { required: ["dataURI"] }], additionalProperties: false }, "objectSymbol3DLayer_resource_schema.json": { title: "ObjectSymbol3DLayer Resource", type: "object", description: "The primitive shape (primitive) or external 3D model (href) used to visualize the points.", properties: { href: { oneOf: [{ type: "string", description: "An absolute URL", pattern: "^https?://.+$" }, { type: "string", description: "A relative path starting with ./", pattern: "^\\./.+$" }] }, primitive: { type: "string", enum: ["cone", "cube", "cylinder", "diamond", "invertedCone", "sphere", "tetrahedron"] } }, oneOf: [{ required: ["primitive"] }, { required: ["href"] }], additionalProperties: false }, "pathSymbol3DLayer_schema.json": { title: "PathSymbol3DLayer", type: "object", description: "PathSymbol3DLayer renders polyline geometries by extruding a 2D profile along the line, resulting in visualizations like tubes, walls, etc.", properties: { anchor: { type: "string", description: "The position of the extrusion profile with respect to the polyline geometry.", enum: ["bottom", "center", "top"], default: "center" }, cap: { type: "string", description: "Shape of the beginning and the end of each line geometry.", enum: ["butt", "none", "round", "square"], default: "butt" }, castShadows: { type: "boolean", description: "Boolean to control the shadow casting behaviour of the rendered geometries.", default: true }, enable: { type: "boolean" }, height: { type: "number", description: "Path height in meters. If unspecified, it is equal to `width`.", minimum: 0 }, join: { type: "string", description: "Shape of the intersection of two line segments.", enum: ["bevel", "miter", "round"], default: "miter" }, material: { $ref: "#/definitions/material_schema.json" }, profile: { type: "string", description: "The shape which is extruded along the line.", enum: ["circle", "quad"], default: "circle" }, profileRotation: { type: "string", description: "Specifies the axes about which the profile may be rotated at the joins. Constraining the rotation axes leads to a fixed orientation of the profile for the specified directions.", enum: ["all", "heading"], default: "all" }, size: { type: "number", description: "Path size (diameter) in meters. Ignored if either `width` or `height` are present.", minimum: 0 }, type: { type: "string", description: "Specifies the type of symbol used.", enum: ["Path"] }, width: { type: "number", description: "Path width in meters. If unspecified, it is equal to `height`.", minimum: 0 } }, anyOf: [{ required: ["type", "size"] }, { required: ["type", "width"] }, { required: ["type", "height"] }], additionalProperties: false }, "visualVariableLegendOptions_schema.json": { title: "Visual Variable Legend Options", type: "object", description: "Options available for the legend for visual variables.", properties: { customValues: { type: "array", items: { type: "number" } }, showLegend: { type: "boolean", description: "Indicates whether to show the color/size/opacity ramp in the legend." }, title: { type: "string", description: "The title of the legend." } } }, "sizeStop_schema.json": { title: "sizeStop", description: "A `sizeStop` object describes the size of the symbol at various values of the expression.", properties: { label: { type: "string", description: "Value if a label is needed on the legend for a stop." }, size: { type: "number", description: "Specifies the marker size to use for the specified value." }, value: { type: "number", description: "The value to be mapped to a size." } }, required: ["size", "value"], additionalProperties: false }, "transparencyStop_schema.json": { title: "transparencyStop", description: "The transparencyStop object defines the thematic opacity ramp in a sequence of stops. At least two stops are required. The stops must be listed in ascending order based on the value of the `value` property in each stop.", properties: { label: { type: "string", description: "A string value used to label the stop in the legend." }, transparency: { type: "integer", description: "A numeric transparancy value for a stop ranging from 0-100, where 0 is opaque and 100 is 100% transparent.", minimum: 0, maximum: 100 }, value: { type: "number", description: "The pixel intensity value. Describes the pixel intensity value that the color should be associated with." } }, required: ["transparency", "value"], additionalProperties: false }, "pointCloudFixedSizeAlgorithm_schema.json": { title: "PointCloud FixedSize Algorithm", type: "object", description: "Render points with fixed real world or screen space size.", properties: { size: { type: "number", description: "Symbol size in real world units or display unit" }, type: { type: "string", enum: ["pointCloudFixedSizeAlgorithm"] }, useRealWorldSymbolSizes: { type: "boolean", description: " If true symbol size is in meters, display unit (pt) otherwise" } }, required: ["size", "type"], additionalProperties: false }, "pointCloudSplatAlgorithm_schema.json": { title: "PointCloud Splat Algorithm", type: "object", description: "Render points using sizes depending on point density.", properties: { scaleFactor: { type: "number", description: "Scale factor to applied to the computed point size (in real world)" }, type: { type: "string", enum: ["pointCloudSplatAlgorithm"] } }, required: ["scaleFactor", "type"], additionalProperties: false } };
const i$4 = { title: "Building Scene Layer config on layer item", type: "object", properties: { layers: { type: "array", items: { properties: { activeFilterId: { type: "string", description: "specifies the id of the currently active filter" }, filters: { type: "array", description: "A list of filters available for this layer. Overrides filters defined on the service.", items: { type: "object", $ref: "#/definitions/buildingSceneLayer_filter_schema.json" }, uniqueItems: true }, id: { type: "integer", description: "ID of the service layer." }, layerDefinition: { type: "object", description: "Additional properties that can define an elevation offset for the layer.", allOf: [{ $ref: "#/definitions/layerDefinition_schema.json" }, { properties: { elevationInfo: {}, minScale: {}, maxScale: {} }, additionalProperties: false }] }, listMode: { type: "string", description: "To show or hide the sublayer in the layer list. If the layer has sublayers, selecting `hide-children` will hide them in the layer list.", enum: ["hide", "hide-children", "show"] }, opacity: { type: "number", description: "The degree of transparency applied to the layer on the client side, where 0 is full transparency and 1 is no transparency.", minimum: 0, maximum: 1, default: 1 }, popupInfo: { type: "object", description: "A popupInfo object defining the content of pop-up windows when you click or query a feature.", $ref: "#/definitions/popupInfo_schema.json" }, sublayers: { type: "array", description: "An array of objects specifying overrides for building scene layer sublayers", items: { type: "object", $ref: "#/definitions/buildingSceneLayer_sublayer_schema.json" }, uniqueItems: true }, visibility: { type: "boolean", description: "Boolean property determining whether the layer is initially visible in the web scene", default: true } }, additionalProperties: false } } }, additionalProperties: false, $schema: "http://json-schema.org/draft-07/schema", definitions: e };
const i$3 = { title: "Integrated Mesh Layer config on layer item", type: "object", properties: { layers: { type: "array", items: { properties: { id: { type: "integer", description: "ID of the service layer." }, layerDefinition: { type: "object", description: "A layerDefinition object defining the attribute schema and drawing information for the layer.", allOf: [{ $ref: "#/definitions/layerDefinition_schema.json" }, { properties: { elevationInfo: {}, minScale: {}, maxScale: {} }, additionalProperties: false }] }, listMode: { type: "string", enum: ["hide", "show"] }, modifications: { type: "string", description: "URL to modifications json file, typically stored in `ITEM/resources`. Content of the file follows the $ref:[Modifications schema](modifications_schema.json)." }, opacity: { type: "number", description: "The degree of transparency applied to the layer on the client side, where 0 is full transparency and 1 is no transparency.", minimum: 0, maximum: 1, default: 1 }, visibility: { type: "boolean", description: "Boolean property determining whether the layer is initially visible in the web scene.", default: true } }, additionalProperties: false } } }, additionalProperties: false, $schema: "http://json-schema.org/draft-07/schema", definitions: e };
const i$2 = { title: "PointCloud Layer config on layer item", type: "object", properties: { layers: { type: "array", items: { properties: { disablePopup: { type: "boolean", description: "disablePopups allows a client to ignore popups defined by the service item." }, id: { type: "integer", description: "ID of the service layer." }, layerDefinition: { type: "object", description: "A layerDefinition object defining the attribute schema and drawing information for the layer.", allOf: [{ $ref: "#/definitions/layerDefinition_schema.json" }, { properties: { drawingInfo: { allOf: [{ $ref: "#/definitions/drawingInfo_schema.json" }, { properties: { renderer: {}, transparency: {} }, additionalProperties: false }] }, elevationInfo: {}, filters: {}, minScale: {}, maxScale: {} }, additionalProperties: false }] }, listMode: { type: "string", description: "To show or hide the layer in the layer list", enum: ["hide", "show"] }, popupInfo: { type: "object", description: "A popupInfo object defining the content of pop-up windows when you click a point.", $ref: "#/definitions/popupInfo_schema.json" }, showLegend: { type: "boolean", description: "Boolean value indicating whether to display the layer in the legend. Default value is `true`.", default: true }, visibility: { type: "boolean", description: "Boolean property determining whether the layer is initially visible", default: true } }, additionalProperties: false } } }, additionalProperties: false, $schema: "http://json-schema.org/draft-07/schema", definitions: e };
const i$1 = { title: "Scene Layer config on layer item", type: "object", properties: { layers: { type: "array", items: { properties: { disablePopup: { type: "boolean", description: "disablePopups allows a client to ignore popups defined by the service item." }, id: { type: "integer", description: "ID of the service layer." }, layerDefinition: { type: "object", description: "A layerDefinition object defining the attribute schema and drawing information for the layer.", allOf: [{ $ref: "#/definitions/layerDefinition_schema.json" }, { properties: { definitionExpression: {}, drawingInfo: {}, elevationInfo: {}, featureReduction: {}, minScale: {}, maxScale: {}, rangeInfos: {} }, additionalProperties: false }] }, listMode: { type: "string", description: "To show or hide layers in the layer list", enum: ["hide", "show"] }, opacity: { type: "number", description: "The degree of transparency applied to the layer on the client side, where 0 is full transparency and 1 is no transparency.", minimum: 0, maximum: 1, default: 1 }, popupInfo: { type: "object", description: "A popupInfo object defining the content of pop-up windows when you click or query a feature.", $ref: "#/definitions/popupInfo_schema.json" }, screenSizePerspective: { type: "boolean", description: "Apply [perspective scaling](https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-FeatureLayer.html#screenSizePerspectiveEnabled) to screen-size symbols.", default: false }, showLabels: { type: "boolean", description: "If the layer has a labelingInfo property then labels show on the scene only if the showLabels property it true.", default: false }, showLegend: { type: "boolean", description: "Boolean value indicating whether to display the layer in the legend. Default value is `true`.", default: true }, visibility: { type: "boolean", description: "Boolean property determining whether the layer is initially visible in the web scene", default: true } }, additionalProperties: false } } }, additionalProperties: false, $schema: "http://json-schema.org/draft-07/schema", definitions: e };
const i = new a({ allErrors: true, extendRefs: true });
function m(e2, t$1) {
  return i.validate(e2, c(t$1)) ? [] : t(i.errors);
}
function c(r2) {
  switch (r2) {
    case "building-scene":
      return i$4;
    case "integrated-mesh":
      return i$3;
    case "point-cloud":
      return i$2;
    case "scene":
      return i$1;
    default:
      throw new s("portalitemlayertype:unknown", "Can not validate against unknown PortalItemLayerType.");
  }
}
export { m as validate };
